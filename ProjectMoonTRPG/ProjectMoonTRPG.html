<div id="menuContainer">

<div id="credits"> <div class="creditIcon"></div> 

<div class="creditText">
<span data-i18n="credits0">
<b>Project Moon TRPG</b><br> is a fan-made system based on the games of Project Moon.</span><br><br>

<b><span data-i18n="credits1">Sheet base:</span></b> @ChungMu35<br>
<b><span data-i18n="credits2">Game system:</span></b> @helloing0119<br>
<b><span data-i18n="credits3">Translations:</span></b> @punibird<br>
<b><span data-i18n="credits6">Editing:</span></b> @punibird, BeautifulDemise (Discord)<br>
<b><span data-i18n="credits4">Supported by:</span></b> Project Moon Tabletop Discord<br><br>
<b>Discord:</b> <input type="text" class="darkInput" value="https://discord.gg/AJBnUV5tbVt"><br>
<b><span data-i18n="credits5">System:</span></b> <input type="text" class="darkInput" value="https://drive.google.com/drive/u/2/folders/15nMYLz0sB5xWUiSOG4oN6IsteRJjpdZk">
</div>

<br>
</div>

<div id="settings">
<div class="settingsIcon centerIcon option"></div>

	<div class="rowContainer">
		<div class="settingsText">
			<span class="settingsTitle" data-i18n="settings-general">General Settings</span>
		
			<input type="text" name="attr_messageOverride" value="0" hidden="true">
				
			<label><input type="checkbox" name="attr_settingGenericTokenMode" value="true"><span data-i18n="settings-generictokenmode">Sheet: Generic token mode</span></label>
			
			<label><input type="checkbox" name="attr_settingDistortSave" value="true"><span data-i18n="settings-distortsave">Auto: Save/Load on Distort</span></label>
		
			<label><input type="checkbox" name="attr_settingSimpleDisplay" value="true"><span data-i18n="settings-simpledisplay">Simple roll display</span></label>
		
			<label><input type="checkbox" name="attr_settingExtraEquip" value="true"><span data-i18n="settings-extraequip">Extra weapons/tools/skills</span></label>
		
			<label><input type="checkbox" name="attr_settingHideSpecial" value="true"><span data-i18n="settings-hidespecial">Hide: Special items</span></label>
		
			<label><input type="checkbox" name="attr_settingHelperText" value="true"><span data-i18n="settings-hidehelpertext">Hide:  Helper text</span></label>
		
			<label><input type="checkbox" name="attr_settingHideUses" value="true"><span data-i18n="settings-hideuses">Hide: Uses in messages</span></label>
		
			
			<span class="settingsTitle" data-i18n="settings-combat">Combat Settings</span>

			<label for="LoopEnabled"><input type="checkbox" id="LoopEnabled" name="attr_settingLoopEnabled" value="true"><span data-i18n="settings-autoupdate">Auto: Update on Round end</span></label>
			<input type="checkbox" name="attr_loopEnabled" value="true" hidden="true">
			<input type="number" name="attr_configLoopDelay" value="10000" hidden="true">
			<input type="number" name="attr_configUpdateDelay" value="1000" hidden="true">
			<input type="text" name="attr_configTrackerItemName" value="Round end" hidden="true">

			<label><input type="checkbox" name="attr_settingAutoDetect" value="true" checked><span data-i18n="settings-detect">Auto: Detect combat states</span></label>
		
			<label><input type="checkbox" name="attr_settingTurnUpdate" value="true"><span data-i18n="settings-turnupdate">Auto: Update Turn Order</span></label>
			
			<label><input type="checkbox" name="attr_settingMultihitUses" value="true"><span data-i18n="settings-multihituses">Spend Uses per Multi-hit</span></label>
		
			<label><input type="checkbox" name="attr_settingMultihitFull" value="true"><span data-i18n="settings-multihitfull">No Power debuff on Multi-hit</span></label>


			<span class="settingsTitle" data-i18n="settings-combat-options">Combat Options</span>
			
			<label><input type="checkbox" name="attr_settingTargeting" value="true"><span data-i18n="settings-targeting" checked>Auto: Targeting</span></label>

			<label><input type="checkbox" name="attr_settingLastDefenceRoll" value="true"><span data-i18n="settings-lastdefenceroll" checked>Auto: Last Defence roll</span></label>

			<label><input type="checkbox" name="attr_settingActionTracker" value="true"><span data-i18n="settings-actiontracker" checked>Auto: Action tracker</span></label>
			
			<label><input type="checkbox" name="attr_settingLightRegen" value="true"><span data-i18n="settings-lightregen" checked>Auto: Light regen</span></label>

			<label><input type="checkbox" name="attr_settingCombatToggle" value="true"><span data-i18n="settings-combattoggle" checked>Auto: Combat toggle</span></label>

			<label><input type="checkbox" name="attr_settingHideDetailsFromTargeting" value="true"><span data-i18n="settings-hidedetailsfromtargeting">Hide: Details from targeting</span></label>
		</div>

		<div class="settingsText" style="padding-left: 10px;">
			<span class="settingsTitle" data-i18n="settings-ailments">Ailment Settings</span>

			<label><input type="checkbox" name="attr_settingMuteMessage" value="true"><span data-i18n="settings-mute">Mute ailment messages</span></label>

			<label><input type="checkbox" name="attr_settingLimbusStyle" value="true"><span data-i18n="settings-limbusstyle">Limbus style ailment icons</span></label>

			<label><input type="checkbox" name="attr_settingHideNextTurn" value="true"><span data-i18n="settings-hidenextturn">Hide: Next turn input </span></label>

			<label><input type="checkbox" name="attr_settingBurnImmune" value="true"><span data-i18n="settings-burnimmune">No Burn damage</span></label>
		
			<label><input type="checkbox" name="attr_settingBleedImmune" value="true"><span data-i18n="settings-bleedimmune">No Bleed damage</span></label>


			<span class="settingsTitle" data-i18n="settings-damage-helper">Damage Helper Settings</span>

			<label><input type="checkbox" name="attr_settingAutoApplyDamage" value="true" checked><span data-i18n="settings-autoapplydamage">Auto: Apply damage taken</span></label>

			<label><input type="checkbox" name="attr_settingHideBarUpdate" value="true"><span data-i18n="settings-hidebarupdate">Hide: Status bar update </span></label>


			<span class="settingsTitle" data-i18n="settings-autoeffects">AutoEffect Settings</span>

			<label><input type="checkbox" name="attr_settingCollapseAutoEffectSections" value="true"><span data-i18n="settings-collapsesections">Collapse AutoEffect sections</span></label>

			<label><input type="checkbox" name="attr_settingHideConditionalButtonReminder" value="true"><span data-i18n="settings-hideconditionalreminder">Hide: Conditional button reminder</span></label>

			<label><input type="checkbox" name="attr_settingHideChatButtons" value="true"><span data-i18n="settings-hidechatbuttons">Hide: Chat buttons</span></label>
			
			<label><input type="checkbox" name="attr_settingHideBaseEffect" value="true"><span data-i18n="settings-hidebaseeffect">Hide: Base effects</span></label>
		</div>
	</div>

</div>
</div>
<br>

<div class="player">
	<div><span data-i18n="assessed">Assessed by: </span></div>
	<input type="text" placeholder="Player name" id="playerName" name="attr_player_name" data-i18n-placeholder="playername">
</div>

<div id="logo">
	<img src="https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/images/PMTRPGLogo.png" title="Project Moon TRPG">
</div>

<div class="rowContainer centerFlex">    
	<div id="sheetTitle"><span data-i18n="sheet-title">Background Investigation and Combat Ability Report</span></div>
</div>


<div id="sheetWrapper">

<!-- Generic popup -->
<input type="checkbox" id="messageToggle" name="attr_popup_display" value="true" hidden="true">
<div id="messagePop">
	<div class="rowContainer centerFlex">
		<div class="messageContent columnAlign">
			<div class="messageClose"><label for="messageToggle">x</label></div>

			<input type="text" class="mHeader transpInput" name="attr_popup_messageHeader">
			<textarea type="text" class="mBody transpInput" name="attr_popup_messageBody" style="overflow: hidden;"></textarea>
		</div>
	</div>
</div>


<!-- AutoScript edit popup -->
<input type="checkbox" class="hide-toggle-next" name="attr_autoScriptEditor_display" value="true" hidden="true">
<div id="autoscriptEditor" class="hide-item contentContainer darkBG editorContainer">
	
	<!-- Editor header  -->
	<div class="editorHeader">
		<label for="autoScriptInput" data-i18n="autoscript-editor">AutoScript Editor</label>
		<input type="text" class="editorTarget" name="attr_autoScriptEditorTargetName" readonly>
		<input type="text" name="attr_autoScriptEditorTarget" hidden="true">

		<div class="editorControls">
			<input type="checkbox" class="toggleAliasButton" name="attr_autoScriptEditorTarget" value="autoScriptAlias" hidden="true">
			<input type="checkbox" class="toggleStylingButton" name="attr_autoScriptEditorTarget" value="autoScriptStyling" hidden="true">
			<button type="action" id="autoScriptAlias" class="darkInput" name="act_autoScriptEdit" data-i18n-title="autoscript-editor-aliases-title" title="Open AutoScript Alias Editor" data-i18n="autoscript-editor-aliases">AutoScript Aliases</button>
			<button type="action" id="autoScriptStyling" class="darkInput" name="act_autoScriptEdit" data-i18n-title="autoscript-editor-styling" title="Open AutoScript Styling Editor" data-i18n="autoscript-editor-styling">AutoScript Styling</button>
			<button type="action" id="autoScriptReturn" class="darkInput" name="act_autoScriptEdit" data-i18n-title="autoscript-editor-return" title="Return to Editor" data-i18n="autoscript-editor-return">Return to Editor</button>
			<button type="action" id="autoScriptAliasDefault" class="darkInput" name="act_autoScriptDefault" data-i18n-title="autoscript-editor-aliases-reset" title="Reset Aliases to Default" data-i18n="autoscript-editor-aliases-reset">Reset Aliases to Default</button>
			<button type="action" id="autoScriptStylingDefault" class="darkInput" name="act_autoScriptDefault" data-i18n-title="autoscript-editor-styling-reset" title="Reset Styling to Default" data-i18n="autoscript-editor-styling-reset">Reset Styling to Default</button>
			<button type="action" id="autoScriptClose" class="darkInput mediumIcon exit" name="act_closeAutoScriptEdit" data-i18n-title="autoscript-editor-close" title="Save and close AutoScript Editor"></button>
		</div>
	</div>

	<!-- Editor contents  -->
	<textarea spellcheck="false" class="editorInput lightScroll" name="attr_autoScriptEditorInput"></textarea>

	<!-- Used for data storage -->
	<input type="text" name="attr_autoScriptEditorTargetOld" hidden="true">
	<textarea type="text" name="attr_autoScriptAlias" hidden="true"></textarea>
	<textarea type="text" name="attr_autoScriptAliasDefault" hidden="true"></textarea>
	<textarea type="text" name="attr_autoScriptStyling" hidden="true"></textarea>
	<textarea type="text" name="attr_autoScriptStylingDefault" hidden="true"></textarea>
</div>


<!-- Item edit popup -->
<input type="checkbox" class="hide-toggle-next" name="attr_itemEditor_display" value="true" hidden="true">
<div id="itemEditor" class="hide-item contentContainer columnAlign darkBG editorContainer">
	
	<!-- Editor header  -->
	<div class="editorHeader">
		<label for="itemInput" data-i18n="item-editor">Item Editor</label>
		<input type="text" class="editorTarget" name="attr_itemEditorTargetName" readonly>
		<input type="text" name="attr_itemEditorTarget" hidden="true">
		
		<div class="editorControls">
			<select name="attr_itemEditType" class="darkInput itemType">
				<option value="Weapon" data-i18n="item-type-weapon">Weapon</option>
				<option value="Outfit" data-i18n="item-type-outfit">Outfit</option>
				<option value="Augment" data-i18n="item-type-augment">Augment</option>
				<option value="Tool" data-i18n="item-type-tool">Tool</option>
				<option value="Skill" data-i18n="item-type-skill">Skill</option>
				<option value="Special" data-i18n="item-type-special">Special</option>
			</select>
			<button type="action" id="itemClose" class="darkInput mediumIcon exit" name="act_closeItemEdit" data-i18n-title="item-editor-close" title="Save and close Item Editor"></button>
		</div>
	</div>
	
	
	<!-- Editor contents -->
	<div class="editorScroll darkScroll">
	<div class="itemOptionContainer">

		<!-- Option: Roll formats -->
		<div class="itemOption divide"><label><input type="checkbox" name="attr_itemEditOptionRollFormat" value="true"><span>Roll Format</span></label>
			<div class="rollFormatContainer">
				
				<!-- Custom add repeating rollformat button -->
				<input type="checkbox" class="hide-toggle-rev-next" name="attr_rollFormatAddToggle" value="true" hidden="true">
				<button type="action" class="hide-item-rev btn repcontrol_add" id="add_rollformat" name="act_addItem" data-i18n-title="item-add-rollformat" title="Add new roll format">Add</button>
				
				<fieldset class="repeating_rollformats">
					<div class="rowContainer">

						<!-- Standalone vs. Applied -->
						<select name="attr_rollMode" class="whiteInput">
							<option value="Roll">Roll</option>
							<option value="Applied">Applied</option>
						</select>

						<!-- Roll type -->
						<select name="attr_rollType" class="whiteInput">
							<option value="Any" data-i18n="skill-type-None">---</option>
							<option value="Attack" data-i18n="skill-type-Attack">Attack</option>
							<option value="Block" data-i18n="skill-type-Block">Block</option>
							<option value="Evade" data-i18n="skill-type-Evade">Evade</option>
							<option value="Fortitude" data-i18n="stats-instinct">Fortitude</option>
							<option value="Prudence" data-i18n="stats-wisdom">Prudence</option>
							<option value="Justice" data-i18n="stats-justice">Justice</option>
							<option value="Charm" data-i18n="stats-charm">Charm</option>
							<option value="Insight" data-i18n="stats-insight">Insight</option>
							<option value="Temperance" data-i18n="stats-temperance">Temperance</option>
						</select>

						<!-- Damage type (Attack only) -->
						<input type="checkbox" class="hide-toggle-next" name="attr_rollDamageType" value="Attack">
						<select name="attr_rollDamageType" class="whiteInput hide-item">
							<option value="None" data-i18n="weapon-type-None">---</option>
							<option value="Slash" data-i18n="weapon-type-Slash">Slash</option>
							<option value="Pierce" data-i18n="weapon-type-Pierce">Pierce</option>
							<option value="Blunt" data-i18n="weapon-type-Blunt">Blunt</option>
							<option value="Choose" data-i18n="weapon-type-Choose">Choose</option>
						</select>
		
						<!-- Roll format -->
						<div class="rowContainer combatRoll">
							<div class="rollFormatBlock">
								<input type="number" class="diceCount noSpinner" name="attr_rollCount" value="0">
								<div class="plainText">D</div>
								<input type="number" class="diceMax noSpinner" name="attr_rollMax" value="0">
								<div class="plainText">+</div>
								<input type="number" class="dicePower noSpinner" name="attr_rollPower" value="0">
							</div>
						</div>

						<!-- Roll advantage -->
						<select name="attr_rollAdv" class="darkInput centerIcon advSelect">
							<option value="false" data-i18n="item-none">---</option>
							<option value="Advantage" data-i18n="helper-text-adv">Advantage</option>
							<option value="Disadvantage" data-i18n="helper-text-disadv">Disadvantage</option>
						</select>

						<!-- Roll format AutoScript -->
						<button type="action" class="darkButton autoScriptButton script" name="act_edit-rollautoscript" data-i18n-title="autoscript-edit" title="Edit AutoScript"></button>
						<input type="text" name="attr_rollAutoscript" hidden="true">
					</div>

					<div class="itemOptionContainer inline">

						<!-- Recycle / store roll -->
						<div class="itemOption inline"><label><input type="checkbox" name="attr_optionStoreRoll" value="true"><span>Recycle</span></label>
							<div class="rowContainer combatRoll">
								<div class="rollFormatBlock">
									<input type="number" class="diceCount noSpinner" name="attr_storeCount" value="0">
									<div class="plainText">D</div>
									<input type="number" class="diceMax noSpinner" name="attr_storeMax" value="0">
									<div class="plainText">+</div>
									<input type="number" class="dicePower noSpinner" name="attr_storePower" value="0">
								</div>
							</div>

							<select name="attr_storeAdv" class="darkInput centerIcon advSelect">
								<option value="false" data-i18n="item-none">---</option>
								<option value="Advantage" data-i18n="helper-text-adv">Advantage</option>
								<option value="Disadvantage" data-i18n="helper-text-disadv">Disadvantage</option>
							</select>

							<!-- Recycle AutoScript -->
							<button type="action" class="darkButton autoScriptButton script" name="act_edit-storeautoscript" data-i18n-title="autoscript-edit" title="Edit AutoScript"></button>
							<input type="text" name="attr_storeAutoscript" hidden="true">
						</div>

						<!-- Roll action cost -->
						<div class="itemOption inline"><label><input type="checkbox" name="attr_optionRollAction" value="true"><span>Action</span></label>
							<div class="rowContainer fitContents">
								<input type="checkbox" class="fade-toggle" name="attr_rollActionCost" value="0" hidden="true">
								<div class="fade-item mediumIcon egoSpecial"></div>
								<input type="number" class="fade-item darkInput hoverSpinner" name="attr_rollActionCost" min="0" value="0">
							</div>

							<select name="attr_rollActionType" class="whiteInput">
								<option value="None" data-i18n="item-none">---</option>
								<option value="Action" data-i18n="resource-action">Action</option>
								<option value="Reaction" data-i18n="resource-reaction">Reaction</option>
								<option value="Counter" data-i18n="resource-counter">Counter</option>
								<option value="Block" data-i18n="resource-block">Block</option>
								<option value="Evade" data-i18n="resource-evade">Evade</option>
								<option value="Light_Regen" data-i18n="resource-light-regen">Light Regen</option>
							</select>
						</div>

						<!-- Roll reaction cost -->
						<div class="itemOption inline"><label><input type="checkbox" name="attr_optionRollReaction" value="true"><span>Reaction</span></label>
							<div class="rowContainer fitContents">
								<input type="checkbox" class="fade-toggle" name="attr_rollReactionCost" value="0" hidden="true" checked>
								<div class="fade-item mediumIcon reaction"></div>
								<input type="number" class="fade-item darkInput hoverSpinner" name="attr_rollReactionCost" min="0" value="0">
							</div>

							<select name="attr_rollReactionType" class="whiteInput">
								<option value="None" data-i18n="item-none">---</option>
								<option value="Action" data-i18n="resource-action">Action</option>
								<option value="Reaction" data-i18n="resource-reaction">Reaction</option>
								<option value="Counter" data-i18n="resource-counter">Counter</option>
								<option value="Block" data-i18n="resource-block">Block</option>
								<option value="Evade" data-i18n="resource-evade">Evade</option>
								<option value="Light_Regen" data-i18n="resource-light-regen">Light Regen</option>
							</select>
						</div>

						<!-- Roll uses cost -->
						<div class="itemOption inline"><label><input type="checkbox" name="attr_optionRollUses" value="true"><span>Uses</span></label>
							<div class="rowContainer fitContents">
								<input type="checkbox" class="fade-toggle" name="attr_rollUsesCost" value="0" hidden="true" checked>
								<div class="fade-item mediumIcon reusable"></div>
								<input type="number" class="fade-item darkInput hoverSpinner" name="attr_rollUsesCost" min="0" value="0">
							</div>
						</div>
					</div>
				</fieldset>
			</div>
		</div>


		<!-- Option: Resistances -->
		<div class="itemOption divide"><label><input type="checkbox" name="attr_itemEditOptionResist" value="true"><span>Resistances</span></label>
			<div class="itemOptionContainer">
					
				<!-- Base Damage Resistance -->
				<div class="itemOption inline"><label><input type="checkbox" name="attr_itemEditOptionResistBaseDamage" value="true"><span>Base damage</span></label>
					<div class="columnAlign">
						
						<!-- Slash -->
						<div class="rowContainer">
							<div class="mediumIcon slashNormal"></div>
							<input type="number" class="darkInput noSpinner" name="attr_itemEditSlashBaseHP" min="0" value="1">
							<input type="number" class="darkInput noSpinner" name="attr_itemEditSlashBaseST" min="0" value="1">
							<div class="mediumIcon slashNormalSTG"></div>

							<select name="attr_itemEditSlashBaseMode" class="whiteInput">
								<option value="None" data-i18n="item-none">---</option>
								<option value="Add" data-i18n="import-type-add">Action</option>
								<option value="Replace" data-i18n="import-type-replace">Reaction</option>
							</select>
						</div>

						<!-- Pierce -->
						<div class="rowContainer">
							<div class="mediumIcon pierceNormal"></div>
							<input type="number" class="darkInput noSpinner" name="attr_itemEditPierceBaseHP" min="0" value="1">
							<input type="number" class="darkInput noSpinner" name="attr_itemEditPierceBaseST" min="0" value="1">
							<div class="mediumIcon pierceNormalSTG"></div>

							<select name="attr_itemEditPierceBaseMode" class="whiteInput">
								<option value="None" data-i18n="item-none">---</option>
								<option value="Add" data-i18n="import-type-add">Action</option>
								<option value="Replace" data-i18n="import-type-replace">Reaction</option>
							</select>
						</div>

						<!-- Blunt  -->
						<div class="rowContainer">
							<div class="mediumIcon bluntNormal"></div>
							<input type="number" class="darkInput noSpinner" name="attr_itemEditBluntBaseHP" min="0" value="1">
							<input type="number" class="darkInput noSpinner" name="attr_itemEditBluntBaseST" min="0" value="1">
							<div class="mediumIcon bluntNormalSTG"></div>

							<select name="attr_itemEditBluntBaseMode" class="whiteInput">
								<option value="None" data-i18n="item-none">---</option>
								<option value="Add" data-i18n="import-type-add">Action</option>
								<option value="Replace" data-i18n="import-type-replace">Reaction</option>
							</select>
						</div>
					</div>
				</div>

				<!-- Flat Damage Resistance -->
				<div class="itemOption inline"><label><input type="checkbox" name="attr_itemEditOptionResistFlatDamage" value="true"><span>Flat damage</span></label>
					<div class="columnAlign">
						
						<!-- Slash -->
						<div class="rowContainer centerFlex">
							<div class="rowContainer">
								<input type="checkbox" class="fade-toggle" name="attr_itemEditSlashFlatHP" value="0" hidden="true" checked>
								<div class="fade-item mediumIcon slashNormal"></div>
								<input type="number" class="fade-item darkInput hoverSpinner" name="attr_itemEditSlashFlatHP" min="0" value="0">
							</div>

							<div class="rowContainer">
								<input type="checkbox" class="fade-toggle" name="attr_itemEditSlashFlatST" value="0" hidden="true" checked>
								<input type="number" class="fade-item darkInput hoverSpinner" name="attr_itemEditSlashFlatST" min="0" value="0">
								<div class="fade-item mediumIcon slashNormalSTG"></div>
							</div>

							<select name="attr_itemEditSlashFlatMode" class="whiteInput">
								<option value="None" data-i18n="item-none">---</option>
								<option value="Add" data-i18n="import-type-add">Action</option>
								<option value="Replace" data-i18n="import-type-replace">Reaction</option>
							</select>
						</div>

						<!-- Pierce -->
						<div class="rowContainer centerFlex">
							<div class="rowContainer">
								<input type="checkbox" class="fade-toggle" name="attr_itemEditPierceFlatHP" value="0" hidden="true" checked>
								<div class="fade-item mediumIcon pierceNormal"></div>
								<input type="number" class="fade-item darkInput hoverSpinner" name="attr_itemEditPierceFlatHP" min="0" value="0">
							</div>

							<div class="rowContainer">
								<input type="checkbox" class="fade-toggle" name="attr_itemEditPierceFlatST" value="0" hidden="true" checked>
								<input type="number" class="fade-item darkInput hoverSpinner" name="attr_itemEditPierceFlatST" min="0" value="0">
								<div class="fade-item mediumIcon pierceNormalSTG"></div>
							</div>

							<select name="attr_itemEditPierceFlatMode" class="whiteInput">
								<option value="None" data-i18n="item-none">---</option>
								<option value="Add" data-i18n="import-type-add">Action</option>
								<option value="Replace" data-i18n="import-type-replace">Reaction</option>
							</select>
						</div>

						<!-- Blunt  -->
						<div class="rowContainer centerFlex">
							<div class="rowContainer">
								<input type="checkbox" class="fade-toggle" name="attr_itemEditBluntFlatHP" value="0" hidden="true" checked>
								<div class="fade-item mediumIcon bluntNormal"></div>
								<input type="number" class="fade-item darkInput hoverSpinner" name="attr_itemEditBluntFlatHP" min="0" value="0">
							</div>

							<div class="rowContainer">
								<input type="checkbox" class="fade-toggle" name="attr_itemEditBluntFlatST" value="0" hidden="true" checked>
								<input type="number" class="fade-item darkInput hoverSpinner" name="attr_itemEditBluntFlatST" min="0" value="0">
								<div class="fade-item mediumIcon bluntNormalSTG"></div>
							</div>

							<select name="attr_itemEditBluntFlatMode" class="whiteInput">
								<option value="None" data-i18n="item-none">---</option>
								<option value="Add" data-i18n="import-type-add">Action</option>
								<option value="Replace" data-i18n="import-type-replace">Reaction</option>
							</select>
						</div>
					</div>
				</div>

				<!-- Ailment Resistance -->
				<div class="itemOption inline"><label><input type="checkbox" name="attr_itemEditOptionResistAilments" value="true"><span>Ailments</span></label>
					<div class="columnAlign" style="margin-top: 3px;">

						<!-- Burn/Bleed/Damage Resist -->
						<div class="ailmentResistContainer">
							<div class="rowContainer">
								<input type="checkbox" class="fade-toggle" name="attr_itemEditBurnResist" value="0" hidden="true" checked>
								<div class="fade-item">
									<input type="checkbox" class="swap-toggle" value="true" name="attr_settingLimbusStyle">
									<div class="swap-item-rev mediumIcon burn"></div> <div class="swap-item mediumIcon burn-limbus"></div>
								</div>
								<input type="number" class="fade-item darkInput" name="attr_itemEditBurnResist" value="0">
							</div>
	
							<div class="rowContainer">
								<input type="checkbox" class="fade-toggle" name="attr_itemEditBleedResist" value="0" hidden="true" checked>
								<div class="fade-item">
									<input type="checkbox" class="swap-toggle" value="true" name="attr_settingLimbusStyle">
									<div class="swap-item-rev mediumIcon bleed"></div> <div class="swap-item mediumIcon bleed-limbus"></div>
								</div>
								<input type="number"  class="fade-item darkInput" name="attr_itemEditBleedResist" value="0">
							</div>
	
							<div class="rowContainer">
								<input type="checkbox" class="fade-toggle" name="attr_itemEditDamageResist" value="0" hidden="true" checked>
								<div class="fade-item">
									<input type="checkbox" class="swap-toggle" value="true" name="attr_settingLimbusStyle">
									<div class="swap-item-rev mediumIcon damageResist"></div> <div class="swap-item mediumIcon damageResist-limbus"></div>
								</div>
								<input type="number" class="fade-item darkInput" name="attr_itemEditDamageResist" value="0">
							</div>
						</div>
	
						<!-- Custom Resist -->
						<div class="ailmentResistContainer">
							<fieldset class="repeating_ailments">
								<input type="checkbox" class="hide-toggle" name="attr_ailCustomResistance" hidden="true" value="true">
								<div class="rowContainer hide-item">
									<input type="checkbox" class="fade-toggle" name="attr_itemEditCustomResistanceNum" value="0" hidden="true" checked>
									<img class="fade-item mediumIcon" name="attr_ailIconDisplay">
									<input type="number" class="fade-item darkInput" name="attr_itemEditCustomResistanceNum" value="0">
								</div>
							</fieldset>
						</div>

					</div>
				</div>
			</div>
		</div>


		<!-- Option: Usable (Tool) -->
		<div class="itemOption divide"><label><input type="checkbox" name="attr_itemEditOptionUsable" value="true"><span>Usable</span></label>
			<div class="itemOptionContainer">
			
				<!-- Usable mode -->
				<select name="attr_itemEditUsableType" class="whiteInput" style="width: 160px;">
					<option value="None" data-i18n="item-none">---</option>
					<option value="Standalone" data-i18n="item-usetype-standalone">Standalone: Used like a tool</option>
					<option value="Applied" data-i18n="item-usetype-applied">Applied: Used like a skill</option>
					<option value="Both" data-i18n="item-usetype-both">Both: Used as a tool or skill</option>
				</select>

				<!-- Usable action cost -->
				<div class="itemOption inline"><label><input type="checkbox" name="attr_itemEditOptionUsableAction" value="true"><span>Action</span></label>
					<div class="rowContainer fitContents">
						<input type="checkbox" class="fade-toggle" name="attr_itemEditUsableActionCost" value="0" hidden="true" checked>
						<div class="fade-item mediumIcon egoSpecial"></div>
						<input type="number" class="fade-item darkInput hoverSpinner" name="attr_itemEditUsableActionCost" min="0" value="0">
					</div>

					<select name="attr_itemEditUsableActionType" class="whiteInput">
						<option value="None" data-i18n="item-none">---</option>
						<option value="Action" data-i18n="resource-action">Action</option>
						<option value="Reaction" data-i18n="resource-reaction">Reaction</option>
						<option value="Counter" data-i18n="resource-counter">Counter</option>
						<option value="Block" data-i18n="resource-block">Block</option>
						<option value="Evade" data-i18n="resource-evade">Evade</option>
						<option value="Light_Regen" data-i18n="resource-light-regen">Light Regen</option>
					</select>
				</div>

				<!-- Usable reaction cost -->
				<div class="itemOption inline"><label><input type="checkbox" name="attr_itemEditOptionUsableReaction" value="true"><span>Reaction</span></label>
					<div class="rowContainer fitContents">
						<input type="checkbox" class="fade-toggle" name="attr_itemEditUsableReactionCost" value="0" hidden="true" checked>
						<div class="fade-item mediumIcon reaction"></div>
						<input type="number" class="fade-item darkInput hoverSpinner" name="attr_itemEditUsableReactionCost" min="0" value="0">
					</div>

					<select name="attr_itemEditUsableReactionType" class="whiteInput">
						<option value="None" data-i18n="item-none">---</option>
						<option value="Action" data-i18n="resource-action">Action</option>
						<option value="Reaction" data-i18n="resource-reaction">Reaction</option>
						<option value="Counter" data-i18n="resource-counter">Counter</option>
						<option value="Block" data-i18n="resource-block">Block</option>
						<option value="Evade" data-i18n="resource-evade">Evade</option>
						<option value="Light_Regen" data-i18n="resource-light-regen">Light Regen</option>
					</select>
				</div>

				<!-- Usable item uses cost -->
				<div class="itemOption inline"><label><input type="checkbox" name="attr_itemEditOptionUsableUses" value="true"><span>Uses</span></label>
					<div class="rowContainer fitContents">
						<input type="checkbox" class="fade-toggle" name="attr_itemEditUsableUsesCost" value="0" hidden="true" checked>
						<div class="fade-item mediumIcon reusable"></div>
						<input type="number" class="fade-item darkInput hoverSpinner" name="attr_itemEditUsableUsesCost" min="0" value="0">
					</div>
				</div>
			</div>
		</div>


		<!-- Option: Limited uses -->
		<div class="itemOption divide"><label><input type="checkbox" name="attr_itemEditOptionLimited" value="true"><span>Limited uses</span></label>
			<div class="itemOptionContainer">
			
				<!-- Item uses -->
				<div class="itemOption inline"><label><input type="checkbox" name="attr_itemEditOptionUses" value="true"><span>Uses</span></label>
					<div class="useCounter">
						<input type="checkbox" class="fade-toggle" name="attr_itemEditUsesMax" value="0" hidden="true" checked>
						<div class="fade-item mediumIcon reusable"></div>
						<div class="darkInput useFormat">
							<input type="number" class="fade-item useCurrent transpInput noSpinner" name="attr_itemEditUsesCurrent" min="0" value="0">
							<div class="plainText">/</div>
							<input type="number" class="fade-item useMax transpInput hoverSpinner" name="attr_itemEditUsesMax" min="0" value="0">
						</div>
					</div>

					<select name="attr_itemEditUsesRecharge" class="whiteInput" style="width: 80px;">
						<option value="None" data-i18n="item-none">---</option>
						<option value="Manual" data-i18n="item-recharge-manual">Manual: Manually restore uses</option>
						<option value="Refresh" data-i18n="item-recharge-refresh">Refresh: Restore uses on Refresh</option>
						<option value="Recover" data-i18n="item-recharge-recover">Recover: Restore uses on Recover</option>
						<option value="Combat" data-i18n="item-recharge-combat">Combat: Restore uses on Combat end</option>
						<option value="Round" data-i18n="item-recharge-round">Round: Restore uses on Round end</option>
						<option value="Loaded" data-i18n="item-recharge-loaded">Loaded: Consumes uses from Ammo item</option>
						<option value="Ammo" data-i18n="item-recharge-ammo">Ammo: Used by Loaded items</option>
					</select>
				</div>

				<!-- Light cost -->
				<div class="itemOption inline"><label><input type="checkbox" name="attr_itemEditOptionLightCost" value="true"><span>Light cost</span></label>
					<div class="rowContainer fitContents">
						<input type="checkbox" class="fade-toggle" name="attr_itemEditLightCost" value="0" hidden="true" checked>
						<div class="fade-item mediumIcon light"></div>
						<input type="number" class="fade-item darkInput hoverSpinner" name="attr_itemEditLightCost" min="0" value="0">
					</div>
				</div>
			</div>
		</div>


		<!-- Option: Equip Slots -->
		<div class="itemOption inline divide"><label><input type="checkbox" name="attr_itemEditOptionEquipSlots" value="true"><span>Equip slots</span></label>
			<input type="number" class="darkInput hoverSpinner" name="attr_itemEditSlotUse" placeholder="1">
			<input type="text" class="whiteInput" name="attr_itemEditSlotType" style="width: 112px;" placeholder="Slot type">
		</div>


		<!-- Option: Mystery -->
		<div class="itemOption divide"><label><input type="checkbox" name="attr_itemEditOptionMystery" value="true"><span>Mystery</span></label>
			
			<!-- Unfinished -->
			<input type="text" class="whiteInput" name="attr_itemEditMysteryActivation" placeholder="Mystery activation">
		</div>
		
		
		<!-- Option: Linked -->
		<div class="itemOption inline divide"><label><input type="checkbox" name="attr_itemEditOptionLinked" value="true"><span>Linked</span></label>
			<div class="columnAlign">
				<div class="rowContainer">
					<input type="checkbox" class="whiteInput" name="attr_itemEditLinkedEquipTogether" value="true" data-i18n-title="item-linked-equiptogether" title="Auto: Equip item with linked item">
					<input type="text" class="whiteInput" name="attr_itemEditLinkedName" placeholder="Linked name" style="width: 100px;">
					<input type="text" class="whiteInput" name="attr_itemEditLinkedId" placeholder="Linked id" style="width: 100px;">

					<!-- Add a attribute to all repeating items which matches the currently selected link item in the editor -->
					<!-- Style the dropdown entry for the selected item differently and have the dropdown default to the type of the item -->
					<!-- Maybe have the dropdown be attr_linkedType -->

					<!-- Make sure an item cannot link to itself -->

					<!-- Add a toggle to reveal and hide the selection interface -->
					<select name="attr_itemEditLinkedType" class="whiteInput">
						<option value="false" data-i18n="item-none">---</option>
						<option value="weapons" data-i18n="item-type-weapon">Weapon</option>
						<option value="outfits" data-i18n="item-type-outfit">Outfit</option>
						<option value="augments" data-i18n="item-type-augment">Augment</option>
						<option value="tools" data-i18n="item-type-tool">Tool</option>
						<option value="skills" data-i18n="item-type-skill">Skill</option>
						<option value="specials" data-i18n="item-type-special">Special</option>
						<option value="effects" data-i18n="item-type-effect">Effect</option>
					</select>
				</div>

				<div class="linkedItemSelector">
					
					<!-- Weapons -->
					<input type="checkbox" class="hide-toggle-next" name="attr_itemEditLinkedType" value="weapons" checked>
					<div class="hide-item rowContainer">
						<fieldset class="repeating_weapons">
							<input type="text" class="darkInput" name="attr_name" placeholder="Unnamed weapon">
							<button type="action" class="darkButton" name="act_selectLinkedItem">Select item</button>
						</fieldset>
					</div>

					<!-- Outfits -->
					<input type="checkbox" class="hide-toggle-next" name="attr_itemEditLinkedType" value="outfits" checked>
					<div class="hide-item rowContainer">
						<fieldset class="repeating_outfits">
							<input type="text" class="darkInput" name="attr_name" placeholder="Unnamed outfit">
						</fieldset>
					</div>

					<!-- Add remaining item types later-->
				</div>
			</div>
		</div>


		<!-- Option: Style -->
		<div class="itemOption divide"><label><input type="checkbox" name="attr_itemEditOptionCustomStyle" value="true"><span>Style</span></label>
			<div class="itemOption"><label><input type="checkbox" name="attr_itemEditOptionIcon" value="true"><span>Icon</span></label>
			
				<!-- Unfinished -->
				<input type="text" class="whiteInput" name="attr_itemEditIconSource" placeholder="Icon source">
			</div>

			<!-- Unfinished -->
			<input type="text" class="whiteInput" name="attr_itemEditColor" placeholder="Color">
			<input type="text" class="whiteInput" name="attr_itemEditAccent" placeholder="Accent">
		</div>


		<!-- Option: Custom UI -->
		<div class="itemOption divide"><label><input type="checkbox" name="attr_itemEditOptionCustomUI" value="true"><span>Custom UI</span></label>
			
			<!-- Unfinishes -->
			<input type="checkbox" class="whiteInput" name="attr_itemEditDamageTypeUI" value="true">
			<input type="checkbox" class="whiteInput" name="attr_itemEditRangeUI" value="true">
			<input type="checkbox" class="whiteInput" name="attr_itemEditSpecialUI" value="true">
			<input type="checkbox" class="whiteInput" name="attr_itemEditHalfUI" value="true">
		</div>


		<!-- Option: Tags -->
		<div class="itemOption divide"><label><input type="checkbox" name="attr_itemEditOptionTags" value="true"><span>Tags</span></label>
			<!-- Should be hidden when a game settings is disabled -->
		</div>


		<!-- Option: Card -->
		<div class="itemOption divide"><label><input type="checkbox" name="attr_itemEditOptionCardCombat" value="true"><span>Card</span></label>
			<!-- Should be hidden when a game settings is disabled -->
		</div>

	</div>
	</div>
	<!-- Item options end -->

	<!-- Output text field. Should be hidden before release -->
	 <!-- 
	<textarea spellcheck="false" class="editorInput" name="attr_itemEditorInput" style="min-height: 100px; width: 96%; margin: 3px !important"></textarea>
	 -->
</div>


<!-- Generic token mode instance bar -->
<input type="checkbox" id="genericTokenModeToggle" name="attr_settingGenericTokenMode" value="true" hidden="true">
<div class="contentContainer columnAlign genericTokenContainer">

	<!-- Generic token instances -->
	<div class="rowContainer genericTokenInstanceContainer">
		<fieldset class="repeating_tokens">
			<input type="checkbox" class="style-toggle" name="attr_token_selected" value="true" hidden="true">
			<div class="contentContainer darkBG genericToken">
				<!-- Selection button -->
				<input type="checkbox" class="hide-toggle-rev" name="attr_token_selected" value="true" hidden="true">
				<button type="action" class="hide-item-rev genericTokenSelectButton" name="act_selectinstance"></button>

				<!-- Token attributes -->
				<input type="text" class="tokenName" name="attr_tokenName" placeholder="Token Name" data-i18n-placeholder="token-name" readonly>
				<input type="text" name="attr_tokenId" hidden="true">
				<input type="text" name="attr_tokenAilmentList" hidden="true">

				<!-- Status bars -->
				<div class="bars">
					<input class="Cstat HPtext" type="number" name="attr_HP" value="30">
					<div>
						<input type="checkbox" class="hide-toggle" name="attr_HP_token_display" value="true" hidden="true">
						<input id="HPbarToken" class="hide-item Tstat HPtext" type="number" name="attr_HP_token" value="">
					</div>
					<input class="Mstat HP" type="text" name="attr_HP_max" value="30">
				</div>
				<div class="bars">
					<input class="Cstat egoSTGRtext" type="number" name="attr_StagRes" value="20">
					<div>
						<input type="checkbox" class="hide-toggle" name="attr_StagRes_token_display" value="true" hidden="true">
						<input id="STGRbarToken" class="hide-item Tstat egoSTGRtext" type="number" name="attr_StagRes_token" value="">
					</div>
					<input class="Mstat egoSTGR" type="text" name="attr_StagRes_max" value="20">
				</div>
				<div class="bars">
					<input type="checkbox" class="hide-toggle-rev" name="attr_distortState_token" value="true">
					<div class="hide-item-rev">
						<input id="SANbar" class="Cstat SANtext" type="number" name="attr_SP" value="15">
						<div>
							<input type="checkbox" class="hide-toggle" name="attr_SP_token_display" value="true" hidden="true">
							<input id="SANbarToken" class="hide-item Tstat SANtext" type="number" name="attr_SP_token" value="">
						</div>
						<input class="Mstat SAN" type="text" name="attr_SP_max" value="15">
					</div>
				</div>
				<div class="bars">
					<input id="LIGHTbar" class="Cstat LIGHTtext" type="number" name="attr_Light" value="3">
					<input id="LIGHTbarToken" class="Tstat LIGHTtext" type="number" name="attr_Light_token" value="">
					<input class="Mstat LIGHT" type="text" name="attr_Light_max" value="3">
				</div>

				<!-- Temporary status bars -->
				<input type="text" name="attr_tokenTHP_Sources" value="{}" hidden="true">
				<input type="text" name="attr_tokenTST_Sources" value="{}" hidden="true">

				<!-- Ailment previews -->
				<div class="rowContainer">
					<input type="checkbox" class="hide-toggle-rev" name="attr_tokenAilment1Num" value="0" hidden="true" checked>
					<div class="tokenAilment hide-item-rev">
						<img name="attr_tokenAilment1Icon">
						<input type="text" class="hoverSpinner" name="attr_tokenAilment1Name" hidden="true">
						<input type="number" class="hoverSpinner" name="attr_tokenAilment1Num" min="0" value="0">
					</div>
					<input type="checkbox" class="hide-toggle-rev" name="attr_tokenAilment2Num" value="0" hidden="true" checked>
					<div class="tokenAilment hide-item-rev">
						<img name="attr_tokenAilment2Icon">
						<input type="text" class="hoverSpinner" name="attr_tokenAilment2Name" hidden="true">
						<input type="number" class="hoverSpinner" name="attr_tokenAilment2Num" min="0" value="0">
					</div>
					<input type="checkbox" class="hide-toggle-rev" name="attr_tokenAilment3Num" value="0" hidden="true" checked>
					<div class="tokenAilment hide-item-rev">
						<img name="attr_tokenAilment3Icon">
						<input type="text" class="hoverSpinner" name="attr_tokenAilment3Name" hidden="true">
						<input type="number" class="hoverSpinner" name="attr_tokenAilment3Num" min="0" value="0">
					</div>
					<input type="checkbox" class="hide-toggle-rev" name="attr_tokenAilment4Num" value="0" hidden="true" checked>
					<div class="tokenAilment hide-item-rev">
						<img name="attr_tokenAilment4Icon">
						<input type="text" class="hoverSpinner" name="attr_tokenAilment4Name" hidden="true">
						<input type="number" class="hoverSpinner" name="attr_tokenAilment4Num" min="0" value="0">
					</div>
				</div>

				<!-- States -->
				<input type="text" name="attr_tokenPanicState" value="0" hidden="true">
				<input type="text" name="attr_tokenStaggerState" value="0" hidden="true">
				<input type="text" name="attr_tokenStaggerDuration" value="0" hidden="true">
				<input type="text" name="attr_tokenSealState" value="0" hidden="true">
				<input type="text" name="attr_tokenImmobileState" value="0" hidden="true">
				<input type="text" name="attr_tokenDefeatState" value="0" hidden="true">
			</div>
		</fieldset>

		<!-- Generic token controls -->
		<input type="text" name="attr_tokenId_selected" value="" hidden="true">
		<input type="text" name="attr_tokenId_suppressUpdate" value="false" hidden="true">


		<!-- Theorical way to handle multiple multiple token bars at once
		<input type="number" name="attr_.1HP" > <input type="number" name="attr_.1ST" > <input type="number" name="attr_.1SP" >
		<input type="number" name="attr_.2HP" > <input type="number" name="attr_.2ST" > <input type="number" name="attr_.2SP" >
		<input type="number" name="attr_.1HP_max" value="30" hidden="true"> <input type="number" name="attr_.1ST_max" value="20" hidden="true"> <input type="number" name="attr_.1SP_max" value="15" hidden="true">
		<input type="number" name="attr_.2HP_max" value="30" hidden="true"> <input type="number" name="attr_.2ST_max" value="20" hidden="true"> <input type="number" name="attr_.2SP_max" value="15" hidden="true">
		-->

		<div class="columnAlign genericToken_controls">
			<button type="action" name="act_addToken" placeholder="Add token" data-i18n-placeholder="token-add">Add token</button>
			<button type="action" name="act_addTokenMultiple" placeholder="Add multiple" data-i18n-placeholder="token-add-multiple">Add multiple</button>
			<button type="action" name="act_deleteToken" placeholder="Delete token" data-i18n-placeholder="token-delete">Delete token</button>
		</div>
	</div>
</div>


<div id="TopContainer"> <!-- Top section container -->

<div id="TopColumnL" style="position: relative;"> <!-- Column 1 -->

<div class="profileHeader">
<input type="checkbox" name="attr_distortStateTemp" value="true" hidden="true">
<input type="checkbox" id="attr_distortState" name="attr_distortState" value="true"><label for="attr_distortState" class="distortIcon" data-i18n-title="distort-toggleText" title="Distort"></label>
</div>

<!-- Distortion Top Profile block -->

<div class="columnContent">



<input type="checkbox" class="hide-toggle" name="attr_distortState" value="true">
        <div class="contentContainer hide-item BLACK distortProfile">
	<div class="contentHeader rowContainer BLACK" style="position: relative;">
		<div>
<input class="characterRank" type="text" name="attr_charaRankCalculated" value="@{charRankBase}" placeholder="0" disabled="true" title="Rank" data-i18n-title="rank">
		</div>

		<input type="text" class="transpInput contentName" id="DistortionName" name="attr_distort_name" placeholder="Distortion Name" data-i18n-placeholder="distort-name">

<div id="WorkCounter" style="position: absolute; right: 20px; top: 5px; z-index: 50;">
                            <div class="columnAlign"> 

	<div class="rowContainer centerFlex bars" data-i18n-title="distort-counter-title">
	<input class="Cstat counterText" type="number" name="attr_distortCounter" value="4" min="0">
	<input class="Mstat HPtext" type="text" name="attr_distortCounter_max" value="4">
	</div>

                            </div>
			</div>

	</div>


<div class="columnAlign BLACK work" style="padding-left: 10px; padding-right: 105px; padding-top: 5px; position: relative; margin-bottom: 10px;">

<b data-i18n="distort-workamount-title">Required work amount</b>
	<div id="WorkAmount" class="rowContainer centerFlex workPref" style="margin-top: 5px;">
<input type="text" name="attr_distortWorkBase" value="4" hidden="true">
<input type="text" class="workAmount whiteInput" name="attr_distortWorkBase" value="4" data-i18n-title="distort-workamount-title" title="Required work amount" style="width: 90px; !important; height: 35px !important;">

         </div>

<div class="columnAlign workPref" style="margin-top: 5px;">

<div class="rowContainer">
<input type="text" class="instinct workPref whiteInput" name="attr_distortWorkInstinct" min="-8" max="8" value="0" data-i18n-title="stats-instinct" title="Instinct">
<input type="text" class="wisdom workPref whiteInput" name="attr_distortWorkWisdom" min="-8" max="8" value="0" data-i18n-title="stats-wisdom" title="Wisdom">
<input type="text" class="justice workPref whiteInput" name="attr_distortWorkJustice" min="-8" max="8" value="0" data-i18n-title="stats-justice" title="Justice">
</div>
<div class="rowContainer">
<input type="text" class="charm workPref whiteInput" name="attr_distortWorkCharm" min="-8" max="8" value="0" data-i18n-title="stats-charm" title="Charm">
<input type="text" class="insight workPref whiteInput" name="attr_distortWorkInsight" min="-8" max="8" value="0" data-i18n-title="stats-insight" title="Insight">
<input type="text" class="temperance workPref whiteInput" name="attr_distortWorkTemperance" min="-8" max="8" value="0" data-i18n-title="stats-temperance" title="Temperance">
</div>

<b data-i18n="distort-workpreference">Work Preference</b>

</div>

<div class="columnAlign" style="position: absolute; bottom: 0px; right: 5px;">

<div class="rowContainer centerFlex" data-i18n-title="distort-loweringresults-title" title="Counter-lowering results">
<div>
<input type="checkbox" name="attr_distortResultGood" value="Good" id="result_good" class="expand-toggle">
<label class="status_effect_item expand-btn" for="result_good">
<img src="https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/icons/good.png" class="statusIcon staggered">
</label>
</div>

<div>
<input type="checkbox" name="attr_distortResultNormal" value="Normal" id="result_normal" class="expand-toggle">
<label class="status_effect_item expand-btn" for="result_normal">
<img src="https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/icons/normal.png" class="statusIcon staggered">
</label>
</div>

<div>
<input type="checkbox" name="attr_distortResultBad" value="Bad" id="result_bad" class="expand-toggle">
<label class="status_effect_item expand-btn" for="result_bad">
<img src="https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/icons/bad.png" class="statusIcon staggered">
</label>
</div>

</div>
<b data-i18n="distort-loweringresults">Counter-lowering Results</b>

</div>
</div>


<div class="CharImage distortion" style="right: 5px;"><img name="attr_character_avatar"><div class="CharImageText"><span data-i18n="character-photo">Photo</span></div></div>

<div class="profileData">
<div class="textSection">URL</div>
<input class="CharDetail whiteInput" type="text" name="attr_distort_url" placeholder="External sheet/reference." data-i18n-placeholder="character-url-placeholder"></div>

<div class="profileData">
<div class="textSection"><span data-i18n="character-summary">Summary</span></div>
<textarea spellcheck="false"  name="attr_distort_summary"  class="CharMediumNotes whiteInput" placeholder="General Distortion summary." data-i18n-placeholder="distort-summary-placeholder"></textarea></div>

<div class="profileData">
<div class="textSection"><span data-i18n="distort-behavior">Behavior</span></div>
<textarea spellcheck="false"  name="attr_distort_behavior"  class="CharMediumNotes whiteInput" placeholder="Notes on Distortion behavior." data-i18n-placeholder="distort-behavior-placeholder"></textarea></div>

	<div class="profileData">
	<div class="textSection" data-i18n="distort-taboo">Taboos/Boons</div>
	<textarea spellcheck="false"  name="attr_distort_taboo" class="CharMediumNotes whiteInput" data-i18n-placeholder="distort-taboo-placeholder" placeholder="Distortion taboos."></textarea>
	</div>

<div class="profileData">
<div class="textSection"><span data-i18n="character-combatnote">Combat Notes</span></div>
<textarea spellcheck="false"  name="attr_distort_combatnote"  class="CharMediumNotes whiteInput" placeholder="Reminders for passive effects, extra damage, etc." data-i18n-placeholder="character-combatnote-placeholder"></textarea></div>




<!-- Distortion effects --> 
                <div class="columnContent distortionContainer">

<div class="rowContainer centerFlex BLACK" style="padding: 5px;">
<b data-i18n="distort-effectText">Distortion Effects</b>
</div>

<div class="columnAlign">

<div class="rowContainer">
<textarea spellcheck="false" name="attr_distortDescription" class="distortDescInput instinct" placeholder="Distortion description." data-i18n-placeholder="distort-descAtt" style="margin-bottom: 0px;"></textarea>

	<textarea spellcheck="false" class="distortEffectInput instinct" name="attr_distortEffect" placeholder="Distortion effects." data-i18n-placeholder="distort-effectAtt" style="margin-bottom: 0px;"></textarea>
</div>

<div class="rowContainer">
<textarea spellcheck="false"   name="attr_distortDescription2" class="distortDescInput SANtext" placeholder="Distortion description." data-i18n-placeholder="distort-descDef" style="margin-bottom: 0px;"></textarea>

	<textarea spellcheck="false" class="distortEffectInput SANtext"  name="attr_distortEffect2" placeholder="Distortion effects." data-i18n-placeholder="distort-effectDef" style="margin-bottom: 0px;"></textarea>
</div>

<!-- Distort item buttons -->
<div class="itemButtons">
	<button type="action" class="darkInput shareButton share" name="act_shareDistort" data-i18n-title="share" title="Share info"></button>
	<button type="action" class="darkInput editButton edit" name="act_editMode" data-i18n-title="edit" title="Edit"></button>
	<button type="action" class="darkInput autoScriptButton script" id="egoAutoScript" name="act_autoScriptEdit" data-i18n-title="autoscript-edit" title="Edit AutoScript"></button>
</div>
<!-- Distort item buttons end -->

<!-- Distort edit -->
<input type="checkbox" class="hide-toggle" name="attr_settingEditMode" value="true">
<div class="editCover hide-item">

<div class="columnAlign">
	<div class="rowContainer">
		<div class="rowContainer">
			<input type="checkbox" class="fade-toggle" name="attr_burnResist_ego" value="0" hidden="true" checked>
			<div class="fade-item">
				<input type="checkbox" class="swap-toggle" value="true" name="attr_settingLimbusStyle">
				<div class="swap-item-rev mediumIcon burn"></div> <div class="swap-item mediumIcon burn-limbus"></div>
			</div>
			<input type="number" class="fade-item darkInput" name="attr_burnResist_ego" value="0">
		</div>

		<div class="rowContainer">
			<input type="checkbox" class="fade-toggle" name="attr_bleedResist_ego" value="0" hidden="true" checked>
			<div class="fade-item">
				<input type="checkbox" class="swap-toggle" value="true" name="attr_settingLimbusStyle">
				<div class="swap-item-rev mediumIcon bleed"></div> <div class="swap-item mediumIcon bleed-limbus"></div>
			</div>
			<input type="number" class="fade-item darkInput" name="attr_bleedResist_ego" value="0">
		</div>

		<div class="rowContainer">
			<input type="checkbox" class="fade-toggle" name="attr_damageResist_ego" value="0" hidden="true" checked>
			<div class="fade-item">
				<input type="checkbox" class="swap-toggle" value="true" name="attr_settingLimbusStyle">
				<div class="swap-item-rev mediumIcon damageResist"></div> <div class="swap-item mediumIcon damageResist-limbus"></div>
			</div>
			<input type="number" class="fade-item darkInput" name="attr_damageResist_ego" value="0">
		</div>
	</div>
</div>

<!-- Outfit Custom Ailment Resistances -->
<div class="customResistDisplay">
	<fieldset class="repeating_ailments">
		<input type="checkbox" class="hide-toggle" name="attr_ailCustomResistance" hidden="true" value="true">
		<div class="rowContainer hide-item">
			<input type="checkbox" class="fade-toggle" name="attr_ailCustomResistanceNumEgo" value="0" hidden="true" checked>
			<img class="fade-item mediumIcon" name="attr_ailIconDisplay">
			<input type="number" class="fade-item darkInput" name="attr_ailCustomResistanceNumEgo" value="0">
		</div>
	</fieldset>
</div>

</div>

<!-- Distort edit -->




</div>

<div class="contentHeader rowContainer BLACK" style="height: 40px">

<div class="rowContainer centerFlex distortionRollFormats">
	<div class="rollFormatBlock egoDiceATK" data-i18n-title="distort-weapon-dice" title="Att modifier applied when Distorted.">
		<input type="number" class="diceCount noSpinner" name="attr_distortWeaponDice1" min="1" value="1">
		<div class="plainText">D</div>
		<input type="number" class="diceMax noSpinner" name="attr_distortWeaponDice2" min="0" value="0">
		<div class="plainText">+</div>
		<input type="number" class="dicePower noSpinner" name="attr_distortWeaponDice3" value="0">
	</div>

	<div class="rollFormatBlock egoDiceDEF" data-i18n-title="distort-def-dice" title="Def modifier applied when Distorted." style="margin: 0px !important;">
		<input type="number" class="diceCount noSpinner" name="attr_distortDefDice1" min="1" value="1">
		<div class="plainText">D</div>
		<input type="number" class="diceMax noSpinner" name="attr_distortDefDice2" min="0" value="0">
		<div class="plainText">+</div>
		<input type="number" class="dicePower noSpinner" name="attr_distortDefDice3" value="0">
		</div>

		<div class="rollFormatBlock egoDiceEVD" data-i18n-title="distort-evd-dice" title="Evd modifier applied when Distorted.">
		<input type="number" class="diceCount noSpinner" name="attr_distortEvdDice1" min="1" value="1">
		<div class="plainText">D</div>
		<input type="number" class="diceMax noSpinner" name="attr_distortEvdDice2" min="0" value="0">
		<div class="plainText">+</div>
		<input type="number" class="dicePower noSpinner" name="attr_distortEvdDice3" value="0">
		</div>


</div>

</div></div> <!-- Distortion Effects container -->



                    </div>
                </div>
<!-- Distortion profile END -->


<!-- Top Profile block -->
<div class="columnContent" style="margin-bottom: 5px;">

<input type="checkbox" class="hide-toggle-rev" name="attr_distortState" value="true">
        <div class="contentContainer hide-item-rev">
	<div class="contentHeader rowContainer skillN" style="position: relative;">
		<input type="text" name="attr_charRankBase" value="0" hidden="true">

		<div>
		<input type="text" name="attr_charRankNum" value="0" hidden="true">
<input class="characterRank transpInput" type="text" name="attr_charaRankCalculated" value="@{charRankBase}" placeholder="0" disabled="true" title="Rank" data-i18n-title="rank">
		</div>

<input type="text" name="attr_character_name" hidden="true">
		<input type="text" class="transpInput contentName" id="CharacterName" name="attr_character_nameBase" placeholder="Character Name" data-i18n-placeholder="character-name">

	<div class="rowContainer levelBox">
                        
                        <div id="Level">
                            <div class="columnAlign" style="position: relative;">
			<div class="blocker"></div>
<span data-i18n="character-level">Level</span><input type="text" class="characterLevel darkInput" name="attr_level" id="level_value" value="0">
                            </div>
			</div>

			<div id="EXP">
                            <div class="columnAlign"><span data-i18n="character-exp">EXP</span><input type="number" class="darkInput" name="attr_EXP" value="0"></div>
                        </div>

         </div>

	</div>

<div class="CharImage"><img name="attr_character_avatar"><div class="CharImageText"><span data-i18n="character-photo">Photo</span></div></div>

<div class="profileData">
<div class="textSection"><span data-i18n="character-job">Occupation</span></div>
<input class="CharJob" type="text" name="attr_character_job"></div>
                        
<div class="profileData">
<div class="textSection"><span data-i18n="character-age">Age</span></div>
<input class="CharAge" type="text" name="attr_age"></div>

<div class="profileData">
<div class="textSection"><span data-i18n="character-height">Height</span></div>
<input class="CharHeight" type="text" name="attr_height"></div>

<div class="profileData">
<div class="textSection"><span data-i18n="character-origin">Birthplace</span></div>
<input class="CharOrigin" type="text" name="attr_character_origin"></div>

<div class="profileData">
<div class="textSection"><span data-i18n="character-residence">Residence</span></div>
<input class="CharOrigin" type="text" name="attr_character_residence"></div>

<div class="profileData">
<div class="textSection"><span data-i18n="character-assets">Assets</span></div>
<input class="CharDetail" type="text" name="attr_character_assets" placeholder="Money, items, other assets." data-i18n-placeholder="character-assets-placeholder"></div>

<div class="profileData">
<div class="textSection"><span data-i18n="character-ahn">Ahn</span></div>
<input class="CharDetail" type="text" name="attr_character_ahn" placeholder="500,000 ahn" data-i18n-placeholder="character-ahn-placeholder"></div>

<div class="profileData">
<div class="textSection">URL</div>
<input class="CharDetail" type="text" name="attr_character_url" placeholder="External sheet/reference." data-i18n-placeholder="character-url-placeholder"></div>
                            
<div class="profileData">
<div class="textSection"><span data-i18n="character-summary">Summary</span></div>
<textarea spellcheck="false"  name="attr_character_summary"  class="CharMediumNotes" placeholder="General character summary." data-i18n-placeholder="character-summary-placeholder"></textarea></div>

<div class="profileData">
<div class="textSection"><span data-i18n="character-combatnote">Combat Notes</span></div>
<textarea spellcheck="false"  name="attr_character_combatnote"  class="CharMediumNotes" placeholder="Reminders for passive effects, extra damage, etc." data-i18n-placeholder="character-combatnote-placeholder"></textarea></div>


                    </div>
                </div>
<!-- Top profile END -->


<!-- EGO block -->
                <div class="columnContent" id="mysterySection">

	<input type="checkbox" class="hide-toggle-rev" name="attr_distortState" value="true">
                    <div class="contentContainer egoContainer hide-item-rev">

	<div class="contentHeader rowContainer BLACK">

<input type="text" class="transpInput contentName" name="attr_egoName" placeholder="Mystery name (E.G.O)" data-i18n-placeholder="ego-name" style="margin-left: 35px; width: 100% !important">
	

<div class="iconHolder">

		<div>
		<div class="icon">
		<div class="typeIcon question"></div>
		</div>


		<input type="checkbox" class="hide-toggle" name="attr_egoType" value="Weapon">
		<div class="hide-item">

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Slash" name="attr_egoWeaponType"><div class="type-image typeIcon egoSlash BLACK"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Pierce" name="attr_egoWeaponType"><div class="type-image typeIcon egoPierce BLACK"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Blunt" name="attr_egoWeaponType"><div class="type-image typeIcon egoBlunt BLACK"></div>
		</div>

		<div style="position: absolute; top:0; left: 0; width: 100%;">
		<input type="checkbox" class="transpInput egoCheck" name="attr_egoActiveState" value="true" style="accent-color: #cc4125" title="Activate Mystery" data-i18n-title="ego-activate">
		</div>

		</div>
		</div></div>

		<div>
		<input type="checkbox" class="hide-toggle" name="attr_egoType" value="Outfit">
		<div class="hide-item">
<input type="checkbox" class="transpInput egoCheck" name="attr_egoActiveState" value="true" style="accent-color: #6d9eeb" title="Activate Mystery" data-i18n-title="ego-activate">

		<div class="icon">
		<div class="typeIcon egoDef"></div>
		</div>

		</div></div>

		<div>
		<input type="checkbox" class="hide-toggle" name="attr_egoType" value="Tool">
		<div class="hide-item">
<input type="checkbox" class="transpInput egoCheck" name="attr_egoActiveState" value="true" style="accent-color: #8e7cc3" data-i18n-title="ego-activate" title="Activate Mystery">

		<div class="icon">
		<div class="typeIcon egoAct"></div>
		</div>

		</div></div>

		<div>
		<input type="checkbox" class="hide-toggle" name="attr_egoType" value="Special">
		<div class="hide-item">
		<input type="checkbox" class="transpInput egoCheck" name="attr_egoActiveState" value="true" data-i18n-title="ego-activate" style="accent-color: #cf8c44" title="Activate Mystery">

		<div class="icon">
		<div class="typeIcon egoSpecial"></div>
		</div>

		</div></div>

	</div>

	<div class="rowContainer toolDescription centerFlex BLACK" style="padding-bottom: 5px;">
	<input type="text" class="egoRank whiteInput" name="attr_egoRank" value="0" placeholder="0" data-i18n-title="rank" title="Rank" style="border: none;">

<div class="rowContainer centerFlex BLACK" data-i18n-title="ego-activecondition" title="Activation condition">

	<input type="text" name="attr_egoConditionTemp" hidden="true">
                                        <select name="attr_egoCondition" class="whiteInput half" style="height: 25px; margin-right: 5px;">
                                            <option value="None" data-i18n="ego-active-None">---</option>
                                            <option value="AlwaysActive" data-i18n="ego-active-AlwaysActive">Always active</option>
                                            <option value="HalfHealth" data-i18n="ego-active-HalfHealth">50% health</option>
                                            <option value="OnStagger" data-i18n="ego-active-OnStagger">On stagger</option>
                                            <option value="EnemyDefeat" data-i18n="ego-active-EnemyDefeat">Enemy defeat</option>
                                            <option value="AllyDefeat" data-i18n="ego-active-AllyDefeat">Ally defeat</option>
                                            <option value="Other" data-i18n="ego-active-Other">Other</option>
                                        </select>

                                        <select name="attr_egoType" class="whiteInput half" style="height: 25px; margin-right: 5px;" title="Manifestation type">
                                            <option value="None" data-i18n="ego-type-None">---</option>
                                            <option value="Weapon" data-i18n="ego-type-Weapon">Weapon</option>
                                            <option value="Outfit" data-i18n="ego-type-Outfit">Outfit</option>
                                            <option value="Tool" data-i18n="ego-type-Tool">Tool</option>
                                            <option value="Special" data-i18n="ego-type-Special">Special item</option>
                                        </select>

	</div>

        </div>

<div class="columnAlign">
<input name="attr_egoIdeology" type="text" class="egoIdeologyInput" placeholder="Manifested ideology." data-i18n-placeholder="ego-ideology">

<div class="rowContainer">
	<textarea spellcheck="false"   name="attr_egoDescription" class="egoDescInput" placeholder="Mystery description." data-i18n-placeholder="ego-description" style="margin-bottom: 0px;"></textarea>
	<textarea spellcheck="false"   name="attr_egoEffect" placeholder="Mystery effects." data-i18n-placeholder="ego-effect" style="margin-bottom: 0px;"></textarea>
</div>


<!-- EGO item buttons -->
<div class="itemButtons">
	<button type="action" class="darkInput shareButton share" name="act_shareEgo" data-i18n-title="share" title="Share info"></button>
	<button type="action" class="darkInput editButton edit" name="act_editMode" data-i18n-title="edit" title="Edit"></button>
	<button type="action" class="darkInput autoScriptButton script" id="egoAutoScript" name="act_autoScriptEdit" data-i18n-title="autoscript-edit" title="Edit AutoScript"></button>
	<input type="text" name="attr_egoAutoScript" hidden="true">
</div>
<!-- EGO item buttons end -->


<!-- EGO edit -->
<input type="checkbox" class="hide-toggle" name="attr_settingEditMode" value="true">
<div class="editCover hide-item">


<input type="checkbox" class="hide-toggle-rev" name="attr_egoType" value="Outfit" hidden="true">
	<div class="rowContainer hide-item-rev">
	<div class="settingStyle">
	<div class="settingStyle" style="width: 40px;"><b data-i18n="message-uses">Uses</b>:</div> 

	<input type="text" class="transpInput" style="width: 23px;" name="attr_egoUses" value="5"> / 
	<input type="number" class="darkInput" name="attr_egoUses_max" value="5" min="1">
	<select name="attr_egoUseType" class="darkInput" style="width: 70px; margin-left: 5px;">
		<option data-i18n="uses-nolimit" value="Limitless" selected>No limit</option>
		<option data-i18n="uses-reload" value="Reload">Reload</option>
		<option data-i18n="uses-deplete" value="Deplete">Deplete</option>
	</select>

	</div>
	</div>


<input type="checkbox" class="hide-toggle" name="attr_egoType" value="Outfit" hidden="true">
<div class="hide-item">
<div class="columnAlign">
<div class="rowContainer">
<div class="rowContainer">
<input type="checkbox" class="fade-toggle" name="attr_burnResist_ego" value="0" hidden="true" checked>

        <div class="ailmentIconSelector status_effect_item rowContainer centerFlex">
	<div class="icon">
	<input type="checkbox" class="hide-toggle-rev" value="true" name="attr_settingLimbusStyle"><div class="hide-item-rev skillIcon burn"></div>
	</div>

	<div class="icon">
	<input type="checkbox" class="expand-toggle" value="true" name="attr_settingLimbusStyle"><div class="type-image skillIcon burn-limbus"></div>
	</div>
	</div>

        <div class="status_effect_value"><input type="number" class="ailmentNum" name="attr_burnResist_ego" value="0"></div>
</div>

<div class="rowContainer">
<input type="checkbox" class="fade-toggle" name="attr_bleedResist_ego" value="0" hidden="true" checked>

        <div class="ailmentIconSelector status_effect_item rowContainer centerFlex">
	<div class="icon">
	<input type="checkbox" class="hide-toggle-rev" value="true" name="attr_settingLimbusStyle"><div class="hide-item-rev skillIcon bleed"></div>
	</div>

	<div class="icon">
	<input type="checkbox" class="expand-toggle" value="true" name="attr_settingLimbusStyle"><div class="type-image skillIcon bleed-limbus"></div>
	</div>
	</div>

       <div class="status_effect_value"><input type="number"  class="ailmentNum" name="attr_bleedResist_ego" value="0"></div>
</div>

<div class="rowContainer">
<input type="checkbox" class="fade-toggle" name="attr_damageResist_ego" value="0" hidden="true" checked>

	<div class="ailmentIconSelector status_effect_item rowContainer centerFlex">
		<div class="icon">
			<input type="checkbox" class="hide-toggle-rev" value="true" name="attr_settingLimbusStyle"><div class="hide-item-rev skillIcon damageResist"></div>
		</div>

		<div class="icon">
			<input type="checkbox" class="expand-toggle" value="true" name="attr_settingLimbusStyle"><div class="type-image skillIcon damageResist-limbus"></div>
		</div>
	</div>
	
	<div class="status_effect_value"><input type="number" class="ailmentNum" name="attr_damageResist_ego" value="0"></div>
</div>
</div>

<!-- EGO Custom Ailment Resistances -->
<div class="customResistDisplay">
	<fieldset class="repeating_ailments">
		<input type="checkbox" class="hide-toggle" name="attr_ailCustomResistance" hidden="true" value="true">
		<div class="rowContainer hide-item">
			<input type="checkbox" class="fade-toggle" name="attr_ailCustomResistanceNumEgo" value="0" hidden="true" checked>
			<div class="status_effect_item rowContainer centerFlex">
				<!-- Icon selector -->
				<div class="ailmentIconSelector rowContainer centerFlex">
					<div class="icon">
					<img name="attr_ailIconDisplay" class="skillIcon">
					</div>
				</div>
			</div>
			<div class="status_effect_value"><input type="number" class="ailmentNum" name="attr_ailCustomResistanceNumEgo" value="0"></div>
		</div>
	</fieldset>
</div>
</div>
</div>

<!-- EGO edit -->
</div>
</div>

<!-- Weapon EGO menu -->
<div class="rowContainer centerFlex">
<input type="checkbox" class="hide-toggle" name="attr_egoType" value="Weapon" hidden="true">
<div class="hide-item BLACK centerFlex" style="width: 100%; padding-top: 5px; padding-bottom: 5px;">

<div class="rowContainer centerFlex">

	<div class="rollFormatBlock egoDiceATK" data-i18n-title="ego-weapon-dice" title="Att dice applied when Mystery is active." style="margin-bottom: 5px;">
		<input type="number" class="diceCount noSpinner" name="attr_egoWeaponDice1" min="1" value="1">
		<div class="plainText">D</div>
		<input type="number" class="diceMax noSpinner" name="attr_egoWeaponDice2" min="0" value="0">
		<div class="plainText">+</div>
		<input type="number" class="dicePower noSpinner" name="attr_egoWeaponDice3" value="0">
		</div>



	</div>

	<select name="attr_egoWeaponType" class="weapon_type whiteInput">
 	<option value="None"   data-i18n="weapon-type-None">---</option>
         <option value="Slash" data-i18n="weapon-type-Slash">Slash</option>
         <option value="Pierce" data-i18n="weapon-type-Pierce">Pierce</option>
	 <option value="Blunt" data-i18n="weapon-type-Blunt">Blunt</option>
         </select>

	<select name="attr_egoWeaponRange" class="weapon_type whiteInput">
 	<option value="None"   data-i18n="weapon-type-None">---</option>
         <option value="Melee" data-i18n="weapon-type-Melee">Melee</option>
         <option value="Ranged" data-i18n="weapon-type-Ranged">Ranged</option>
         </select>

</div>
</div>
<!-- Weapon EGO menu END -->


<!-- Outfit EGO menu -->
<input type="checkbox" class="hide-toggle" name="attr_egoType" value="Outfit" hidden="true">
<div class="hide-item BLACK" style="padding-top: 5px; padding-bottom: 5px; width: 100%;">

	<div class="rowContainer centerFlex BLACK" style="margin-bottom: 5px;">

		<div class="rollFormatBlock egoDiceDEF" data-i18n-title="ego-defend-dice" title="Def dice applied when Mystery is active.">
		<input type="number" class="diceCount noSpinner" name="attr_egoDefDice1" min="1" value="1">
		<div class="plainText">D</div>
		<input type="number" class="diceMax noSpinner" name="attr_egoDefDice2" min="0" value="0">
		<div class="plainText">+</div>
		<input type="number" class="dicePower noSpinner" name="attr_egoDefDice3" value="0">
		</div>

		<div class="rollFormatBlock egoDiceEVD" data-i18n-title="ego-evade-dice" title="Evd dice applied when Mystery is active.">
		<input type="number" class="diceCount noSpinner" name="attr_egoEvdDice1" min="1" value="1">
		<div class="plainText">D</div>
		<input type="number" class="diceMax noSpinner" name="attr_egoEvdDice2" min="0" value="0">
		<div class="plainText">+</div>
		<input type="number" class="dicePower noSpinner" name="attr_egoEvdDice3" value="0">
		</div>

	</div>

	<div class="rowContainer centerFlex" style="width: 100%;">

	<div class="rowContainer resistanceChart BLACK" style="width: 200px;">
		<div class="rowContainer centerFlex">

	<div id="outfit_res_slash">
		<div class="resIconLeft">
		<div class="resistIcon slashNormal"></div>
		</div>
	</div>
                            <select name="attr_egoImmune1" class="outfitresistVal whiteInput dmg">
				<option data-i18n="outfit-res-none" value="" selected disabled hidden>---</option>
                                <option data-i18n="outfit-res-fatal" value="2">[x2]Fatal</option>
                                <option data-i18n="outfit-res-weak" value="1.5">[x1.5]Weak</option>
                                <option data-i18n="outfit-res-normal" value="1">[x1]Normal</option>
                                <option data-i18n="outfit-res-endured" value="0.5">[x0.5]Endured</option>
                                <option data-i18n="outfit-res-ineffective" value="0.25">[x0.25]Ineffective</option>
                                <option data-i18n="outfit-res-immune" value="0">[x0]Immune</option>
                            </select>

                            <select name="attr_egoImmune2" class="outfitresistVal whiteInput stg">
				<option data-i18n="outfit-res-none" value="" selected disabled hidden>---</option>
                                <option data-i18n="outfit-res-fatal" value="2">[x2]Fatal</option>
                                <option data-i18n="outfit-res-weak" value="1.5">[x1.5]Weak</option>
                                <option data-i18n="outfit-res-normal" value="1">[x1]Normal</option>
                                <option data-i18n="outfit-res-endured" value="0.5">[x0.5]Endured</option>
                                <option data-i18n="outfit-res-ineffective" value="0.25">[x0.25]Ineffective</option>
                                <option data-i18n="outfit-res-immune" value="0">[x0]Immune</option>
                            </select>

<div id="outfit_res_slashSTG">
		<div class="resIconRight">
		<div class="resistIcon slashNormalSTG"></div>
		</div>
	</div>
		</div>

		<div class="rowContainer centerFlex">
<div id="outfit_res_pierce">
		<div class="resIconLeft">
		<div class="resistIcon pierceNormal"></div>
		</div>
	</div>
                            <select name="attr_egoImmune3" class="outfitresistVal whiteInput dmg">
				<option data-i18n="outfit-res-none" value="" selected disabled hidden>---</option>
                                <option data-i18n="outfit-res-fatal" value="2">[x2]Fatal</option>
                                <option data-i18n="outfit-res-weak" value="1.5">[x1.5]Weak</option>
                                <option data-i18n="outfit-res-normal" value="1">[x1]Normal</option>
                                <option data-i18n="outfit-res-endured" value="0.5">[x0.5]Endured</option>
                                <option data-i18n="outfit-res-ineffective" value="0.25">[x0.25]Ineffective</option>
                                <option data-i18n="outfit-res-immune" value="0">[x0]Immune</option>
                            </select>

                            <select name="attr_egoImmune4" class="outfitresistVal whiteInput stg">
				<option data-i18n="outfit-res-none" value="" selected disabled hidden>---</option>
                                <option data-i18n="outfit-res-fatal" value="2">[x2]Fatal</option>
                                <option data-i18n="outfit-res-weak" value="1.5">[x1.5]Weak</option>
                                <option data-i18n="outfit-res-normal" value="1">[x1]Normal</option>
                                <option data-i18n="outfit-res-endured" value="0.5">[x0.5]Endured</option>
                                <option data-i18n="outfit-res-ineffective" value="0.25">[x0.25]Ineffective</option>
                                <option data-i18n="outfit-res-immune" value="0">[x0]Immune</option>
                            </select>


<div id="outfit_res_pierceSTG">
		<div class="resIconRight">
		<div class="resistIcon pierceNormalSTG"></div>
		</div>
	</div>

		</div>

		<div class="rowContainer centerFlex">
<div id="outfit_res_blunt">
		<div class="resIconLeft">
		<div class="resistIcon bluntNormal"></div>
		</div>
	</div>


                            <select name="attr_egoImmune5" class="outfitresistVal whiteInput dmg">
				<option data-i18n="outfit-res-none" value="" selected disabled hidden>---</option>
                                <option data-i18n="outfit-res-fatal" value="2">[x2]Fatal</option>
                                <option data-i18n="outfit-res-weak" value="1.5">[x1.5]Weak</option>
                                <option data-i18n="outfit-res-normal" value="1">[x1]Normal</option>
                                <option data-i18n="outfit-res-endured" value="0.5">[x0.5]Endured</option>
                                <option data-i18n="outfit-res-ineffective" value="0.25">[x0.25]Ineffective</option>
                                <option data-i18n="outfit-res-immune" value="0">[x0]Immune</option>
                            </select>

                            <select name="attr_egoImmune6" class="outfitresistVal whiteInput stg">
				<option data-i18n="outfit-res-none" value="" selected disabled hidden>---</option>
                                <option data-i18n="outfit-res-fatal" value="2">[x2]Fatal</option>
                                <option data-i18n="outfit-res-weak" value="1.5">[x1.5]Weak</option>
                                <option data-i18n="outfit-res-normal" value="1">[x1]Normal</option>
                                <option data-i18n="outfit-res-endured" value="0.5">[x0.5]Endured</option>
                                <option data-i18n="outfit-res-ineffective" value="0.25">[x0.25]Ineffective</option>
                                <option data-i18n="outfit-res-immune" value="0">[x0]Immune</option>
                            </select>

<div id="outfit_res_bluntSTG">
		<div class="resIconRight">
		<div class="resistIcon bluntNormalSTG"></div>
		</div>
	</div>


		</div>
</div>
</div>

</div>
<!-- Outfit EGO menu end -->

<!-- Tool EGO menu -->
<div class="rowContainer centerFlex">
<input type="checkbox" class="hide-toggle" name="attr_egoType" value="Tool" hidden="true">
<div class="hide-item BLACK centerFlex" style="width: 100%; padding-top: 5px; padding-bottom: 5px;">

<div class="rowContainer centerFlex">



</div>
</div>

</div>
<!-- Tool EGO menu END -->

<!-- Special EGO menu -->
<div class="rowContainer centerFlex">
<input type="checkbox" class="hide-toggle" name="attr_egoType" value="Special" hidden="true">
<div class="hide-item BLACK centerFlex" style="width: 100%; padding-top: 5px; padding-bottom: 5px;">

<div class="columnAlign">


<div class="rowContainer centerFlex egoSpecialLabel">
<span data-i18n="special-risk-text">Risk Level</span>
<select name="attr_egoRisk" class="whiteInput" style="text-align: center;">
			<option data-i18n="special-risk-none" value="none">---</option>
			<option data-i18n="special-risk-0" value="0">Canard</option>
			<option data-i18n="special-risk-1" value="1">Urban Myth</option>
			<option data-i18n="special-risk-2" value="2">Urban Legend</option>
			<option data-i18n="special-risk-3" value="3">Urban Plague</option>
			<option data-i18n="special-risk-4" value="4">Urban Nightmare</option>
			<option data-i18n="special-risk-5" value="5">Star of the City</option>
			<option data-i18n="special-risk-6" value="6">Impuritas Civitatis</option>
		</select>
</div>


<div class="rowContainer centerFlex egoSpecialLabel">
	<span data-i18n="special-range-text">Effect Range</span>
 		<select name="attr_egoRange" class="whiteInput" id="ego_range" style="text-align: center;">
                          <option data-i18n="special-range-none" value="none">---</option>
                          <option data-i18n="special-range-0" value="0">One or two people</option>
                          <option data-i18n="special-range-1" value="1">Street</option>
                          <option data-i18n="special-range-2" value="2">Neighborhood</option>
                          <option data-i18n="special-range-3" value="3">Residence Area</option>
                          <option data-i18n="special-range-4" value="4">Nest</option>
                          <option data-i18n="special-range-5" value="5">Multiple Nests</option>
                          <option data-i18n="special-range-6" value="6">City</option>
               	</select>
</div>


<div class="rowContainer centerFlex egoSpecialLabel">
	<span data-i18n="special-duration-text">Duration</span>
		<select name="attr_egoDuration" class="whiteInput" id="ego_duration" style="text-align: center;">
			<option data-i18n="special-duration-none" value="none">---</option>
			<option data-i18n="special-duration-0" value="0">A moment</option>
			<option data-i18n="special-duration-1" value="1">Seconds</option>
			<option data-i18n="special-duration-2" value="2">Minutes</option>
			<option data-i18n="special-duration-3" value="3">Hours</option>
			<option data-i18n="special-duration-4" value="4">Days</option>
			<option data-i18n="special-duration-5" value="5">Weeks</option>
			<option data-i18n="special-duration-6" value="6">Months</option>
              	</select>
</div>


</div>
</div>
</div>
<!-- Special EGO menu END -->



</div> <!-- end EGO container -->


</div>
</div>

<div id="TopColumnM"> <!-- column 2 -->
<div class="rowContainer sectionHeader">
	<button type="action" name="act_resetHealth" data-i18n-title="reset-button" title="Reset"> ! </button> <h4 data-i18n="heading-derived">Derived values</h4>
	<button type="action" class="centerIcon heal" name="act_recover" data-i18n-title="recover-button" title="Recover: Benefit from a short rest"></button>
</div>

<div class="contentContainer darkBG">

<!-- row 1 -->
<div class="rowContainer">
<input type="text" name="attr_dummy" value="0" hidden="true">
<input type="text" name="attr_dummy2" value="0" hidden="true">
<input type="text" name="attr_dummyIcon" value="0" hidden="true">

<div class="banner HPtext"><span data-i18n="bar-health">Health</span>
	<div class="rowContainer centerFlex bars">
	<input type="checkbox" class="style-toggle-rev" name="attr_THP_Sources" value="{}" hidden="true">
	<input id="HPbar" class="Cstat HPtext" type="number" name="attr_HP" value="30">
	<input class="Mstat HP" type="text" name="attr_HP_max" value="30">
	</div>
</div>

	<div class="banner egoSTGRtext"><span data-i18n="bar-stagres">Stagger Res</span>
	<div class="rowContainer centerFlex bars">
	<input type="checkbox" class="style-toggle-rev" name="attr_TST_Sources" value="{}" hidden="true">
	<input id="STGRbar" class="Cstat egoSTGRtext" type="number" name="attr_StagRes" value="20">
	<input class="Mstat egoSTGR" type="text" name="attr_StagRes_max" value="20">

	</div>
</div>

</div>

<!-- row 2 -->
		<div class="rowContainer">
	<div class="banner SANtext"><span data-i18n="bar-sanity">Sanity</span>
	<div class="rowContainer centerFlex bars">

	<input type="checkbox" class="hide-toggle-rev" name="attr_distortState" value="true" >
	<div class="hide-item-rev">
	<input id="SANbar" class="Cstat SANtext" type="number" name="attr_SP" value="15">
	<input class="Mstat SAN" type="text" name="attr_SP_max" value="15">
	</div>

	<input type="checkbox" class="hide-toggle" name="attr_distortState" value="true" >
	<div class="hide-item" data-i18n="message-distorted" style="text-align: center; opacity: 50%;">
	Distorted
	</div>

	</div>
</div>

	<div class="banner LIGHTtext"><span data-i18n="bar-light">Light</span>
	<div class="rowContainer centerFlex bars">
	<input id="LIGHTbar" class="Cstat LIGHTtext" type="number" name="attr_Light" value="3">
	<input class="Mstat LIGHT" type="text" name="attr_Light_max" value="3">
	</div>
</div>
</div>
</div>



<!-- Damage & healing helpers -->
<div class="rowContainer sectionHeader">
	<button type="action" name="act_resetDamageHelper" data-i18n-title="reset-button" title="Reset"> ! </button> <h4 data-i18n="heading-damagehelper">Damage helper</h4>
</div>

<div class="contentContainer darkBG">
	<input type="checkbox" class="helperText" name="attr_settingHelperText" value="true" hidden="true">
	<div class="rowContainer damageHelperContainer helperTextContainer">
		<div class="columnAlign damageHelperType">
			<input type="radio" id="damageHelperNone" name="attr_damageHelperType" value="None" checked>

			<input type="radio" id="damageHelperSlash" name="attr_damageHelperType" value="Slash">
			<label for="damageHelperSlash" class="type-image typeIcon slash" data-i18n-title="weapon-type-Slash" title="Slash"></label>

			<input type="radio" id="damageHelperPierce" name="attr_damageHelperType" value="Pierce">
			<label for="damageHelperPierce" class="type-image typeIcon pierce" data-i18n-title="weapon-type-Pierce" title="Pierce"></label>

			<input type="radio" id="damageHelperBlunt" name="attr_damageHelperType" value="Blunt">
			<label for="damageHelperBlunt" class="type-image typeIcon blunt" data-i18n-title="weapon-type-Blunt" title="Blunt"></label>
		</div>

		<div class="columnAlign baseDamage helpers">
			<b data-i18n="helper-text-basedamage">Base Damage</b>
			<input type="number" class="whiteInput baseDamageInput" name="attr_baseDamage" value="0" min="0" data-i18n-title="helper-text-basedamage" title="Base damage">
		</div>
		<div class="columnAlign flatDamage helpers" style="margin-left: 2px;">
			<b data-i18n="helper-text-flatdamagehp">Flat HP DMG</b>
			<input type="number" class="whiteInput flatHPInput hoverSpinner" name="attr_flatDamageHP" value="0" data-i18n-title="helper-text-flatdamagehp" title="Flat HP DMG">
		</div>
		<div class="columnAlign flatDamage helpers" style="margin-right: 1px;">
			<b data-i18n="helper-text-flatdamagest">Flat ST DMG</b>
			<input type="number" class="whiteInput flatSTInput hoverSpinner" name="attr_flatDamageST" value="0" data-i18n-title="helper-text-flatdamagest" title="Flat ST DMG">
		</div>
		<div class="columnAlign applyDamage helpers">
			<b data-i18n="helper-text-applydamage">Apply damage</b>
			<button type="action" class="applyDamageInput" name="act_applyDamage" data-i18n-title="helper-text-applydamage" title="Apply damage"></button>
		</div>
	</div>
	<input type="text" name="attr_THP_Sources" value="{}" hidden="true">
	<input type="text" name="attr_TST_Sources" value="{}" hidden="true">
</div>
<!-- Damage & healing helpers end -->



<!-- Status ailments -->
<div id="ailmentBlock">
	<input type="text" name="attr_ailmentList" hidden>

	<!-- Section header -->
	<div class="rowContainer sectionHeader"><button type="action" name="act_resetAilments" data-i18n-title="reset-button" title="Reset"> ! </button>
		<h4 data-i18n="heading-ailments">Status ailments</h4>

		<button type="action" class="centerIcon next" name="act_updateAilments" data-i18n-title="helper-update-ailments" title="Update Ailments">
			<input type="checkbox" name="attr_settingLoopEnabled" class="loopEnabledToggle" value="true" hidden="true">
			<input type="checkbox" name="attr_prevRoundInitAttempts" class="loopSearchingToggle" value="0" hidden="true">
			<input type="checkbox" name="attr_prevRoundInitAttempts" class="loopStandbyToggle" value="6" hidden="true">
			<div class="autoUpdateIndicator"></div>
			<span data-i18n="helper-text-update">Update</span>
		</button>
	</div>

	<div class="contentContainer darkBG">

	<!-- States -->
	<div class="rowContainer centerFlex topRow ailmentStates">
		<input type="text" name="attr_PanicStateSuppressUpdate" value="false" hidden="true">
		<input type="text" name="attr_StaggerStateSuppressUpdate" value="false" hidden="true">
		<input type="text" name="attr_StaggerDurationSuppressUpdate" value="false" hidden="true">
		<input type="text" name="attr_SealStateSuppressUpdate" value="false" hidden="true">
		<input type="text" name="attr_ImmobileStateSuppressUpdate" value="false" hidden="true">
		<input type="text" name="attr_DefeatStateSuppressUpdate" value="false" hidden="true">

		<!-- Hostile -->
		<div><input type="checkbox" class="hide-toggle" name="attr_distortState" value="true">
			<div class="hide-item">
			<input type="checkbox" name="attr_HostileState" value="Hostile" class="expand-toggle" id="state_Hostile">
			<label class="status_effect_item expand-btn rowContainer" for="state_Hostile" data-i18n-title="ailments-hostile-title" title="Hostile">
				<input type="checkbox" class="swap-toggle" value="true" name="attr_settingLimbusStyle">
				<div class="swap-item-rev containIcon statusIcon hostile"></div> <div class="swap-item centerIcon statusIcon hostile-limbus"></div>
			</label>
		</div></div>

		<!-- Panic -->
		<div><input type="checkbox" class="hide-toggle-rev" name="attr_distortState" value="true">
			<div class="hide-item-rev">
			<input type="checkbox" name="attr_PanicState" value="Panic" class="expand-toggle" id="state_Panic">
			<label class="status_effect_item expand-btn rowContainer" for="state_Panic" data-i18n-title="ailments-panic-title" title="Panic">
				<input type="checkbox" class="swap-toggle" value="true" name="attr_settingLimbusStyle">
				<div class="swap-item-rev containIcon statusIcon panic"></div> <div class="swap-item centerIcon statusIcon panic-limbus"></div>
			</label>
		</div></div>

		<!-- Stagger -->
		<div>
			<input type="checkbox" name="attr_StaggerState" value="Staggered" class="expand-toggle" id="state_Stagger">
			<label class="status_effect_item expand-btn rowContainer" for="state_Stagger" data-i18n-title="ailments-stagger-title" title="Stagger">
				<input type="checkbox" class="swap-toggle" value="true" name="attr_settingLimbusStyle">
				<div class="swap-item-rev containIcon statusIcon stagger"></div> <div class="swap-item centerIcon statusIcon stagger-limbus"></div>
			</label>

			<input type="number" name="attr_StaggerDuration" value="0" hidden="true">
		</div>

		<!-- Seal -->
		<div>
			<input type="checkbox" name="attr_SealState" value="Seal" class="expand-toggle" id="state_Seal">
			<label class="status_effect_item expand-btn rowContainer" for="state_Seal" data-i18n-title="ailments-seal-title" title="Seal (Incapable of reactions)">
				<input type="checkbox" class="swap-toggle" value="true" name="attr_settingLimbusStyle">
				<div class="swap-item-rev containIcon statusIcon seal"></div> <div class="swap-item centerIcon statusIcon seal-limbus"></div>
			</label>
		</div>

		<!-- Immobile -->
		<div>
			<input type="checkbox" name="attr_ImmobileState" value="Immobile" class="expand-toggle" id="state_Immobile">
			<label class="status_effect_item expand-btn rowContainer" for="state_Immobile" data-i18n-title="ailments-immobile-title" title="Immobile (Incapable of action/reaction)">
				<input type="checkbox" class="swap-toggle" value="true" name="attr_settingLimbusStyle">
				<div class="swap-item-rev containIcon statusIcon immobile"></div> <div class="swap-item centerIcon statusIcon immobile-limbus"></div>
			</label>
		</div>

		<!-- Defeat -->
		<div>
			<input type="checkbox" name="attr_DefeatState" value="Defeated" class="expand-toggle" id="state_Defeat">
			<label class="status_effect_item expand-btn rowContainer" for="state_Defeat" data-i18n-title="ailments-defeat-title" title="Defeated (Incapable of combat)">
				<input type="checkbox" class="swap-toggle" value="true" name="attr_settingLimbusStyle">
				<div class="swap-item-rev containIcon statusIcon defeat"></div> <div class="swap-item centerIcon statusIcon defeat-limbus"></div>
			</label>
		</div>

	</div>
	<!-- States END -->


	<!-- Row 1 -->
	<div class="rowContainer ailmentRow">

		<!-- Burn -->
		<div class="rowContainer">
			<input type="checkbox" class="fade-toggle" name="attr_Burn" value="0" hidden="true" checked>
			
			<div class="fade-item status_effect_item centerFlex">
				<button type="action" class="blocker ailmentButton" id="ailment_Burn" name="act_ailmentClicker" data-i18n-title="ailments-burn" title="Burn"></button>
				<input type="checkbox" class="swap-toggle" value="true" name="attr_settingLimbusStyle">
				<div class="swap-item-rev mediumIcon burn"></div> <div class="swap-item mediumIcon burn-limbus"></div>
			</div>

			<div class="status_effect_value rowContainer">
				<input type="checkbox" class="hide-toggle-rev" name="attr_settingHideNextTurn" value="true">
				<input type="checkbox" class="hide-toggle" name="attr_burnNextTurnSetting" value="true" hidden="true" checked>
				<input type="number" class="ailmentNum ailmentNumThisTurn hoverSpinner" name="attr_Burn" min="0" value="0">
				<input type="number" class="ailmentNum ailmentNumNextTurn hoverSpinner hide-item hide-item-rev" name="attr_BurnNextTurn" min="0" value="0">
				<input type="number" class="ailmentNum ailmentNumDecayPause hoverSpinner" name="attr_BurnDecayPause" value="0">
			</div>
		</div>

		<!-- Bleed -->
		<div class="rowContainer">
			<input type="checkbox" class="fade-toggle" name="attr_Bleed" value="0" hidden="true" checked>
			
			<div class="fade-item status_effect_item centerFlex">
				<button type="action" class="blocker ailmentButton" id="ailment_Bleed" name="act_ailmentClicker" data-i18n-title="ailments-bleed" title="Bleed"></button>
				<input type="checkbox" class="swap-toggle" value="true" name="attr_settingLimbusStyle">
				<div class="swap-item-rev mediumIcon bleed"></div> <div class="swap-item mediumIcon bleed-limbus"></div>
			</div>

			<div class="status_effect_value rowContainer">
				<input type="checkbox" class="hide-toggle-rev" name="attr_settingHideNextTurn" value="true">
				<input type="checkbox" class="hide-toggle" name="attr_bleedNextTurnSetting" value="true" hidden="true" checked>
				<input type="number" class="ailmentNum ailmentNumThisTurn hoverSpinner" name="attr_Bleed" min="0" value="0">
				<input type="number" class="ailmentNum ailmentNumNextTurn hoverSpinner hide-item hide-item-rev" name="attr_BleedNextTurn" min="0" value="0">
				<input type="number" class="ailmentNum ailmentNumDecayPause hoverSpinner" name="attr_BleedDecayPause" value="0">
			</div>
		</div>

		<!-- Paralysis -->
		<div class="rowContainer">
			<input type="checkbox" class="fade-toggle" name="attr_Paralysis" value="0" hidden="true" checked>
			
			<div class="fade-item status_effect_item centerFlex">
				<button type="action" class="blocker ailmentButton" id="ailment_Paralysis" name="act_ailmentClicker" data-i18n-title="ailments-paralysis" title="Paralysis"></button>
				<input type="checkbox" class="swap-toggle" value="true" name="attr_settingLimbusStyle">
				<div class="swap-item-rev mediumIcon paralysis"></div> <div class="swap-item mediumIcon paralysis-limbus"></div>
			</div>

			<div class="status_effect_value rowContainer">
				<input type="checkbox" class="hide-toggle-rev" name="attr_settingHideNextTurn" value="true">
				<input type="number" class="ailmentNum ailmentNumThisTurn hoverSpinner" min="0" name="attr_Paralysis" value="0">
				<input type="number" class="ailmentNum ailmentNumNextTurn hoverSpinner hide-item-rev" min="0" name="attr_ParalysisNextTurn" value="0">
				<input type="number" class="ailmentNum ailmentNumDecayPause hoverSpinner" name="attr_ParalysisDecayPause" value="0">
				<input type="number" name="attr_prevParalysis" value="0" hidden="true">
			</div>
		</div>
	</div> 

	<!-- Row 2 -->
	<div class="rowContainer ailmentRow">

		<!-- Fragile -->
		<div class="rowContainer">
			<input type="checkbox" class="fade-toggle" name="attr_Fragile" value="0" hidden="true" checked>   
			
			<div class="fade-item status_effect_item centerFlex">
				<button type="action" class="blocker ailmentButton" id="ailment_Fragile" name="act_ailmentClicker" data-i18n-title="ailments-fragile" title="Fragile"></button>
				<input type="checkbox" class="swap-toggle" value="true" name="attr_settingLimbusStyle">
				<div class="swap-item-rev mediumIcon fragile"></div> <div class="swap-item mediumIcon fragile-limbus-red"></div>
			</div>

			<div class="status_effect_value rowContainer">
				<input type="checkbox" class="hide-toggle-rev" name="attr_settingHideNextTurn" value="true">
				<input type="number" min="0" class="ailmentNum ailmentNumThisTurn hoverSpinner" name="attr_Fragile" value="0">
				<input type="number" min="0" class="ailmentNum ailmentNumNextTurn hoverSpinner hide-item-rev" name="attr_FragileNextTurn" value="0">
				<input type="number" class="ailmentNum ailmentNumDecayPause hoverSpinner" name="attr_FragileDecayPause" value="0">
			</div>
		</div>

		<!-- Protection -->
		<div class="rowContainer">
			<input type="checkbox" class="fade-toggle" name="attr_Protection" value="0" hidden="true" checked>  
			
			<div class="fade-item status_effect_item centerFlex">
				<button type="action" class="blocker ailmentButton" id="ailment_Protection" name="act_ailmentClicker" data-i18n-title="ailments-protection" title="Protection"></button>
				<input type="checkbox" class="swap-toggle" value="true" name="attr_settingLimbusStyle">
				<div class="swap-item-rev mediumIcon protection"></div> <div class="swap-item mediumIcon protection-limbus"></div>
			</div>

			<div class="status_effect_value rowContainer">
				<input type="checkbox" class="hide-toggle-rev" name="attr_settingHideNextTurn" value="true">
				<input type="number" min="0" class="ailmentNum ailmentNumThisTurn hoverSpinner" name="attr_Protection" value="0">
				<input type="number" min="0" class="ailmentNum ailmentNumNextTurn hoverSpinner hide-item-rev" name="attr_ProtectionNextTurn" value="0">
				<input type="number" class="ailmentNum ailmentNumDecayPause hoverSpinner" name="attr_ProtectionDecayPause" value="0">
			</div>
		</div>

		<!-- Stagger Protection -->
		<div class="rowContainer">
			<input type="checkbox" class="fade-toggle" name="attr_StaggerProtection" value="0" hidden="true" checked>
			
			<div class="fade-item status_effect_item centerFlex">
				<button type="action" class="blocker ailmentButton" id="ailment_StaggerProtection" name="act_ailmentClicker" data-i18n-title="ailments-stgprotection" title="Stagger Protection"></button>
				<input type="checkbox" class="swap-toggle" value="true" name="attr_settingLimbusStyle">
				<div class="swap-item-rev mediumIcon staggerprotection"></div> <div class="swap-item mediumIcon staggerprotection-limbus"></div>
			</div>

			<div class="status_effect_value rowContainer">
				<input type="checkbox" class="hide-toggle-rev" name="attr_settingHideNextTurn" value="true">
				<input type="number" min="0" class="ailmentNum ailmentNumThisTurn hoverSpinner" name="attr_StaggerProtection" value="0">
				<input type="number" min="0" class="ailmentNum ailmentNumNextTurn hoverSpinner hide-item-rev" name="attr_StaggerProtectionNextTurn" value="0">
				<input type="number" class="ailmentNum ailmentNumDecayPause hoverSpinner" name="attr_StaggerProtectionDecayPause" value="0">
			</div>
		</div>
	</div>

	<!-- Row 3 -->
	<div class="rowContainer ailmentRow">

		<!-- Strength -->
		<div class="rowContainer">
			<input type="checkbox" class="fade-toggle" name="attr_Strength" value="0" hidden="true" checked>
			
			<div class="fade-item status_effect_item centerFlex">
				<button type="action" class="blocker ailmentButton" id="ailment_Strength" name="act_ailmentClicker" data-i18n-title="ailments-strength" title="Strength"></button>
				<input type="checkbox" class="swap-toggle" value="true" name="attr_settingLimbusStyle">
				<div class="swap-item-rev mediumIcon strength"></div> <div class="swap-item mediumIcon strength-limbus"></div>
			</div>

			<div class="status_effect_value rowContainer">
				<input type="checkbox" class="hide-toggle-rev" name="attr_settingHideNextTurn" value="true">
				<input type="number" min="0" class="ailmentNum ailmentNumThisTurn hoverSpinner" name="attr_Strength" value="0">
				<input type="number" min="0" class="ailmentNum ailmentNumNextTurn hoverSpinner hide-item-rev" name="attr_StrengthNextTurn" value="0">
				<input type="number" class="ailmentNum ailmentNumDecayPause hoverSpinner" name="attr_StrengthDecayPause" value="0">
			</div>
		</div>

		<!-- Endurance -->
		<div class="rowContainer">
			<input type="checkbox" class="fade-toggle" name="attr_Endurance" value="0" hidden="true" checked>
			
			<div class="fade-item status_effect_item centerFlex">
				<button type="action" class="blocker ailmentButton" id="ailment_Endurance" name="act_ailmentClicker" data-i18n-title="ailments-endurance" title="Endurance"></button>
				<input type="checkbox" class="swap-toggle" value="true" name="attr_settingLimbusStyle">
				<div class="swap-item-rev mediumIcon endurance"></div> <div class="swap-item mediumIcon endurance-limbus"></div>
			</div>

			<div class="status_effect_value rowContainer">
				<input type="checkbox" class="hide-toggle-rev" name="attr_settingHideNextTurn" value="true">
				<input type="number" min="0" class="ailmentNum ailmentNumThisTurn hoverSpinner" name="attr_Endurance" value="0">
				<input type="number" min="0" class="ailmentNum ailmentNumNextTurn hoverSpinner hide-item-rev" name="attr_EnduranceNextTurn" value="0">
				<input type="number" class="ailmentNum ailmentNumDecayPause hoverSpinner" name="attr_EnduranceDecayPause" value="0">
			</div>
		</div>

		<!-- Haste -->
		<div class="rowContainer">
			<input type="checkbox" class="fade-toggle" name="attr_Haste" value="0" hidden="true" checked>
			
			<div class="fade-item status_effect_item centerFlex">
				<button type="action" class="blocker ailmentButton" id="ailment_Haste" name="act_ailmentClicker" data-i18n-title="ailments-haste" title="Haste"></button>
				<input type="checkbox" class="swap-toggle" value="true" name="attr_settingLimbusStyle">
				<div class="swap-item-rev mediumIcon haste"></div> <div class="swap-item mediumIcon haste-limbus"></div>
			</div>

			<div class="status_effect_value rowContainer">
				<input type="checkbox" class="hide-toggle-rev" name="attr_settingHideNextTurn" value="true">
				<input type="number" min="0" class="ailmentNum ailmentNumThisTurn hoverSpinner" name="attr_Haste" value="0">
				<input type="number" min="0" class="ailmentNum ailmentNumNextTurn hoverSpinner hide-item-rev" name="attr_HasteNextTurn" value="0">
				<input type="number" class="ailmentNum ailmentNumDecayPause hoverSpinner" name="attr_HasteDecayPause" value="0">
			</div>
		</div>
	</div>

	<!-- Row 4 -->
	<div class="rowContainer ailmentRow">

		<!-- Feeble -->
		<div class="rowContainer">
			<input type="checkbox" class="fade-toggle" name="attr_Feeble" value="0" hidden="true" checked>
			
			<div class="fade-item status_effect_item centerFlex">
				<button type="action" class="blocker ailmentButton" id="ailment_Feeble" name="act_ailmentClicker" data-i18n-title="ailments-feeble" title="Feeble"></button>
				<input type="checkbox" class="swap-toggle" value="true" name="attr_settingLimbusStyle">
				<div class="swap-item-rev mediumIcon feeble"></div> <div class="swap-item mediumIcon feeble-limbus"></div>
			</div>

			<div class="status_effect_value rowContainer">
				<input type="checkbox" class="hide-toggle-rev" name="attr_settingHideNextTurn" value="true">
				<input type="number" min="0" class="ailmentNum ailmentNumThisTurn hoverSpinner" name="attr_Feeble" value="0">
				<input type="number" min="0" class="ailmentNum ailmentNumNextTurn hoverSpinner hide-item-rev" name="attr_FeebleNextTurn" value="0">
				<input type="number" class="ailmentNum ailmentNumDecayPause hoverSpinner" name="attr_FeebleDecayPause" value="0">
			</div>
		</div>

		<!-- Disarm -->
		<div class="rowContainer">
			<input type="checkbox" class="fade-toggle" name="attr_Disarm" value="0" hidden="true" checked>
			
			<div class="fade-item status_effect_item centerFlex">
				<button type="action" class="blocker ailmentButton" id="ailment_Disarm" name="act_ailmentClicker" data-i18n-title="ailments-disarm" title="Disarm"></button>
				<input type="checkbox" class="swap-toggle" value="true" name="attr_settingLimbusStyle">
				<div class="swap-item-rev mediumIcon disarm"></div> <div class="swap-item mediumIcon disarm-limbus-blue"></div>
			</div>

			<div class="status_effect_value rowContainer">
				<input type="checkbox" class="hide-toggle-rev" name="attr_settingHideNextTurn" value="true">
				<input type="number" min="0" class="ailmentNum ailmentNumThisTurn hoverSpinner" name="attr_Disarm" value="0">
				<input type="number" min="0" class="ailmentNum ailmentNumNextTurn hoverSpinner hide-item-rev" name="attr_DisarmNextTurn" value="0">
				<input type="number" class="ailmentNum ailmentNumDecayPause hoverSpinner" name="attr_DisarmDecayPause" value="0">
			</div>
		</div>

		<!-- Bind -->
		<div class="rowContainer">
			<input type="checkbox" class="fade-toggle" name="attr_Bind" value="0" hidden="true" checked>
			
			<div class="fade-item status_effect_item centerFlex">
				<button type="action" class="blocker ailmentButton" id="ailment_Bind" name="act_ailmentClicker" data-i18n-title="ailments-bind" title="Bind"></button>
				<input type="checkbox" class="swap-toggle" value="true" name="attr_settingLimbusStyle">
				<div class="swap-item-rev mediumIcon bind"></div> <div class="swap-item mediumIcon bind-limbus"></div>
			</div>

			<div class="status_effect_value rowContainer">
				<input type="checkbox" class="hide-toggle-rev" name="attr_settingHideNextTurn" value="true">
				<input type="number" min="0" class="ailmentNum ailmentNumThisTurn hoverSpinner" name="attr_Bind" value="0">
				<input type="number" min="0" class="ailmentNum ailmentNumNextTurn hoverSpinner hide-item-rev" name="attr_BindNextTurn" value="0">
				<input type="number" class="ailmentNum ailmentNumDecayPause hoverSpinner" name="attr_BindDecayPause" value="0">
			</div>
		</div>
	</div>

	<!-- Row 5 -->
	<div class="rowContainer ailmentRow">

		<!-- Smoke -->
		<div class="rowContainer">
			<input type="checkbox" class="fade-toggle" name="attr_Smoke" value="0" hidden="true" checked>
			
			<div class="fade-item status_effect_item centerFlex">
				<button type="action" class="blocker ailmentButton" id="ailment_Smoke" name="act_ailmentClicker" data-i18n-title="ailments-smoke" title="Smoke"></button>
				<input type="checkbox" class="swap-toggle" value="true" name="attr_settingLimbusStyle">
				<div class="swap-item-rev mediumIcon smoke"></div> <div class="swap-item mediumIcon smoke-limbus"></div>
			</div>

			<div class="status_effect_value rowContainer">
				<input type="checkbox" class="hide-toggle" name="attr_smokeNextTurnSetting" value="true" hidden="true" checked>
				<input type="number" class="ailmentNum ailmentNumThisTurn hoverSpinner" name="attr_Smoke" min="0" value="0">
				<input type="number" class="ailmentNum ailmentNumNextTurn hoverSpinner hide-item" name="attr_SmokeNextTurn" min="0" value="0">
				<input type="number" class="ailmentNum ailmentNumDecayPause hoverSpinner" name="attr_SmokeDecayPause" value="0">
			</div>
		</div>

		<!-- Charge -->
		<div class="rowContainer">
			<input type="checkbox" class="fade-toggle" name="attr_Charge" value="0" hidden="true" checked>
			
			<div class="fade-item status_effect_item centerFlex">
				<button type="action" class="blocker ailmentButton" id="ailment_Charge" name="act_ailmentClicker" data-i18n-title="ailments-charge" title="Charge"></button>
				<input type="checkbox" class="swap-toggle" value="true" name="attr_settingLimbusStyle">
				<div class="swap-item-rev mediumIcon charge"></div> <div class="swap-item mediumIcon charge-limbus"></div>
			</div>

			<div class="status_effect_value rowContainer">
				<input type="checkbox" class="hide-toggle" name="attr_chargeNextTurnSetting" value="true" hidden="true" checked>
				<input type="number" class="ailmentNum ailmentNumThisTurn hoverSpinner" name="attr_Charge" min="0" value="0">
				<input type="number" class="ailmentNum ailmentNumNextTurn hoverSpinner hide-item" name="attr_ChargeNextTurn" min="0" value="0">
				<input type="number" class="ailmentNum ailmentNumDecayPause hoverSpinner" name="attr_ChargeDecayPause" value="0">
			</div>
		</div>

		<!-- Fortune -->
		<div class="rowContainer">
			<input type="checkbox" class="fade-toggle" name="attr_Fortune" value="0" hidden="true" checked>
			
			<div class="fade-item status_effect_item rowContainer centerFlex">
				<button type="action" class="blocker ailmentButton" id="ailment_Fortune" name="act_ailmentClicker" data-i18n-title="ailments-fortune" title="Fortune"></button>
				<input type="checkbox" class="swap-toggle" value="true" name="attr_settingLimbusStyle">
				<div class="swap-item-rev mediumIcon fortune"></div> <div class="swap-item mediumIcon fortune-limbus"></div>
			</div>

			<div class="status_effect_value rowContainer">
				<input type="checkbox" class="hide-toggle-rev" name="attr_settingHideNextTurn" value="true">
				<input type="number" class="ailmentNum ailmentNumThisTurn hoverSpinner" name="attr_Fortune" min="0" value="0">
				<input type="number" class="ailmentNum ailmentNumNextTurn hoverSpinner hide-item-rev" name="attr_FortuneNextTurn" min="0" value="0">
				<input type="number" class="ailmentNum ailmentNumDecayPause hoverSpinner" name="attr_FortuneDecayPause" value="0">
				<input type="number" name="attr_prevFortune" min="0" value="0" hidden="true">
			</div>
		</div>
	</div>

	<!-- Repeating ailments -->
	<div class="ailmentCustomDisplay">
	<fieldset class="repeating_ailments">
		<input type="checkbox" class="hide-container-toggle" name="attr_ailDisplay" hidden="true" value="0">
		<div class="rowContainer">
			<input type="checkbox" class="fade-toggle" name="attr_ailNum" value="0" hidden="true" checked>
			
			<div class="fade-item status_effect_item centerFlex">
				<button type="action" class="blocker ailmentButton" name="act_clickercustom"></button>
				<img name="attr_ailIconDisplay" class="mediumIcon">
			</div>
			
			<div class="status_effect_value rowContainer">
				<input type="checkbox" class="hide-toggle" name="attr_ailNextTurn" value="true">
				<input type="number" class="ailmentNum ailmentNumThisTurn hoverSpinner" name="attr_ailNum" min="0" value="0">
				<input type="number" class="ailmentNum ailmentNumNextTurn hoverSpinner hide-item" name="attr_ailNumNextTurn" min="0" value="0">
				<input type="number" class="ailmentNum ailmentNumDecayPause hoverSpinner" name="attr_ailDecayPause" min="0" value="0">
			</div>
		</div>

		<input type="text" name="attr_ailName" hidden="true">
		<input type="text" name="attr_ailTrigger" hidden="true">
		<input type="text" name="attr_ailEffect" hidden="true">
		<input type="text" name="attr_ailEffectMode" hidden="true">
		<input type="text" name="attr_ailEffectVal" hidden="true">
		<input type="text" name="attr_ailDecayMode" hidden="true">
		<input type="text" name="attr_ailDecayVal" hidden="true">
		<input type="text" name="attr_ailMax" hidden="true">
		<input type="text" name="attr_ailCustomReistance" hidden="true">
		<input type="text" name="attr_ailMessageCheck" hidden="true">
		<input type="text" name="attr_ailMessage" hidden="true">

	</fieldset>
	</div>
	<!-- Repeating ailments end -->
						
	</div>
</div>
<!-- Status ailments end -->



<!-- Observation section palette -->
<input type="checkbox" class="hide-toggle" name="attr_distortState" value="true">
<div class="hide-item">
<div class="rowContainer sectionHeader">
	<button type="action" name="act_resetObservation" data-i18n-title="reset-button" title="Reset"> ! </button> <h4 data-i18n="heading-observation">Observation levels</h4>
</div>

<input type="checkbox" name="attr_distortState" value="true" hidden="true">
<div class="contentContainer darkBG helperTextContainer">

<div class="rowContainer observationSelect">
<div class="columnAlign">
<b data-i18n="distort-obs-details">Details</b><br>
<label for="obsDesc"><input type="checkbox" id="obsDesc" name="attr_obsDesc" value="true" checked><span data-i18n="distort-obs-desc">Effect desc.</span></label>
<label for="obsEffect"><input type="checkbox" id="obsEffect" name="attr_obsEffect" value="true"><span data-i18n="distort-obs-effect">Effects</span></label>
<label for="obsBehavior"><input type="checkbox" id="obsBehavior" name="attr_obsBehavior" value="true"><span data-i18n="distort-behavior">Behavior</span></label>
<label for="obsTaboon"><input type="checkbox" id="obsTaboon" name="attr_obsTaboon" value="true"><span data-i18n="distort-obs-taboon">Taboos/Boons</span></label>
</div>

<div class="columnAlign">
<b data-i18n="distort-obs-work">Work</b><br>
<label for="obsCounter"><input type="checkbox" id="obsCounter" name="attr_obsCounter" value="true" checked><span data-i18n="distort-counter">Counter</span></label>
<label for="obsWorkAmount"><input type="checkbox" id="obsWorkAmount" name="attr_obsWorkAmount" value="true" checked><span data-i18n="distort-workamount">Work amount</span></label>
<label for="obsWorkPref"><input type="checkbox" id="obsWorkPref" name="attr_obsWorkPref" value="true"><span data-i18n="distort-obs-workpreference">Preferences</span></label>
<label for="obsWorkResults"><input type="checkbox" id="obsWorkResults" name="attr_obsWorkResults" value="true"><span data-i18n="distort-obs-workresults">Work results</span></label>
</div>

<div class="columnAlign">
<b data-i18n="distort-obs-flavor">Flavor</b><br>
<label for="obsSummary"><input type="checkbox" id="obsSummary" name="attr_obsSummary" value="true" checked><span data-i18n="character-summary">Summary</span></label>
<label for="obsAppearance"><input type="checkbox" id="obsAppearance" name="attr_obsAppearance" value="true"><span data-i18n="distort-appearance">Appearance</span></label>
<label for="obsAtmosphere"><input type="checkbox" id="obsAtmosphere" name="attr_obsAtmosphere" value="true"><span data-i18n="distort-atmosphere">Atmosphere</span></label>
<label for="obsStory"><input type="checkbox" id="obsStory" name="attr_obsStory" value="true"><span data-i18n="distort-story">Story</span></label>
</div>

</div>


	</div>
</div>

	<!-- Observation END -->

 

            </div>


            <!-- Stats Section -->
            <div id="TopColumnR">



<div class="rowContainer sectionHeader">
	<button type="action" name="act_resetStats" data-i18n-title="reset-button" title="Reset"> ! </button> <h4 data-i18n="heading-stats">Stats</h4>

	<button type="action" class="centerIcon luck" id="autoroll_luck" name="act_rollChallenge" data-i18n-title="helper-roll-luck" title="Roll Luck"></button>
	<input type="text" name="attr_baseLuckNum" value="0" hidden="true">
	<input type="text" name="attr_luckNum" value="@{baseLuckNum}" hidden="true">

	<button type="action" class="centerIcon reusable" name="act_resetUses" data-i18n-title="refresh-button" title="Refresh: Reload all weapons and reusable tools"></button>
</div>

<div class="contentContainer darkBG" id="baseStats">
	<div class="rowContainer">

		<!-- Instinct -->
        <div class="statBlock">
			<div class="statImage">
			<div class="statInput" id="InstinctStat" data-i18n-title="stats-instinct" title="Instinct"> 
			<input type="text" class="instinct" name="attr_instinct" value="0">
			</div>
			</div>
		<div class="statHeader instinct" data-i18n-title="stats-instinct-roll" title="Roll Instinct">
		<button type="action" class="challengeButton instinct" name="act_rollChallenge" id="autoroll_instinct" data-i18n="stats-instinct">Instinct</button>
		</div>
		</div>

		<!-- Wisdom -->
		<div class="statBlock">
			<div class="statImage">
			<div class="statInput" id="WisdomStat" data-i18n-title="stats-wisdom" title="Wisdom"> 
			<input type="text" class="wisdom" name="attr_wisdom" value="0">
			</div>

			</div>

			<div class="statHeader wisdom" data-i18n-title="stats-wisdom-roll" title="Roll Wisdom">

<button type="action" class="challengeButton wisdom" name="act_rollChallenge" id="autoroll_wisdom" data-i18n="stats-wisdom">Wisdom</button>

			</div>

		</div>

		<!-- Justice -->
		<div class="statBlock">
			<div class="statImage">
			<div class="statInput" id="JusticeStat" data-i18n-title="stats-justice" title="Justice"> 
			<input type="text" class="justice" name="attr_justice" value="0">
			</div>

			</div>

			<div class="statHeader justice"  data-i18n-title="stats-justice-roll" title="Roll Justice">

<button type="action" class="challengeButton justice" name="act_rollChallenge" id="autoroll_justice" data-i18n="stats-justice">Justice</button>
			
			</div>
		</div>
	</div>
	<!-- Stat first row end -->



	<div class="rowContainer">
		<!-- Charm -->
		<div class="statBlock">
			<div class="statImage">
			<div class="statInput" id="CharmStat" title="Charm" data-i18n-title="stats-charm"> 
			<input type="text" class="charm" name="attr_charm" value="0">
			</div>

			</div>

			<div class="statHeader charm" data-i18n-title="stats-charm-roll" title="Roll Charm">

<button type="action" class="challengeButton charm" name="act_rollChallenge" id="autoroll_charm" data-i18n="stats-charm">Charm</button>
			
			</div>
		</div>

		<!-- Insight -->
		<div class="statBlock">
			<div class="statImage">
			<div class="statInput" id="InsightStat" data-i18n-title="stats-insight" title="Insight"> 
			<input type="text" class="insight" name="attr_insight" value="0">
			</div>

			</div>

			<div class="statHeader insight" data-i18n-title="stats-insight-roll" title="Roll Insight">

<button type="action" class="challengeButton insight" name="act_rollChallenge" id="autoroll_insight" data-i18n="stats-insight">Insight</button>
			
			</div>
		</div>

		<!-- Temperance -->
		<div class="statBlock">
			<div class="statImage">
			<div class="statInput" id="TemperanceStat" data-i18n-title="stats-temperance" title="Temperance"> 
			<input type="text" class="temperance" name="attr_temperance" value="0">
			</div>

			</div>

			<div class="statHeader temperance" data-i18n-title="stats-temperance-roll" title="Roll Temperance">

<button type="action" class="challengeButton temperance" name="act_rollChallenge" id="autoroll_temperance" data-i18n="stats-temperance">Temperance</button>
			
			</div>
		</div>

	</div>
	<!-- Stat row2 end -->

	<input type="checkbox" class="helperText" name="attr_settingHelperText" value="true" hidden="true">
	<div class="rollHelpersContainer helperTextContainer rowContainer">
			
		<div class="columnAlign helpers">
			<b data-i18n="helper-text-whisper">Whisper</b>

			<label for="WhisperRolls" style="margin: 0px; padding: 0px;">
			<input type="checkbox" id="WhisperRolls" name="attr_settingWhisperRolls" value="true" class="expand-toggle" style="display: none !important;">
			<div class="darkButton containIcon whisper" data-i18n-title="helper-toggle-whisper" title="Toggle Whisper"></div>
			</label>
		</div>

		<div class="sideDice columnAlign helpers">
			<b data-i18n="helper-text-difficulty">Difficulty</b>
			<input type="number" class="whiteInput difficultyInput" name="attr_difficulty" value="0" data-i18n-title="helper-text-difficulty" title="Difficulty">
		</div>

		<div class="columnAlign centerFlex helpers">
			<b data-i18n="helper-text-advantages">Advantages</b>
			<div class="rowContainer helpers">
				<div data-i18n-title="helper-text-disadv" title="Disadvantage" class="rowContainer centerFlex">
					<input type="text" class="transpInput disadvCounter disadv" name="attr_disadvNum"  value="0"><input type="checkbox" name="attr_advState" class="largeCheck disadv" value="Disadvantage">
				</div>
				<div data-i18n-title="helper-text-adv" title="Advantage" class="rowContainer centerFlex">
					<input type="text" class="transpInput advCounter adv" name="attr_advNum" value="0"><input type="checkbox"  name="attr_advState" class="largeCheck adv" value="Advantage">
				</div>
			</div>
		</div>

		<div class="columnAlign helpers" style="display: none !important">
			<b data-i18n="helper-text-power">Power</b>
			<div class="rowContainer centerFlex helpers">
				<input type="text" name="attr_attPower" value="0" hidden="true">
				<input type="text" name="attr_defPower" value="0" hidden="true">
				<input type="text" name="attr_evdPower" value="0" hidden="true">

				<input type="text" class="power HPtext darkInput" name="attr_powerATT" value="@{attPower}+@{Strength}-@{Feeble}" disabled="true" data-i18n-title="helper-att-power" title="Att Power">
				<input type="text" class="power SANtext darkInput" name="attr_powerDEF" value="@{defPower}+@{Endurance}-@{Disarm}" disabled="true" data-i18n-title="helper-def-power" title="Def Power">

				<input type="text" name="attr_evdPositive" value="0" hidden="true">
				<input type="text" name="attr_evdNegative" value="0" hidden="true">
				<input type="text" class="power STGRtext darkInput" name="attr_powerEVD" value="@{evdPower}+@{evdPositive}-@{evdNegative}" data-i18n-title="helper-evd-power" title="Evd Power" disabled="true">
			</div>
		</div>
	</div>

	<input type="checkbox" name="attr_settingWhisperRolls" class="hide-toggle" value="true">
	<div class="hide-item" style="margin-top: 3px;">
		<span class="half" style="color: #888; font-weight: bold;" data-i18n="settings-whisper">Whisper rolls to: </span>
		<input type="text" class="whiteInput half" name="attr_settingWhisperTarget" value="GM">
	</div>

	<button type="action" name="act_testButton" class="darkButton" style="width: 60px;">?????</button>

</div>


<!-- AutoEffect Conditional Buttons -->
<div class="conditionalButtonDisplay" style="margin-top: 10px; width: calc(100% + 5px);">
	<fieldset class="repeating_conditionalButtons">
		<input type="checkbox" name="attr_buttonColor" value="green" class="conditioalButtonColorSelection" hidden checked/>
		<input type="checkbox" name="attr_buttonColor" value="blue" class="conditioalButtonColorSelection" hidden />
		<input type="checkbox" name="attr_buttonColor" value="red" class="conditioalButtonColorSelection" hidden />
		<input type="checkbox" name="attr_buttonColor" value="orange" class="conditioalButtonColorSelection" hidden />
		<input type="checkbox" name="attr_buttonColor" value="yellow" class="conditioalButtonColorSelection" hidden />
		<input type="checkbox" name="attr_buttonColor" value="purple" class="conditioalButtonColorSelection" hidden />
		<input type="checkbox" name="attr_buttonColor" value="black" class="conditioalButtonColorSelection" hidden />
		<img name="attr_buttonIcon" class="conditionalButtonIcon conditioalButtonColor">
		<button type="action" class="conditionalButtonAct" name="act_activate"></button> 
		<div class="conditionalButton conditioalButtonColor">
			<span type="text" class="conditionalButtonName" name="attr_buttonName"></span>
			<input type="text" name="attr_buttonAutoScript" hidden="true">
		</div>
	</fieldset>
</div>


<!-- Combat palette -->

<div class="rowContainer sectionHeader">
	<button type="action" name="act_resetDamageHelper" data-i18n-title="reset-button" title="Reset"> ! </button> <h4 data-i18n="heading-combat">Combat palette</h4>

	<!-- Combat toggle -->
	<input type="checkbox" class="hide-toggle hide-toggle-rev" name="attr_settingCombatToggle" value="true" hidden="true">
	<div class="hide-item combatToggleContainer">
		<input type="checkbox" class="hide-toggle hide-toggle-rev" name="attr_combatState" value="true" hidden="true">
		<div class="hide-item-rev"><button type="action" class="centerIcon speed combatToggleButton" name="act_combatToggle" data-i18n-title="helper-text-begincombat" title="Begin combat"><span data-i18n="helper-text-begincombat">Begin Combat</span></button></div>
		<div class="hide-item"><button type="action" class="centerIcon exit combatToggleButton" name="act_combatToggle" data-i18n-title="helper-text-endcombat" title="End combat"><span data-i18n="helper-text-endcombat">End Combat</span></button></div>
	</div>

	<!-- Standard speed button -->
	<div class="hide-item-rev">
		<button type="action" class="centerIcon speed" id="autoroll_speed" name="act_rollChallenge" data-i18n-title="helper-roll-speed" title="Roll Speed"></button>
	</div>

	<input type="text" name="attr_baseSpeed" value="0" hidden="true">
	<input type="text" name="attr_prevSpeed" value="0" hidden="true">
	<input type="text" name="attr_thisRoundSpeed" value="0" hidden="true">
	<input type="text" name="attr_nextRoundSpeed" value="0" hidden="true">
	<input type="text" name="attr_isFirstRound" value="false" hidden="true">
	<input type="number" name="attr_prevRoundInit" value="0" hidden="true">
	<input type="number" name="attr_prevRoundInitAttempts" value="1" hidden="true">
	<input type="text" name="attr_calcSpeed" value="0" hidden="true">
</div>

<!-- Combat toggle -->
<div class="status_effect" style="margin-top: 5px;">
	<div class="contentContainer darkBG">

	<!-- Combat options -->
	<input type="checkbox" class="hide-toggle" name="attr_combatState" value="true" hidden="true">
	<input type="checkbox" class="helperText" name="attr_settingHelperText" value="true" hidden="true">
	<div class="hide-item rowContainer combatOptionsContainer helperTextContainer">
			
		<div class="rowContainer targetAndDefenceContainer">
			
			<!-- Target selector -->
			<input type="checkbox" class="hide-toggle" name="attr_settingTargeting" value="true" hidden="true" checked>
			<div class="hide-item rowContainer">
				<div class="columnAlign helpers">
					<b data-i18n="helper-text-selecttarget">Target</b>
					<button type="action" class="darkButton selectTargetButton" name="act_selectTarget" title="Select target. Double click button to reset target" data-i18n-title="helper-text-selecttarget-title">
						<img name="attr_targetToken" class="targetToken">
						<input type="text" name="attr_selfToken" hidden>
						<div class="selectTargetIcon"></div>
					</button>
				</div>
	
				<!-- Target statistics -->
				<div class="columnAlign helpers">
					<input type="text" class="helperInput tokenName" name="attr_targetTokenName" value="" style="width: 150px;" placeholder="No target selected" data-i18n-placeholder="helper-text-notarget" readonly="">
					<input type="text" name="attr_targetName" value="" hidden="true">
					<input type="text" name="attr_targetTokenId" value="" hidden="true">
					<input type="text" name="attr_targetSettings" value="{}" hidden="true">
	
					<input type="text" name="attr_targetedBy" value="{}" hidden="true">
					<!-- <input type="text" name="attr_announceTargeting" value="" hidden="true">
					<input type="text" name="attr_testIsGM" value="unset" hidden="true"> -->
					
					<!-- Target bars -->
					<div class="rowContainer" style="width: 150px;">
						<div class="bars"><input class="Cstat HPtext noSpinner" type="text" name="attr_HP_target" value="---"></div>
						<div class="bars"><input class="Cstat egoSTGRtext noSpinner" type="text" name="attr_StagRes_target" value="---"></div>
						<div class="bars"><input class="Cstat SANtext noSpinner" type="text" name="attr_SP_target" value="---"></div>
					</div>
	
					<!-- Target ailments -->
					<div class="rowContainer">
						<input type="checkbox" class="hide-toggle-rev" name="attr_targetAilment1Num" value="0" hidden="true" checked>
						<div class="targetAilment hide-item-rev">
							<img name="attr_targetAilment1Icon">
							<input type="number" name="attr_targetAilment1Num" min="0" value="0">
						</div>
						<input type="checkbox" class="hide-toggle-rev" name="attr_targetAilment2Num" value="0" hidden="true" checked>
						<div class="targetAilment hide-item-rev">
							<img name="attr_targetAilment2Icon">
							<input type="number" name="attr_targetAilment2Num" min="0" value="0">
						</div>
						<input type="checkbox" class="hide-toggle-rev" name="attr_targetAilment3Num" value="0" hidden="true" checked>
						<div class="targetAilment hide-item-rev">
							<img name="attr_targetAilment3Icon">
							<input type="number" name="attr_targetAilment3Num" min="0" value="0">
						</div>
						<input type="checkbox" class="hide-toggle-rev" name="attr_targetAilment4Num" value="0" hidden="true" checked>
						<div class="targetAilment hide-item-rev">
							<img name="attr_targetAilment4Icon">
							<input type="number" name="attr_targetAilment4Num" min="0" value="0">
						</div>
						<input type="checkbox" class="hide-toggle-rev" name="attr_targetAilment5Num" value="0" hidden="true" checked>
						<div class="targetAilment hide-item-rev">
							<img name="attr_targetAilment5Icon">
							<input type="number" name="attr_targetAilment5Num" min="0" value="0">
						</div>
						<input type="checkbox" class="hide-toggle-rev" name="attr_targetAilment6Num" value="0" hidden="true" checked>
						<div class="targetAilment hide-item-rev">
							<img name="attr_targetAilment6Icon">
							<input type="number" name="attr_targetAilment6Num" min="0" value="0">
						</div>
					</div>
				</div>
			</div>

			<!-- Last defence dice -->
			<div>
				<input type="checkbox" class="hide-toggle" name="attr_settingLastDefenceRoll" value="true" hidden="true" checked>
				<div class="hide-item columnAlign helpers">
					<b data-i18n="helper-text-defencedice">Defence</b>
					<input type="number" class="darkInput defenceDice hoverSpinner" name="attr_lastDefenceRoll" min="0" value="0" data-i18n-title="helper-text-lastdefenceroll" title="Last Defence roll"> <!-- delete this later -->
				</div>
			</div>
		</div>

		<!-- Resources -->
		<div class="columnAlign">
			<input type="checkbox" class="hide-toggle" name="attr_settingActionTracker" value="true" hidden="true">
			<input type="checkbox" class="hide-toggle" name="attr_settingLightRegen" value="true" hidden="true">
			<input type="checkbox" id="editResourceToggle" name="attr_editResourceToggle" value="true" hidden="true" checked>
			<div class="hide-item columnAlign" style="gap: 1px;">

				<div class="rowContainer resourceContainer">
					<input type="text" value="0" name="attr_actionTradeReaction" hidden="true">
					
					<!-- Action tracking -->
					<input type="checkbox" class="hide-toggle-rev-next" name="attr_settingActionTracker" value="0" hidden="true" checked>
					<div class="hide-item-rev helpers">
						<b data-i18n="helper-actions">Actions</b>
						<div class="resourceTracker rowContainer">
							<label for="actionSelection" class="egoSpecial resourceTypeSelector" data-i18n-title="resource-action" title="Action">
								<input type="radio" id="actionSelection" name="attr_actionType" value="Action" hidden="true" checked>
							</label>
							<input type="checkbox" class="fade-toggle" name="attr_Action" value="0" hidden="true" checked>
							<input type="number" min="0" value="0" class="resourceCurrent hoverSpinner" name="attr_Action">
							<input type="number" min="0" value="0" class="resourceMax noSpinner" name="attr_Action_max">
							<input type="number" min="0" value="0" class="resourceBase" name="attr_Action_base">
						</div>
					</div>
		
					<!-- Universal reaction tracking -->
					<!-- When additional reactions are hidden, the tracker insteads shows the sum of all reactions -->
					<input type="checkbox" class="hide-toggle-rev-next" name="attr_settingActionTracker" value="0" hidden="true" checked>
					<div class="hide-item-rev helpers">
						<b data-i18n="helper-reactions">Reactions</b>
						<div class="resourceTracker rowContainer">
							<input type="checkbox" class="hide-toggle hide-toggle-rev" name="attr_expandResourceToggle" value="true" hidden="true" checked>
							<label for="reactionSelection" class="hide-item-rev reaction resourceTypeSelector" data-i18n-title="resource-reaction" title="Reaction"></label>
							<label for="reactionSelection" class="hide-item reaction resourceTypeSelector" data-i18n-title="helper-reaction-universal" title="Universal reaction"></label>
							<input type="radio" id="reactionSelection" name="attr_actionType" value="Reaction" hidden="true">

							<input type="checkbox" class="fade-toggle" name="attr_Reaction" value="0" hidden="true" checked>
							<input type="number" min="0" value="0" class="resourceCurrent hoverSpinner" name="attr_Reaction">
							<input type="number" min="0" value="0" class="resourceMax noSpinner" name="attr_Reaction_max">
							<input type="number" min="0" value="0" class="resourceBase" name="attr_Reaction_base">
						</div>
					</div>
					
					<!-- Light regen tracking -->
					<input type="checkbox" class="hide-toggle-rev-next" name="attr_settingLightRegen" value="0" hidden="true" checked>
					<div class="hide-item-rev columnAlign helpers">
						<b data-i18n="helper-light-regen">Light Regen</b>
						<div class="resourceTracker rowContainer">
							<button type="action" class="light resourceTypeSelector" name="act_lightClicker" data-i18n-title="helper-light-regen" title="Light regen"></button>
							<input type="checkbox" class="fade-toggle" name="attr_Light_Regen" value="0" hidden="true" checked>
							<input type="number" min="0" value="0" class="resourceCurrent hoverSpinner" name="attr_Light_Regen">
							<input type="number" min="0" value="0" class="resourceMax noSpinner LIGHT" name="attr_Light_Regen_max">
							<input type="number" min="0" value="0" class="resourceBase" name="attr_Light_Regen_base">
						</div>
					</div>

					<!-- Expand resources buttons -->
					<input type="checkbox" class="hide-toggle-rev-next" name="attr_settingActionTracker" value="0" hidden="true" checked>
					<div class="hide-item-rev" style="margin-top: auto;">
						<input type="checkbox" class="hide-toggle hide-toggle-rev" name="attr_expandResourceToggle" value="true" hidden="true" checked>
						<div class="hide-item-rev">
							<button type="action" class="darkButton resourceButton centerIcon arrowDown" name="act_expandResourceTrackers" data-i18n-title="resource-expand" title="Expand trackers"></button>
						</div>
						<div class="hide-item" style="max-width: 20px; margin-top: auto;">
							<button type="action" class="darkButton resourceButton centerIcon arrowUp" name="act_expandResourceTrackers" data-i18n-title="resource-compact" title="Compact trackers"></button>
						</div>
					</div>
				</div>
		
				<!-- Additional resources -->
				<input type="checkbox" class="hide-toggle" name="attr_expandResourceToggle" value="true" hidden="true">
				<div class="hide-item rowContainer resourceContainer">
		
					<!-- Counter / block / evade reaction tracking -->
					<div class="resourceTracker rowContainer">
						<label for="counterSelection" class="egoAtt resourceTypeSelector" data-i18n-title="helper-reaction-counter" title="Counter reaction">
							<input type="radio" id="counterSelection" name="attr_actionType" value="Counter" hidden="true">
						</label>
						<input type="checkbox" class="fade-toggle" name="attr_Counter" value="0" hidden="true" checked>
						<input type="number" min="0" value="0" class="resourceCurrent hoverSpinner" name="attr_Counter">
						<input type="number" min="0" value="0" class="resourceMax noSpinner" name="attr_Counter_max">
						<input type="number" min="0" value="0" class="resourceBase" name="attr_Counter_base">
					</div>
						
					<div class="resourceTracker rowContainer">
						<label for="blockSelection" class="egoDef resourceTypeSelector" data-i18n-title="helper-reaction-block" title="Block reaction">
							<input type="radio" id="blockSelection" name="attr_actionType" value="Block" hidden="true">
						</label>
						<input type="checkbox" class="fade-toggle" name="attr_Block" value="0" hidden="true" checked>
						<input type="number" min="0" value="0" class="resourceCurrent hoverSpinner" name="attr_Block">
						<input type="number" min="0" value="0" class="resourceMax noSpinner" name="attr_Block_max">
						<input type="number" min="0" value="0" class="resourceBase" name="attr_Block_base">
					</div>
		
					<div class="resourceTracker rowContainer">
						<label for="evadeSelection" class="egoEvd resourceTypeSelector" data-i18n-title="helper-reaction-evade" title="Evade reaction">
							<input type="radio" id="evadeSelection" name="attr_actionType" value="Evade" hidden="true">
						</label>
						<input type="checkbox" class="fade-toggle" name="attr_Evade" value="0" hidden="true" checked>
						<input type="number" min="0" value="0" class="resourceCurrent hoverSpinner" name="attr_Evade">
						<input type="number" min="0" value="0" class="resourceMax noSpinner" name="attr_Evade_max">
						<input type="number" min="0" value="0" class="resourceBase" name="attr_Evade_base">
					</div>

					<!-- Edit resources button -->
					<button type="action" name="act_editResourceTrackers" class="darkButton resourceButton centerIcon edit" data-i18n-title="resource-edit" title="Edit base actions and reactions (per round) and light regen (per combat)"></button>
				</div>
			</div>
		</div>
	</div>
                     
	<!-- Weapon 1 Palette -->
	<div class="weaponSlot">
	<div class="rowContainer weapon paletteButton"> <!-- color portion -->


	<!-- Weapon1 Uses -->
	<div class="buffer weaponPaletteUses">
	<input type="checkbox" class="hide-toggle-rev" name="attr_weapon1UseType" value="Limitless" hidden="true" checked>
		<div class="hide-item-rev rowContainer centerFlex" style="position: relative;">

		<input type="text" class="transpInput blocker" name="attr_weapon1Uses" style="text-align: center; height: 100%;" value="5">

		<input type="checkbox" class="fade-toggle" name="attr_weapon1UseType" value="Deplete" hidden="true">
		<div class="fade-item centerIcon reusable" style="width: 30px; height: 30px;"></div>  
		<div class="blocker"></div>
		</div>

	</div>

	<div class="buffer">
	<input type="checkbox" class="hide-toggle" name="attr_weapon1Uses" value="0" hidden="true">
		<div class="hide-item">
		<div class="blocker weaponBlocker"></div>
		</div>
	</div>
	<!-- Weapon1 Uses END -->



	<div class="rowContainer half centerFlex">
		<div class="iconHolder">

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Slash" name="attr_weapon1Type"><div class="type-image typeIcon slash"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Pierce" name="attr_weapon1Type"><div class="type-image typeIcon pierce"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Blunt" name="attr_weapon1Type"><div class="type-image typeIcon blunt"></div>
		</div>

		</div>

	<input type="text" class="combatPaletteName transpInput" name="attr_weapon1Name" data-i18n-placeholder="palette-weapon1-name" placeholder="Weapon (1)">

	</div>


	<div class="rowContainer half" style="position: relative;">
	
	<div class="paletteRange"></div>

	<div class="rowContainer darkInput paletteDice">
			<input type="text" name="attr_weapon1Roll1" placeholder="1" value="(@{weapon1Dice1} + @{selectAtkDice1})" disabled="true">
			<div class="plainText">D</div>
			<input type="text" name="attr_weapon1Roll2" placeholder="6" value="(@{weapon1Dice2} + @{selectAtkDice2})" disabled="true">
			<div class="plainText">+</div>
			<input type="text" name="attr_weapon1Roll3" placeholder="0" value="(@{weapon1Dice3}+@{attPower}+@{selectAtkDice3}+@{Strength}-@{Feeble}+@{difficulty})" disabled="true">
	</div>

	<button type="action" class="NDice" id="autoroll_weapon1" name="act_rollCombat"></button>



	</div> <!-- weapon 1 (under) end -->

	<!-- EGO (Weapon 1) Palette -->
	<div class="paletteOverride" style="z-index: 30;">
	<input type="checkbox" class="hide-toggle" name="attr_distortState" value="0" checked>
	<div class="hide-item">
	<input type="checkbox" class="hide-toggle" name="attr_egoActiveState" value="true">
	<div class="hide-item">

		<input type="checkbox" class="hide-toggle" name="attr_egoType" value="Weapon">
		<div class="hide-item">

	<div class="buffer">
	<input type="checkbox" class="hide-toggle" name="attr_egoUses" value="0" hidden="true">
		<div class="hide-item" style="z-index: 35; position: absolute; top: 0; left:0; width: 100%; height: 30px;">
		<div class="blocker weaponBlocker"></div>
		</div>
	</div>
	
		<!-- actual content -->
		<div class="rowContainer egoAttPalette paletteButton">
		<div class="rowContainer half centerFlex">

		<div class="iconHolder">

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Slash" name="attr_egoWeaponType"><div class="type-image typeIcon egoSlash"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Pierce" name="attr_egoWeaponType"><div class="type-image typeIcon egoPierce"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Blunt" name="attr_egoWeaponType"><div class="type-image typeIcon egoBlunt"></div>
		</div>

		</div>

	<input type="text" class="combatPaletteName transpInput" name="attr_egoName" data-i18n-placeholder="palette-egoweapon-name" placeholder="Mystery weapon">

		</div> <!-- first half -->

	<div class="rowContainer half" style="position: relative;">
	
	<div class="paletteRange">

	<!-- EGO Uses -->
	<div class="buffer weaponPaletteUses">
	<input type="checkbox" class="hide-toggle-rev" name="attr_egoUseType" value="Limitless" hidden="true" checked>
		<div class="hide-item-rev rowContainer centerFlex" style="position: relative;">

		<input type="text" class="transpInput blocker" name="attr_egoUses" style="text-align: center; height: 100%;" value="5">

		<input type="checkbox" class="fade-toggle" name="attr_egoUseType" value="Deplete" hidden="true">
		<div class="fade-item centerIcon reusable" style="width: 30px; height: 30px;"></div>  
		<div class="blocker"></div>
		</div>

	</div>

	<!-- EGO Uses END -->

	</div>


	<div class="rowContainer darkInput paletteDice">
			<input type="text" name="attr_egoWeaponRoll1" placeholder="1" value="(@{egoWeaponDice1} + @{selectAtkDice1})" disabled="true">
			<div class="plainText">D</div>
			<input type="text" name="attr_egoWeaponRoll2" placeholder="6" value="(@{egoWeaponDice2} + @{selectAtkDice2})" disabled="true">
			<div class="plainText">+</div>
			<input type="text" name="attr_egoWeaponRoll3" placeholder="0" value="(@{egoWeaponDice3}+@{attPower}+@{selectAtkDice3}+@{Strength}-@{Feeble}+@{difficulty})" disabled="true">
	</div>

<button type="action" class="NDice" id="autoroll_egoWeapon" name="act_rollCombat"></button>


		</div>			
       </div>
</div></div></div></div>
	<!-- EGO (Weapon 1) Palette END -->


<!-- Distortion (Weapon 1) Palette -->
	<div class="paletteOverride">

	<input type="checkbox" class="hide-toggle" name="attr_distortState" value="true">
	<div class="hide-item">
	
		<!-- actual content -->
		<div class="rowContainer egoAttPalette paletteButton">
		<div class="rowContainer half centerFlex">

		<div class="iconHolder">

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Slash" name="attr_weapon1Type"><div class="type-image typeIcon egoSlash"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Pierce" name="attr_weapon1Type"><div class="type-image typeIcon egoPierce"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Blunt" name="attr_weapon1Type"><div class="type-image typeIcon egoBlunt"></div>
		</div>

		</div>

	<input type="text" class="combatPaletteName transpInput" name="attr_weapon1Name" data-i18n-placeholder="palette-weapon1-name" placeholder="Weapon (1)">

		</div> <!-- first half -->

	<div class="rowContainer half" style="position: relative;">
	
	<div class="paletteRange"></div>


	<div class="rowContainer darkInput paletteDice">
			<input type="text" name="attr_weapon1Roll1" placeholder="1" value="(@{weapon1Dice1} + @{selectAtkDice1} + @{distortWeaponDice1})" disabled="true">
			<div class="plainText">D</div>
			<input type="text" name="attr_weapon1Roll2" placeholder="6" value="(@{weapon1Dice2} + @{selectAtkDice2} + @{distortWeaponDice2})" disabled="true">
			<div class="plainText">+</div>
			<input type="text" name="attr_weapon2Roll3" placeholder="0" value="(@{weapon1Dice3}+@{attPower}+@{selectAtkDice3}+@{distortWeaponDice3}+@{Strength}-@{Feeble}+@{difficulty})" disabled="true">
	</div>

<button type="action" class="NDice" id="autoroll_weapon1_distort" name="act_rollCombat"></button>


		</div>			
       </div>
</div></div>
	<!-- Distortion (Weapon 1) Palette END -->


 
	<!-- Weapon 1 Palette END -->
	</div></div>

	<!-- Weapon 2 Palette -->
	<div class="weaponSlot">
			<input type="checkbox" class="hide-toggle-rev" name="attr_weapon2Name" value="" hidden="true" checked>
	<div class="hide-item-rev" style="width: 100%;">

	<div class="rowContainer weapon paletteButton">

	<!-- Weapon2 Uses -->
	<div class="buffer weaponPaletteUses">
	<input type="checkbox" class="hide-toggle-rev" name="attr_weapon2UseType" value="Limitless" hidden="true" checked>
		<div class="hide-item-rev rowContainer centerFlex" style="position: relative;">

		<input type="text" class="transpInput blocker" name="attr_weapon2Uses" style="text-align: center; height: 100%;" value="5">

		<input type="checkbox" class="fade-toggle" name="attr_weapon2UseType" value="Deplete" hidden="true">
		<div class="fade-item centerIcon reusable" style="width: 30px; height: 30px;"></div>  
		<div class="blocker"></div>
		</div>

	</div>

	<div class="buffer">
	<input type="checkbox" class="hide-toggle" name="attr_weapon2Uses" value="0" hidden="true">
		<div class="hide-item">
		<div class="blocker weaponBlocker"></div>
		</div>
	</div>
	<!-- Weapon2 Uses END -->




	<div class="rowContainer half centerFlex">
		<div class="iconHolder">

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Slash" name="attr_weapon2Type"><div class="type-image typeIcon slash"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Pierce" name="attr_weapon2Type"><div class="type-image typeIcon pierce"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Blunt" name="attr_weapon2Type"><div class="type-image typeIcon blunt"></div>
		</div>

		</div>

	<input type="text" class="combatPaletteName transpInput" name="attr_weapon2Name" data-i18n-placeholder="palette-weapon2-name" placeholder="Weapon (2)">

	</div>

	<div class="rowContainer half" style="position: relative;">
	
	<div class="paletteRange"></div>


		<div class="rowContainer darkInput paletteDice">
			<input type="text" name="attr_weapon2Roll1" placeholder="1" value="(@{weapon2Dice1} + @{selectAtkDice1})" disabled="true">
			<div class="plainText">D</div>
			<input type="text" name="attr_weapon2Roll2" placeholder="6" value="(@{weapon2Dice2} + @{selectAtkDice2})" disabled="true">
			<div class="plainText">+</div>
			<input type="text" name="attr_weapon2Roll3" placeholder="0" value="(@{weapon2Dice3}+@{attPower}+@{selectAtkDice3}+@{Strength}-@{Feeble}+@{difficulty})" disabled="true">
	</div>

	<button type="action" class="NDice" id="autoroll_weapon2" name="act_rollCombat"></button>
	</div>

<!-- Distortion (Weapon 2) Palette -->
	<div class="paletteOverride">

	<input type="checkbox" class="hide-toggle" name="attr_distortState" value="true">
	<div class="hide-item">
	
		<!-- actual content -->
		<div class="rowContainer egoAttPalette paletteButton">
		<div class="rowContainer half centerFlex">

		<div class="iconHolder">

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Slash" name="attr_weapon2Type"><div class="type-image typeIcon egoSlash"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Pierce" name="attr_weapon2Type"><div class="type-image typeIcon egoPierce"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Blunt" name="attr_weapon2Type"><div class="type-image typeIcon egoBlunt"></div>
		</div>

		</div>

	<input type="text" class="combatPaletteName transpInput" name="attr_weapon2Name" data-i18n-placeholder="palette-weapon2-name" placeholder="Weapon (2)">

		</div> <!-- first half -->

	<div class="rowContainer half" style="position: relative;">
	
	<div class="paletteRange"></div>


	<div class="rowContainer darkInput paletteDice">
			<input type="text" name="attr_weapon2Roll1" placeholder="1" value="(@{weapon2Dice1} + @{selectAtkDice1} + @{distortWeaponDice1})" disabled="true">
			<div class="plainText">D</div>
			<input type="text" name="attr_weapon2Roll2" placeholder="6" value="(@{weapon2Dice2} + @{selectAtkDice2} + @{distortWeaponDice2})" disabled="true">
			<div class="plainText">+</div>
			<input type="text" name="attr_weapon2Roll3" placeholder="0" value="(@{weapon2Dice3}+@{attPower}+@{selectAtkDice3}+@{distortWeaponDice3}+@{Strength}-@{Feeble}+@{difficulty})" disabled="true">
	</div>

<button type="action" class="NDice" id="autoroll_weapon2_distort" name="act_rollCombat"></button>


		</div>			
       </div>
</div></div>
	<!-- Distortion (Weapon 2) Palette END -->

		</div>
        </div>
	</div>

	<!-- Weapon 2 Palette END -->


	<!-- Weapon EXTRA palette -->
		<!-- Weapon 3 Palette -->
	<div class="weaponSlot">
			<input type="checkbox" class="hide-toggle-rev" name="attr_weapon3Name" value="" hidden="true" checked>
	<div class="hide-item-rev" style="width: 100%;">

	<div class="rowContainer weapon paletteButton">

	<!-- Weapon3 Uses -->
	<div class="buffer weaponPaletteUses">
	<input type="checkbox" class="hide-toggle-rev" name="attr_weapon3UseType" value="Limitless" hidden="true" checked>
		<div class="hide-item-rev rowContainer centerFlex" style="position: relative;">

		<input type="text" class="transpInput blocker" name="attr_weapon3Uses" style="text-align: center; height: 100%;" value="5">

		<input type="checkbox" class="fade-toggle" name="attr_weapon3UseType" value="Deplete" hidden="true">
		<div class="fade-item centerIcon reusable" style="width: 30px; height: 30px;"></div>  
		<div class="blocker"></div>
		</div>

	</div>

	<div class="buffer">
	<input type="checkbox" class="hide-toggle" name="attr_weapon3Uses" value="0" hidden="true">
		<div class="hide-item">
		<div class="blocker weaponBlocker"></div>
		</div>
	</div>
	<!-- Weapon3 Uses END -->


	<div class="rowContainer half centerFlex">
		<div class="iconHolder">

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Slash" name="attr_weapon3Type"><div class="type-image typeIcon slash"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Pierce" name="attr_weapon3Type"><div class="type-image typeIcon pierce"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Blunt" name="attr_weapon3Type"><div class="type-image typeIcon blunt"></div>
		</div>

		</div>

	<input type="text" class="combatPaletteName transpInput" name="attr_weapon3Name" data-i18n-placeholder="palette-weapon3-name" placeholder="Weapon (3)">

	</div>

	<div class="rowContainer half" style="position: relative;">
	
	<div class="paletteRange"></div>


		<div class="rowContainer darkInput paletteDice">
			<input type="text" name="attr_weapon3Roll1" placeholder="1" value="(@{weapon3Dice1} + @{selectAtkDice1})" disabled="true">
			<div class="plainText">D</div>
			<input type="text" name="attr_weapon3Roll2" placeholder="6" value="(@{weapon3Dice2} + @{selectAtkDice2})" disabled="true">
			<div class="plainText">+</div>
			<input type="text" name="attr_weapon3Roll3" placeholder="0" value="(@{weapon3Dice3}+@{attPower}+@{selectAtkDice3}+@{Strength}-@{Feeble}+@{difficulty})" disabled="true">
	</div>

	<button type="action" class="NDice" id="autoroll_weapon3" name="act_rollCombat"></button>
	</div>

<!-- Distortion (Weapon 3) Palette -->
	<div class="paletteOverride">

	<input type="checkbox" class="hide-toggle" name="attr_distortState" value="true">
	<div class="hide-item">
	
		<!-- actual content -->
		<div class="rowContainer egoAttPalette paletteButton">
		<div class="rowContainer half centerFlex">

		<div class="iconHolder">

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Slash" name="attr_weapon3Type"><div class="type-image typeIcon egoSlash"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Pierce" name="attr_weapon3Type"><div class="type-image typeIcon egoPierce"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Blunt" name="attr_weapon3Type"><div class="type-image typeIcon egoBlunt"></div>
		</div>

		</div>

	<input type="text" class="combatPaletteName transpInput" name="attr_weapon3Name" data-i18n-placeholder="palette-weapon3-name" placeholder="Weapon (3)">

		</div> <!-- first half -->

	<div class="rowContainer half" style="position: relative;">
	
	<div class="paletteRange"></div>


	<div class="rowContainer darkInput paletteDice">
			<input type="text" name="attr_weapon3Roll1" placeholder="1" value="(@{weapon3Dice1} + @{selectAtkDice1} + @{distortWeaponDice1})" disabled="true">
			<div class="plainText">D</div>
			<input type="text" name="attr_weapon3Roll2" placeholder="6" value="(@{weapon3Dice2} + @{selectAtkDice2} + @{distortWeaponDice2})" disabled="true">
			<div class="plainText">+</div>
			<input type="text" name="attr_weapon3Roll3" placeholder="0" value="(@{weapon3Dice3}+@{attPower}+@{selectAtkDice3}+@{distortWeaponDice3}+@{Strength}-@{Feeble}+@{difficulty})" disabled="true">
	</div>

<button type="action" class="NDice" id="autoroll_weapon3_distort" name="act_rollCombat"></button>


		</div>			
       </div>
</div></div>
	<!-- Distortion (Weapon 3) Palette END -->


		</div>
        </div>
	</div>

	<!-- Weapon 3 Palette END -->

	<!-- Weapon 4 Palette -->
	<div class="weaponSlot">
			<input type="checkbox" class="hide-toggle-rev" name="attr_weapon4Name" value="" hidden="true" checked>
	<div class="hide-item-rev" style="width: 100%;">

	<div class="rowContainer weapon paletteButton">

	<!-- Weapon4 Uses -->
	<div class="buffer weaponPaletteUses">
	<input type="checkbox" class="hide-toggle-rev" name="attr_weapon4UseType" value="Limitless" hidden="true" checked>
		<div class="hide-item-rev rowContainer centerFlex" style="position: relative;">

		<input type="text" class="transpInput blocker" name="attr_weapon4Uses" style="text-align: center; height: 100%;" value="5">

		<input type="checkbox" class="fade-toggle" name="attr_weapon4UseType" value="Deplete" hidden="true">
		<div class="fade-item centerIcon reusable" style="width: 30px; height: 30px;"></div>  
		<div class="blocker"></div>
		</div>

	</div>

	<div class="buffer">
	<input type="checkbox" class="hide-toggle" name="attr_weapon4Uses" value="0" hidden="true">
		<div class="hide-item">
		<div class="blocker weaponBlocker"></div>
		</div>
	</div>
	<!-- Weapon4 Uses END -->

	<div class="rowContainer half centerFlex">
		<div class="iconHolder">

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Slash" name="attr_weapon4Type"><div class="type-image typeIcon slash"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Pierce" name="attr_weapon4Type"><div class="type-image typeIcon pierce"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Blunt" name="attr_weapon4Type"><div class="type-image typeIcon blunt"></div>
		</div>

		</div>

	<input type="text" class="combatPaletteName transpInput" name="attr_weapon4Name" data-i18n-placeholder="palette-weapon4-name" placeholder="Weapon (4)">

	</div>

	<div class="rowContainer half" style="position: relative;">
	
	<div class="paletteRange"></div>


	<div class="rowContainer darkInput paletteDice">
			<input type="text" name="attr_weapon4Roll1" placeholder="1" value="(@{weapon4Dice1} + @{selectAtkDice1})" disabled="true">
			<div class="plainText">D</div>
			<input type="text" name="attr_weapon4Roll2" placeholder="6" value="(@{weapon4Dice2} + @{selectAtkDice2})" disabled="true">
			<div class="plainText">+</div>
			<input type="text" name="attr_weapon4Roll3" placeholder="0" value="(@{weapon4Dice3}+@{attPower}+@{selectAtkDice3}+@{Strength}-@{Feeble}+@{difficulty})" disabled="true">
	</div>

	<button type="action" class="NDice" id="autoroll_weapon4" name="act_rollCombat"></button>
	</div>

<!-- Distortion (Weapon 4) Palette -->
	<div class="paletteOverride">

	<input type="checkbox" class="hide-toggle" name="attr_distortState" value="true">
	<div class="hide-item">
	
		<!-- actual content -->
		<div class="rowContainer egoAttPalette paletteButton">
		<div class="rowContainer half centerFlex">

		<div class="iconHolder">

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Slash" name="attr_weapon4Type"><div class="type-image typeIcon egoSlash"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Pierce" name="attr_weapon4Type"><div class="type-image typeIcon egoPierce"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Blunt" name="attr_weapon4Type"><div class="type-image typeIcon egoBlunt"></div>
		</div>

		</div>

	<input type="text" class="combatPaletteName transpInput" name="attr_weapon4Name" data-i18n-placeholder="palette-weapon4-name" placeholder="Weapon (4)">

		</div> <!-- first half -->

	<div class="rowContainer half" style="position: relative;">
	
	<div class="paletteRange"></div>


	<div class="rowContainer darkInput paletteDice">
			<input type="text" name="attr_weapon4Roll1" placeholder="1" value="(@{weapon4Dice1} + @{selectAtkDice1} + @{distortWeaponDice1})" disabled="true">
			<div class="plainText">D</div>
			<input type="text" name="attr_weapon4Roll2" placeholder="6" value="(@{weapon4Dice2} + @{selectAtkDice2} + @{distortWeaponDice2})" disabled="true">
			<div class="plainText">+</div>
			<input type="text" name="attr_weapon4Roll3" placeholder="0" value="(@{weapon4Dice3}+@{attPower}+@{selectAtkDice3}+@{distortWeaponDice3}+@{Strength}-@{Feeble}+@{difficulty})" disabled="true">
	</div>

<button type="action" class="NDice" id="autoroll_weapon4_distort" name="act_rollCombat"></button>


		</div>			
       </div>
</div></div>
	<!-- Distortion (Weapon 4) Palette END -->


		</div>
        </div>
	</div>

	<!-- Weapon 4 Palette END -->

	<!-- Weapon EXTRA palette END -->

	

	<!-- Def/Evd palette -->
	<div class="rowContainer" style="gap: 5px;">

	<!-- Action Palette -->
	<div class="rowContainer half">


	<!-- Distortion (Action) Palette -->
	<div class="paletteOverride">

	<input type="checkbox" class="hide-toggle" name="attr_distortState" value="true">
	<div class="hide-item">
	
	<div class="columnAlign BLACK paletteButton" style="height: 63px; overflow: hidden; align-items: start; justify-content: start;">
	<div class="rowContainer" style="height: 50%;">
	<select name="attr_actionType" class="darkInput toolText" style="height: 100%; margin-bottom: 0px;">
         <option data-i18n="palette-action-tool" value="tool">Use Tool</option>
         <option data-i18n="palette-action-move" value="move">Move</option>
         <option data-i18n="palette-action-protect" value="protect">Protect</option>
	 <option data-i18n="palette-action-other" value="other">Other</option>
         </select>

	<button type="action" class="declare toolText" data-i18n="palette-action-text" name="act_declareAction">Action</button>
	</div>
		
       </div>
	</div>
	</div>

	<!-- Distortion (Action) Palette END -->

	<div class="columnAlign tool paletteButton" style="height: 63px; overflow: hidden;  justify-content: start;">
	<div class="rowContainer" style="height: 50%;">
	<select name="attr_actionType" class="darkInput" style="height: 100%; margin-bottom: 0px;">
         <option data-i18n="palette-action-tool" value="tool">Use Tool</option>
         <option data-i18n="palette-action-move" value="move">Move</option>
         <option data-i18n="palette-action-protect" value="protect">Protect</option>
	 <option data-i18n="palette-action-other" value="other">Other</option>
         </select>

	<button type="action" class="declare" data-i18n="palette-action-text" name="act_declareAction">Action</button>
	</div>
	
<!-- Tool Selector Box -->
	<div class="rowContainer centerFlex toolSelect">


	<!-- EGO Tool selector -->

	<div>


	<input type="checkbox" class="hide-toggle" name="attr_egoActiveState" value="true" hidden="true"><div class="hide-item">

	<input type="checkbox" class="hide-toggle" name="attr_egoType" value="Tool" hidden="true"><div class="hide-item">

	<div class="toolSelectHolder">

	<input id="select-egoTool" class="toolSelector" type="checkbox" name="attr_toolSelect" value="egoTool">
	<label for="select-egoTool" class="skillSelectionLabel">

	<div class="blocker toolBlocker"></div>	

<input type="checkbox" class="hide-toggle-rev" name="attr_egoUseType" value="Limitless" hidden="true" checked>
	<input type="text" name="attr_egoUses" class="hide-item-rev toolSelectBox" value="5">

	<div class="icon">
	<input type="checkbox" class="expand-toggle" value="Tool" name="attr_egoType"><div class="type-image skillIcon egoAct"></div>
	</div>

	</label>


	<input type="checkbox" class="hide-toggle" name="attr_egoUses" value="0" hidden="true"><div class="hide-item blocker" style="z-index: 100;"></div>

	</div>

	</div> 
	</div>
	</div>
	<!-- EGO tool selector end -->

	<!-- EGO special selector -->
	<div>


	<input type="checkbox" class="hide-toggle" name="attr_egoActiveState" value="true" hidden="true"><div class="hide-item">

	<input type="checkbox" class="hide-toggle" name="attr_egoType" value="Special" hidden="true"><div class="hide-item">

	<div class="toolSelectHolder">

	<input id="select-egoSpecial" class="toolSelector" type="checkbox" name="attr_toolSelect" value="egoSpecial">
	<label for="select-egoSpecial" class="skillSelectionLabel">

	<div class="blocker toolBlocker"></div>

<input type="checkbox" class="hide-toggle-rev" name="attr_egoUseType" value="Limitless" hidden="true" checked>
	<input type="text" name="attr_egoUses" class="hide-item-rev toolSelectBox" value="5">

	<div class="icon">
	<input type="checkbox" class="expand-toggle" value="Special" name="attr_egoType"><div class="type-image skillIcon egoSpecial"></div>
	</div>

	</label>

	<input type="checkbox" class="hide-toggle" name="attr_egoUses" value="0" hidden="true"><div class="hide-item blocker" style="z-index: 100;"></div>

	</div>

	</div> 
	</div>
	</div>
	<!-- EGO special end -->



	<!-- Tool1 selector -->

	<div>
	<input type="checkbox" class="hide-toggle-rev" name="attr_tool1Uses" value="0" hidden="true">
	<div class="hide-item-rev">
	<input type="checkbox" class="hide-toggle-rev" name="attr_tool1Name" value="" hidden="true" checked>
	<div class="toolSelectHolder hide-item-rev">

	<input id="select-tool1" class="toolSelector" type="checkbox" name="attr_toolSelect" value="tool1">
	<label for="select-tool1" class="skillSelectionLabel">

	<div class="blocker toolBlocker"></div>
	
	<input type="text" name="attr_tool1Uses" class="toolSelectBox" value="1">

	<!-- Tool1 Icon Selection -->
	<div class="icon">
	<img name="attr_tool1IconDisplay" class="skillIcon">
	</div>

	</label>

	</div> 
	</div>
	</div>
	<!-- Tool1 selector end -->

	<!-- Tool2 selector -->

	<div>
	<input type="checkbox" class="hide-toggle-rev" name="attr_tool2Uses" value="0" hidden="true">
	<div class="hide-item-rev">
	<input type="checkbox" class="hide-toggle-rev" name="attr_tool2Name" value="" hidden="true" checked>
	<div class="toolSelectHolder hide-item-rev">

	<input id="select-tool2" class="toolSelector" type="checkbox" name="attr_toolSelect" value="tool2">
	<label for="select-tool2" class="skillSelectionLabel">

	<div class="blocker toolBlocker"></div>
	

	<input type="text" name="attr_tool2Uses" class="toolSelectBox" value="1">

	<!-- Tool2 Icon Selection -->
	<div class="icon">
	<img name="attr_tool2IconDisplay" class="skillIcon">
	</div>

	</label>

	</div> 
	</div>
	</div>
	<!-- Tool2 selector end -->

	<!-- Tool3 selector -->

	<div>
	<input type="checkbox" class="hide-toggle-rev" name="attr_tool3Uses" value="0" hidden="true">
	<div class="hide-item-rev">
	<input type="checkbox" class="hide-toggle-rev" name="attr_tool3Name" value="" hidden="true" checked>
	<div class="toolSelectHolder hide-item-rev">

	<input id="select-tool3" class="toolSelector" type="checkbox" name="attr_toolSelect" value="tool3">
	<label for="select-tool3" class="skillSelectionLabel">

	<div class="blocker toolBlocker"></div>
	

	<input type="text" name="attr_tool3Uses" class="toolSelectBox" value="1">

	<!-- Tool3 Icon Selection -->
	<div class="icon">
	<img name="attr_tool3IconDisplay" class="skillIcon">
	</div>

	</label>

	</div> 
	</div>
	</div>
	<!-- Tool3 selector end -->

	<!-- Tool4 selector -->

	<div>
	<input type="checkbox" class="hide-toggle-rev" name="attr_tool4Uses" value="0" hidden="true">
	<div class="hide-item-rev">
	<input type="checkbox" class="hide-toggle-rev" name="attr_tool4Name" value="" hidden="true" checked>
	<div class="toolSelectHolder hide-item-rev">

	<input id="select-tool4" class="toolSelector" type="checkbox" name="attr_toolSelect" value="tool4">
	<label for="select-tool4" class="skillSelectionLabel">

	<div class="blocker toolBlocker"></div>
	

	<input type="text" name="attr_tool4Uses" class="toolSelectBox" value="1">

	<!-- Tool4 Icon Selection -->
	<div class="icon">
	<img name="attr_tool4IconDisplay" class="skillIcon">
	</div>

	</label>

	</div> 
	</div>
	</div>
	<!-- Tool4 selector end -->


	<!-- Special1 selector -->
	<div>
	<input type="checkbox" class="hide-toggle-rev" name="attr_special1Name" value="" hidden="true" checked>
	<div class="toolSelectHolder hide-item-rev">
	<input id="select-special1" class="toolSelector" type="checkbox" name="attr_toolSelect" value="special1">
	<label for="select-special1" class="skillSelectionLabel">

	<div class="type-image skillIcon skillSpecial"></div>

	</label>

	</div> 
	</div>
	<!-- Special1 selector end -->

	<!-- Special2 selector -->
	<div>
	<input type="checkbox" class="hide-toggle-rev" name="attr_special2Name" value="" hidden="true" checked>
	<div class="toolSelectHolder hide-item-rev">
	<input id="select-special2" class="toolSelector" type="checkbox" name="attr_toolSelect" value="special2">
	<label for="select-special2" class="skillSelectionLabel">

	<div class="type-image skillIcon skillSpecial"></div>

	</label>

	</div> 
	</div>
	<!-- Special2 selector end -->



	</div>
	<!-- Tool selector Box end -->

	</div>

	</div>
	<!-- Action Palette END -->

	<!-- Def Palette -->
	<div class="rowContainer columnAlign" style="width: calc(50% - 5px);">
	<div class="rowContainer outfit paletteButton" style="justify-content: flex-start;">

		<div class="iconHolder">
			<div class="type-image typeIcon defend"></div>
		</div>

		<div class="rowContainer" style="left: -4px;">

			<div class="rowContainer darkInput paletteDice">
			<input type="text" name="attr_defRoll1" placeholder="1" value="(@{defDice1} + @{selectDefDice1})" disabled="true">
			<div class="plainText">D</div>
			<input type="text" name="attr_defRoll2" placeholder="6" value="(@{defDice2} + @{selectDefDice2})" disabled="true">
			<div class="plainText">+</div>
			<input type="text" name="attr_defRoll3" placeholder="0" value="(@{defDice3}+@{defPower}+@{selectDefDice3}+@{Endurance}-@{Disarm}+@{difficulty})" disabled="true">
	</div>



	<button type="action" class="NDice" id="autoroll_def" name="act_rollCombat"></button>		
		</div>

	<!-- EGO (Def) Palette -->
	<div class="paletteOverride">

	<input type="checkbox" class="hide-toggle" name="attr_egoActiveState" value="true">
	<div class="hide-item">

		<input type="checkbox" class="hide-toggle" name="attr_egoType" value="Outfit">
		<div class="hide-item">
	
		<div class="rowContainer egoDefPalette paletteButton" style="justify-content: flex-start;">
		<div class="iconHolder">
		<div class="type-image typeIcon egoDef"></div>
		</div>

		<div class="rowContainer" style="left: -4px;">
	<div class="rowContainer darkInput paletteDice">
			<input type="text" name="attr_egoDefRoll1" placeholder="1" value="(@{egoDefDice1} + @{selectDefDice1})" disabled="true">
			<div class="plainText">D</div>
			<input type="text" name="attr_egoDefRoll2" placeholder="6" value="(@{egoDefDice2} + @{selectDefDice2})" disabled="true">
			<div class="plainText">+</div>
			<input type="text" name="attr_egoDefRoll3" placeholder="0" value="(@{egoDefDice3}+@{defPower}+@{selectDefDice3}+@{Endurance}-@{Disarm}+@{difficulty})" disabled="true">
	</div>

<button type="action" class="NDice" id="autoroll_egoDef" name="act_rollCombat"></button>			
		</div>

	</div></div></div></div>
	<!-- EGO (Def) Palette END -->

	<!-- Distort (Def) Palette -->
	<div class="paletteOverride">

	<input type="checkbox" class="hide-toggle" name="attr_distortState" value="true">
	<div class="hide-item">
	
		<div class="rowContainer egoDefPalette paletteButton" style="justify-content: flex-start;">
		<div class="iconHolder">
		<div class="type-image typeIcon egoDef"></div>
		</div>

		<div class="rowContainer" style="left: -4px;">
	<div class="rowContainer darkInput paletteDice">
			<input type="text" name="attr_distortDefRoll1" placeholder="1" value="(@{defDice1} + @{distortDefDice1} + @{selectDefDice1})" disabled="true">
			<div class="plainText">D</div>
			<input type="text" name="attr_distortDefRoll2" placeholder="6" value="(@{defDice2} + @{distortDefDice2} + @{selectDefDice2})" disabled="true">
			<div class="plainText">+</div>
			<input type="text" name="attr_distortDefRoll3" placeholder="0" value="(@{defDice3}+@{distortDefDice3}+@{defPower}+@{selectDefDice3}+@{Endurance}-@{Disarm}+@{difficulty})" disabled="true">
	</div>

<button type="action" class="NDice" id="autoroll_def_distort" name="act_rollCombat"></button>			
		</div>

	</div>

	</div></div>
	<!-- Distort (Def) Palette END -->




	</div>
              

	<!-- Defend Palette END -->

	<!-- Evade Palette -->
	<div class="rowContainer STGR paletteButton" style="justify-content: flex-start;">

		<div class="iconHolder">
		<div class="type-image typeIcon evade"></div>
		</div>

		<div class="rowContainer" style="left: -4px;">
		<div class="rowContainer darkInput paletteDice">
			<input type="text" name="attr_evdRoll1" placeholder="1" value="(@{evdDice1} + @{selectEvdDice1})" disabled="true">
			<div class="plainText">D</div>
			<input type="text" name="attr_evdRoll2" placeholder="6" value="(@{evdDice2} + @{selectEvdDice2})" disabled="true">
			<div class="plainText">+</div>
			<input type="text" name="attr_evdRoll3" placeholder="0" value="(@{evdDice3}+@{evdPower}+@{evdPositive}-@{evdNegative}+@{selectEvdDice3}+@{difficulty})" disabled="true">
	</div>

<button type="action" class="NDice" id="autoroll_evd" name="act_rollCombat"></button>			
		</div>

	<!-- EGO (Evd) Palette -->
	<div class="paletteOverride">

	<input type="checkbox" class="hide-toggle" name="attr_egoActiveState" value="true">
	<div class="hide-item">

		<input type="checkbox" class="hide-toggle" name="attr_egoType" value="Outfit">
		<div class="hide-item">
	

<div class="rowContainer egoEvdPalette paletteButton" style="justify-content: flex-start;">

		<div class="iconHolder">
		<div class="type-image typeIcon egoEvd"></div>
		</div>

		<div class="rowContainer" style="left: -4px;">
		<div class="rowContainer darkInput paletteDice">
			<input type="text" name="attr_egoEvdRoll1" placeholder="1" value="(@{egoEvdDice1} + @{selectEvdDice1})" disabled="true">
			<div class="plainText">D</div>
			<input type="text" name="attr_egoEvdRoll2" placeholder="6" value="(@{egoEvdDice2} + @{selectEvdDice2})" disabled="true">
			<div class="plainText">+</div>
			<input type="text" name="attr_egoEvdRoll3" placeholder="0" value="(@{egoEvdDice3}+@{evdPower}+@{evdPositive}-@{evdNegative}+@{selectEvdDice3}+@{difficulty})" disabled="true">
	</div>

<button type="action" class="NDice" id="autoroll_egoEvd" name="act_rollCombat"></button>			
		</div>

	</div>

		</div></div></div>

	<!-- EGO (Evd) Palette END -->

	<!-- Distort (Evd) Palette -->
	<div class="paletteOverride">

	<input type="checkbox" class="hide-toggle" name="attr_distortState" value="true">
	<div class="hide-item">

<div class="rowContainer egoEvdPalette paletteButton" style="justify-content: flex-start;">

		<div class="iconHolder">
		<div class="type-image typeIcon egoEvd"></div>
		</div>

		<div class="rowContainer" style="left: -4px;">
		<div class="rowContainer darkInput paletteDice">
			<input type="text" name="attr_distortEvdRoll1" placeholder="1" value="(@{evdDice1} + @{distortEvdDice1} + @{selectEvdDice1})" disabled="true">
			<div class="plainText">D</div>
			<input type="text" name="attr_distortEvdRoll2" placeholder="6" value="(@{evdDice2} + @{distortEvdDice2} + @{selectEvdDice2})" disabled="true">
			<div class="plainText">+</div>
			<input type="text" name="attr_distortEvdRoll3" placeholder="0" value="(@{evdDice3}+@{distortEvdDice3}+@{evdPower}+@{evdPositive}-@{evdNegative}+@{selectEvdDice3}+@{difficulty})" disabled="true">
	</div>

<button type="action" class="NDice" id="autoroll_evd_distort" name="act_rollCombat"></button>			
		</div>

	</div>

		</div></div></div>
	<!-- Distort (Evd) Palette END -->




		</div>
	<!-- Evade Palette END -->
              
	</div>
<!-- Def/Evd section END -->


	<div class="skillSelect">

<!-- Skill palette selection area (normal) -->

<input type="checkbox" class="hide-toggle-rev" name="attr_distortState" value="true" hidden="true" checked>
<div class="hide-item-rev" style="width: 100%;">

<div class="rowContainer centerFlex" style="width: 100%; flex-wrap: wrap; margin-top: 5px;">

<!-- EGO Skill 1 Palette -->
<div class="skillBuffer">
<input type="checkbox" class="hide-toggle-rev" name="attr_egoActiveState" value="0" hidden="true" checked>
<input type="checkbox" class="hide-toggle-rev" name="attr_egoSkill1Type" value="None" hidden="true" checked>
	<div class="hide-item-rev skillhide">
	<div class="rowContainer paletteButton skillSelectionElement" style="width: 100%;">

	<input id="select-egoSkill1" class="skillSelector" type="checkbox" name="attr_skillSelect" value="egoSkill1">
	<label for="select-egoSkill1" class="skillSelectionLabel" style="width: 100%;">
	<div class="skillWrap">

	<div style="position: relative;">
	<div class="blocker"></div>
	<input type="text" class="combatPaletteName skillSelectionName" name="attr_egoSkill1Name" data-i18n-placeholder="palette-egoskill1-name" placeholder="MYS Skill (1)">
	</div>

<div class="iconHolder egoSkills">
		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="" name="attr_egoSkill1Type"><div class="skillIcon skillNone"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Attack" name="attr_egoSkill1Type"><div class="skillIcon skillAtt"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Defend" name="attr_egoSkill1Type"><div class="type-image skillIcon skillDef"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Evade" name="attr_egoSkill1Type"><div class="type-image skillIcon skillEvd"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Action" name="attr_egoSkill1Type"><div class="type-image skillIcon skillAct"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Mass" name="attr_egoSkill1Type"><div class="type-image skillIcon skillMass"></div>
		</div>

	</div>

	</div>

	</label>
	</div>
	</div>
</div>
<!-- EGO Skill 1 block END -->

<!-- Skill 1 Palette -->
<div class="skillBuffer">
<input type="checkbox" class="hide-toggle-rev" name="attr_skill1Type" value="None" hidden="true" checked>
	<div class="hide-item-rev skillhide">
	<div class="rowContainer paletteButton skillSelectionElement" style="width: 100%;">

	<input id="select-skill1" class="skillSelector" type="checkbox" name="attr_skillSelect" value="skill1">
	<label for="select-skill1" class="skillSelectionLabel" style="width: 100%;">
	<div class="skillWrap">

	<div style="position: relative;">
	<div class="blocker"></div>
	<input type="text" class="combatPaletteName skillSelectionName" name="attr_skill1Name" data-i18n-placeholder="palette-skill1-name" placeholder="Skill (1)">
	</div>


<div class="iconHolder">
		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="" name="attr_skill1Type"><div class="skillIcon skillNone"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Attack" name="attr_skill1Type"><div class="skillIcon skillAtt weapon"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Defend" name="attr_skill1Type"><div class="type-image skillIcon skillDef outfit"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Evade" name="attr_skill1Type"><div class="type-image skillIcon skillEvd STGR"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Action" name="attr_skill1Type"><div class="type-image skillIcon skillAct tool"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Mass" name="attr_skill1Type"><div class="type-image skillIcon skillMass weapon"></div>
		</div>

	</div>

	</div>

	</label>
	</div>
	</div>
</div>
<!-- Skill 1 block END -->

<!-- EGO Skill 2 Palette -->
<div class="skillBuffer">
<input type="checkbox" class="hide-toggle-rev" name="attr_egoActiveState" value="0" hidden="true" checked>
<input type="checkbox" class="hide-toggle-rev" name="attr_egoSkill2Type" value="None" hidden="true" checked>
	<div class="hide-item-rev skillhide">
	<div class="rowContainer paletteButton skillSelectionElement" style="width: 100%;">

	<input id="select-egoSkill2" class="skillSelector" type="checkbox" name="attr_skillSelect" value="egoSkill2">
	<label for="select-egoSkill2" class="skillSelectionLabel" style="width: 100%;">
	<div class="skillWrap">

	<div style="position: relative;">
	<div class="blocker"></div>
	<input type="text" class="combatPaletteName skillSelectionName" name="attr_egoSkill2Name" data-i18n-placeholder="palette-egoskill2-name" placeholder="MYS Skill (2)">
	</div>

<div class="iconHolder egoSkills">
		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="" name="attr_egoSkill2Type"><div class="skillIcon skillNone"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Attack" name="attr_egoSkill2Type"><div class="skillIcon skillAtt"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Defend" name="attr_egoSkill2Type"><div class="type-image skillIcon skillDef"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Evade" name="attr_egoSkill2Type"><div class="type-image skillIcon skillEvd"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Action" name="attr_egoSkill2Type"><div class="type-image skillIcon skillAct"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Mass" name="attr_egoSkill2Type"><div class="type-image skillIcon skillMass"></div>
		</div>

	</div>

	</div>

	</label>
	</div>
	</div>
</div>
<!-- EGO Skill 2 block END -->

<!-- Skill 2 Palette -->
<div class="skillBuffer">
<input type="checkbox" class="hide-toggle-rev" name="attr_skill2Type" value="None" hidden="true" checked>
	<div class="hide-item-rev skillhide">
	<div class="rowContainer paletteButton skillSelectionElement" style="width: 100%;">

	<input id="select-skill2" class="skillSelector" type="checkbox" name="attr_skillSelect" value="skill2">
	<label for="select-skill2" class="skillSelectionLabel" style="width: 100%;">
	<div class="skillWrap">

	<div style="position: relative;">
	<div class="blocker"></div>
	<input type="text" class="combatPaletteName skillSelectionName" name="attr_skill2Name" data-i18n-placeholder="palette-skill2-name" placeholder="Skill (2)">
	</div>

<div class="iconHolder">
		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="" name="attr_skill2Type"><div class="skillIcon skillNone"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Attack" name="attr_skill2Type"><div class="skillIcon skillAtt weapon"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Defend" name="attr_skill2Type"><div class="type-image skillIcon skillDef outfit"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Evade" name="attr_skill2Type"><div class="type-image skillIcon skillEvd STGR"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Action" name="attr_skill2Type"><div class="type-image skillIcon skillAct tool"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Mass" name="attr_skill2Type"><div class="type-image skillIcon skillMass weapon"></div>
		</div>

	</div>

	</div>

	</label>
	</div>
	</div>
</div>
<!-- Skill 2 block END -->

<!-- EGO Skill 3 Palette -->
<div class="skillBuffer">
<input type="checkbox" class="hide-toggle-rev" name="attr_egoActiveState" value="0" hidden="true" checked>
<input type="checkbox" class="hide-toggle-rev" name="attr_egoSkill3Type" value="None" hidden="true" checked>
	<div class="hide-item-rev skillhide">
	<div class="rowContainer paletteButton skillSelectionElement" style="width: 100%;">

	<input id="select-egoSkill3" class="skillSelector" type="checkbox" name="attr_skillSelect" value="egoSkill3">
	<label for="select-egoSkill3" class="skillSelectionLabel" style="width: 100%;">
	<div class="skillWrap">

	<div style="position: relative;">
	<div class="blocker"></div>
	<input type="text" class="combatPaletteName skillSelectionName" name="attr_egoSkill3Name" data-i18n-placeholder="palette-egoskill3-name" placeholder="MYS Skill (3)">
	</div>

<div class="iconHolder egoSkills">
		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="" name="attr_egoSkill3Type"><div class="skillIcon skillNone"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Attack" name="attr_egoSkill3Type"><div class="skillIcon skillAtt"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Defend" name="attr_egoSkill3Type"><div class="type-image skillIcon skillDef"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Evade" name="attr_egoSkill3Type"><div class="type-image skillIcon skillEvd"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Action" name="attr_egoSkill3Type"><div class="type-image skillIcon skillAct"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Mass" name="attr_egoSkill3Type"><div class="type-image skillIcon skillMass"></div>
		</div>

	</div>

	</div>

	</label>
	</div>
	</div>
</div>
<!-- EGO Skill 3 block END -->


<!-- Skill 3 Palette -->
<div class="skillBuffer">
<input type="checkbox" class="hide-toggle-rev" name="attr_skill3Type" value="None" hidden="true" checked>
	<div class="hide-item-rev skillhide">
	<div class="rowContainer paletteButton skillSelectionElement" style="width: 100%;">

	<input id="select-skill3" class="skillSelector" type="checkbox" name="attr_skillSelect" value="skill3">
	<label for="select-skill3" class="skillSelectionLabel" style="width: 100%;">
	<div class="skillWrap">

	<div style="position: relative;">
	<div class="blocker"></div>
	<input type="text" class="combatPaletteName skillSelectionName" name="attr_skill3Name" data-i18n-placeholder="palette-skill3-name" placeholder="Skill (3)">
	</div>

<div class="iconHolder">
		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="" name="attr_skill3Type"><div class="skillIcon skillNone"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Attack" name="attr_skill3Type"><div class="skillIcon skillAtt weapon"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Defend" name="attr_skill3Type"><div class="type-image skillIcon skillDef outfit"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Evade" name="attr_skill3Type"><div class="type-image skillIcon skillEvd STGR"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Action" name="attr_skill3Type"><div class="type-image skillIcon skillAct tool"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Mass" name="attr_skill3Type"><div class="type-image skillIcon skillMass weapon"></div>
		</div>

	</div>

	</div>

	</label>
	</div>
	</div>
</div>
<!-- Skill 3 block END -->

<!-- EGO Skill 4 Palette -->
<div class="skillBuffer">
<input type="checkbox" class="hide-toggle-rev" name="attr_egoActiveState" value="0" hidden="true" checked>
<input type="checkbox" class="hide-toggle-rev" name="attr_egoSkill4Type" value="None" hidden="true" checked>
	<div class="hide-item-rev skillhide">
	<div class="rowContainer paletteButton skillSelectionElement" style="width: 100%;">

	<input id="select-egoSkill4" class="skillSelector" type="checkbox" name="attr_skillSelect" value="egoSkill4">
	<label for="select-egoSkill4" class="skillSelectionLabel" style="width: 100%;">
	<div class="skillWrap">

	<div style="position: relative;">
	<div class="blocker"></div>
	<input type="text" class="combatPaletteName skillSelectionName" name="attr_egoSkill4Name" data-i18n-placeholder="palette-egoskill4-name" placeholder="MYS Skill (4)">
	</div>

<div class="iconHolder egoSkills">
		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="" name="attr_egoSkill4Type"><div class="skillIcon skillNone"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Attack" name="attr_egoSkill4Type"><div class="skillIcon skillAtt"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Defend" name="attr_egoSkill4Type"><div class="type-image skillIcon skillDef"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Evade" name="attr_egoSkill4Type"><div class="type-image skillIcon skillEvd"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Action" name="attr_egoSkill4Type"><div class="type-image skillIcon skillAct"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Mass" name="attr_egoSkill4Type"><div class="type-image skillIcon skillMass"></div>
		</div>

	</div>

	</div>

	</label>
	</div>
	</div>
</div>
<!-- EGO Skill 4 block END -->

<!-- Skill 4 Palette -->
<div class="skillBuffer">
<input type="checkbox" class="hide-toggle-rev" name="attr_skill4Type" value="None" hidden="true" checked>
	<div class="hide-item-rev skillhide">
	<div class="rowContainer paletteButton skillSelectionElement" style="width: 100%;">

	<input id="select-skill4" class="skillSelector" type="checkbox" name="attr_skillSelect" value="skill4">
	<label for="select-skill4" class="skillSelectionLabel" style="width: 100%;">
	<div class="skillWrap">

	<div style="position: relative;">
	<div class="blocker"></div>
	<input type="text" class="combatPaletteName skillSelectionName" name="attr_skill4Name" data-i18n-placeholder="palette-skill4-name" placeholder="Skill (4)">
	</div>

<div class="iconHolder">
		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="" name="attr_skill4Type"><div class="skillIcon skillNone"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Attack" name="attr_skill4Type"><div class="skillIcon skillAtt weapon"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Defend" name="attr_skill4Type"><div class="type-image skillIcon skillDef outfit"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Evade" name="attr_skill4Type"><div class="type-image skillIcon skillEvd STGR"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Action" name="attr_skill4Type"><div class="type-image skillIcon skillAct tool"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Mass" name="attr_skill4Type"><div class="type-image skillIcon skillMass weapon"></div>
		</div>

	</div>

	</div>

	</label>
	</div>
	</div>
</div>
<!-- Skill 4 block END -->

<!-- EGO Skill 5 Palette -->
<div class="skillBuffer">
<input type="checkbox" class="hide-toggle-rev" name="attr_egoActiveState" value="0" hidden="true" checked>
<input type="checkbox" class="hide-toggle-rev" name="attr_egoSkill5Type" value="None" hidden="true" checked>
	<div class="hide-item-rev skillhide">
	<div class="rowContainer paletteButton skillSelectionElement" style="width: 100%;">

	<input id="select-egoSkill5" class="skillSelector" type="checkbox" name="attr_skillSelect" value="egoSkill5">
	<label for="select-egoSkill5" class="skillSelectionLabel" style="width: 100%;">
	<div class="skillWrap">

	<div style="position: relative;">
	<div class="blocker"></div>
	<input type="text" class="combatPaletteName skillSelectionName" name="attr_egoSkill5Name" data-i18n-placeholder="palette-egoskill5-name" placeholder="MYS Skill (5)">
	</div>

<div class="iconHolder egoSkills">
		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="" name="attr_egoSkill5Type"><div class="skillIcon skillNone"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Attack" name="attr_egoSkill5Type"><div class="skillIcon skillAtt"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Defend" name="attr_egoSkill5Type"><div class="type-image skillIcon skillDef"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Evade" name="attr_egoSkill5Type"><div class="type-image skillIcon skillEvd"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Action" name="attr_egoSkill5Type"><div class="type-image skillIcon skillAct"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Mass" name="attr_egoSkill5Type"><div class="type-image skillIcon skillMass"></div>
		</div>

	</div>

	</div>

	</label>
	</div>
	</div>
</div>
<!-- EGO Skill 5 block END -->

<!-- Skill 5 Palette -->
<div class="skillBuffer">
<input type="checkbox" class="hide-toggle-rev" name="attr_skill5Type" value="None" hidden="true" checked>
	<div class="hide-item-rev skillhide">
	<div class="rowContainer paletteButton skillSelectionElement" style="width: 100%;">

	<input id="select-skill5" class="skillSelector" type="checkbox" name="attr_skillSelect" value="skill5">
	<label for="select-skill5" class="skillSelectionLabel" style="width: 100%;">
	<div class="skillWrap">

	<div style="position: relative;">
	<div class="blocker"></div>
	<input type="text" class="combatPaletteName skillSelectionName" name="attr_skill5Name" data-i18n-placeholder="palette-skill5-name" placeholder="Skill (5)">
	</div>

<div class="iconHolder">
		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="" name="attr_skill5Type"><div class="skillIcon skillNone"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Attack" name="attr_skill5Type"><div class="skillIcon skillAtt weapon"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Defend" name="attr_skill5Type"><div class="type-image skillIcon skillDef outfit"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Evade" name="attr_skill5Type"><div class="type-image skillIcon skillEvd STGR"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Action" name="attr_skill5Type"><div class="type-image skillIcon skillAct tool"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Mass" name="attr_skill5Type"><div class="type-image skillIcon skillMass weapon"></div>
		</div>

	</div>

	</div>

	</label>
	</div>
	</div>
</div>
<!-- Skill 5 block END -->

<!-- EGO Skill 6 Palette -->
<div class="skillBuffer">
<input type="checkbox" class="hide-toggle-rev" name="attr_egoActiveState" value="0" hidden="true" checked>
<input type="checkbox" class="hide-toggle-rev" name="attr_egoSkill6Type" value="None" hidden="true" checked>
	<div class="hide-item-rev skillhide">
	<div class="rowContainer paletteButton skillSelectionElement" style="width: 100%;">

	<input id="select-egoSkill6" class="skillSelector" type="checkbox" name="attr_skillSelect" value="egoSkill6">
	<label for="select-egoSkill6" class="skillSelectionLabel" style="width: 100%;">
	<div class="skillWrap">

	<div style="position: relative;">
	<div class="blocker"></div>
	<input type="text" class="combatPaletteName skillSelectionName" name="attr_egoSkill6Name" data-i18n-placeholder="palette-egoskill6-name" placeholder="MYS Skill (6)">
	</div>

<div class="iconHolder egoSkills">
		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="" name="attr_egoSkill6Type"><div class="skillIcon skillNone"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Attack" name="attr_egoSkill6Type"><div class="skillIcon skillAtt"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Defend" name="attr_egoSkill6Type"><div class="type-image skillIcon skillDef"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Evade" name="attr_egoSkill6Type"><div class="type-image skillIcon skillEvd"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Action" name="attr_egoSkill6Type"><div class="type-image skillIcon skillAct"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Mass" name="attr_egoSkill6Type"><div class="type-image skillIcon skillMass"></div>
		</div>

	</div>

	</div>

	</label>
	</div>
	</div>
</div>
<!-- EGO Skill 6 block END -->

<!-- Skill 6 Palette -->
<div class="skillBuffer">
<input type="checkbox" class="hide-toggle-rev" name="attr_skill6Type" value="None" hidden="true" checked>
	<div class="hide-item-rev skillhide">
	<div class="rowContainer paletteButton skillSelectionElement" style="width: 100%;">

	<input id="select-skill6" class="skillSelector" type="checkbox" name="attr_skillSelect" value="skill6">
	<label for="select-skill6" class="skillSelectionLabel" style="width: 100%;">
	<div class="skillWrap">

	<div style="position: relative;">
	<div class="blocker"></div>
	<input type="text" class="combatPaletteName skillSelectionName" name="attr_skill6Name" data-i18n-placeholder="palette-skill6-name" placeholder="Skill (6)">
	</div>

<div class="iconHolder">
		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="" name="attr_skill6Type"><div class="skillIcon skillNone"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Attack" name="attr_skill6Type"><div class="skillIcon skillAtt weapon"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Defend" name="attr_skill6Type"><div class="type-image skillIcon skillDef outfit"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Evade" name="attr_skill6Type"><div class="type-image skillIcon skillEvd STGR"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Action" name="attr_skill6Type"><div class="type-image skillIcon skillAct tool"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Mass" name="attr_skill6Type"><div class="type-image skillIcon skillMass weapon"></div>
		</div>

	</div>

	</div>

	</label>
	</div>
	</div>
</div>
<!-- Skill 6 block END -->

    
</div>	</div> <!-- Skill palette END -->


<!-- Skill palette selection area (Distortion) -->

<input type="checkbox" class="hide-toggle" name="attr_distortState" value="true" hidden="true" checked>
<div class="hide-item" style="width: 100%;">

<div class="rowContainer centerFlex" style="width: 100%; flex-wrap: wrap; margin-top: 5px;">

<!-- EGO Skill 1 Palette -->
<div class="skillBuffer">
<input type="checkbox" class="hide-toggle-rev" name="attr_egoSkill1Type" value="None" hidden="true" checked>
	<div class="hide-item-rev skillhide">
	<div class="rowContainer paletteButton skillSelectionElement" style="width: 100%;">

	<input id="select-egoSkill1" class="skillSelector" type="checkbox" name="attr_skillSelect" value="egoSkill1">
	<label for="select-egoSkill1" class="skillSelectionLabel" style="width: 100%;">
	<div class="skillWrap">

	<div style="position: relative;">
	<div class="blocker"></div>
	<input type="text" class="combatPaletteName skillSelectionName" name="attr_egoSkill1Name" data-i18n-placeholder="palette-egoskill1-name" placeholder="MYS Skill (1)">
	</div>

<div class="iconHolder egoSkills">
		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="" name="attr_egoSkill1Type"><div class="skillIcon skillNone"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Attack" name="attr_egoSkill1Type"><div class="skillIcon skillAtt"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Defend" name="attr_egoSkill1Type"><div class="type-image skillIcon skillDef"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Evade" name="attr_egoSkill1Type"><div class="type-image skillIcon skillEvd"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Action" name="attr_egoSkill1Type"><div class="type-image skillIcon skillAct"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Mass" name="attr_egoSkill1Type"><div class="type-image skillIcon skillMass"></div>
		</div>

	</div>

	</div>

	</label>
	</div>
	</div>
</div>
<!-- EGO Skill 1 block END -->

<!-- Skill 1 Palette -->
<div class="skillBuffer">
<input type="checkbox" class="hide-toggle-rev" name="attr_skill1Type" value="None" hidden="true" checked>
	<div class="hide-item-rev skillhide">
	<div class="rowContainer paletteButton skillSelectionElement" style="width: 100%;">

	<input id="select-skill1" class="skillSelector" type="checkbox" name="attr_skillSelect" value="skill1">
	<label for="select-skill1" class="skillSelectionLabel" style="width: 100%;">
	<div class="skillWrap">

	<div style="position: relative;">
	<div class="blocker"></div>
	<input type="text" class="combatPaletteName skillSelectionName" name="attr_skill1Name" data-i18n-placeholder="palette-skill1-name" placeholder="Skill (1)">
	</div>


<div class="iconHolder">
		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="" name="attr_skill1Type"><div class="skillIcon skillNone"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Attack" name="attr_skill1Type"><div class="skillIcon skillAtt weapon"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Defend" name="attr_skill1Type"><div class="type-image skillIcon skillDef outfit"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Evade" name="attr_skill1Type"><div class="type-image skillIcon skillEvd STGR"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Action" name="attr_skill1Type"><div class="type-image skillIcon skillAct tool"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Mass" name="attr_skill1Type"><div class="type-image skillIcon skillMass weapon"></div>
		</div>

	</div>

	</div>

	</label>
	</div>
	</div>
</div>
<!-- Skill 1 block END -->

<!-- EGO Skill 2 Palette -->
<div class="skillBuffer">
<input type="checkbox" class="hide-toggle-rev" name="attr_egoSkill2Type" value="None" hidden="true" checked>
	<div class="hide-item-rev skillhide">
	<div class="rowContainer paletteButton skillSelectionElement" style="width: 100%;">

	<input id="select-egoSkill2" class="skillSelector" type="checkbox" name="attr_skillSelect" value="egoSkill2">
	<label for="select-egoSkill2" class="skillSelectionLabel" style="width: 100%;">
	<div class="skillWrap">

	<div style="position: relative;">
	<div class="blocker"></div>
	<input type="text" class="combatPaletteName skillSelectionName" name="attr_egoSkill2Name" data-i18n-placeholder="palette-egoskill2-name" placeholder="MYS Skill (2)">
	</div>

<div class="iconHolder egoSkills">
		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="" name="attr_egoSkill2Type"><div class="skillIcon skillNone"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Attack" name="attr_egoSkill2Type"><div class="skillIcon skillAtt"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Defend" name="attr_egoSkill2Type"><div class="type-image skillIcon skillDef"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Evade" name="attr_egoSkill2Type"><div class="type-image skillIcon skillEvd"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Action" name="attr_egoSkill2Type"><div class="type-image skillIcon skillAct"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Mass" name="attr_egoSkill2Type"><div class="type-image skillIcon skillMass"></div>
		</div>

	</div>

	</div>

	</label>
	</div>
	</div>
</div>
<!-- EGO Skill 2 block END -->

<!-- Skill 2 Palette -->
<div class="skillBuffer">
<input type="checkbox" class="hide-toggle-rev" name="attr_skill2Type" value="None" hidden="true" checked>
	<div class="hide-item-rev skillhide">
	<div class="rowContainer paletteButton skillSelectionElement" style="width: 100%;">

	<input id="select-skill2" class="skillSelector" type="checkbox" name="attr_skillSelect" value="skill2">
	<label for="select-skill2" class="skillSelectionLabel" style="width: 100%;">
	<div class="skillWrap">

	<div style="position: relative;">
	<div class="blocker"></div>
	<input type="text" class="combatPaletteName skillSelectionName" name="attr_skill2Name" data-i18n-placeholder="palette-skill2-name" placeholder="Skill (2)">
	</div>

<div class="iconHolder">
		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="" name="attr_skill2Type"><div class="skillIcon skillNone"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Attack" name="attr_skill2Type"><div class="skillIcon skillAtt weapon"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Defend" name="attr_skill2Type"><div class="type-image skillIcon skillDef outfit"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Evade" name="attr_skill2Type"><div class="type-image skillIcon skillEvd STGR"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Action" name="attr_skill2Type"><div class="type-image skillIcon skillAct tool"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Mass" name="attr_skill2Type"><div class="type-image skillIcon skillMass weapon"></div>
		</div>

	</div>

	</div>

	</label>
	</div>
	</div>
</div>
<!-- Skill 2 block END -->

<!-- EGO Skill 3 Palette -->
<div class="skillBuffer">
<input type="checkbox" class="hide-toggle-rev" name="attr_egoSkill3Type" value="None" hidden="true" checked>
	<div class="hide-item-rev skillhide">
	<div class="rowContainer paletteButton skillSelectionElement" style="width: 100%;">

	<input id="select-egoSkill3" class="skillSelector" type="checkbox" name="attr_skillSelect" value="egoSkill3">
	<label for="select-egoSkill3" class="skillSelectionLabel" style="width: 100%;">
	<div class="skillWrap">

	<div style="position: relative;">
	<div class="blocker"></div>
	<input type="text" class="combatPaletteName skillSelectionName" name="attr_egoSkill3Name" data-i18n-placeholder="palette-egoskill3-name" placeholder="MYS Skill (3)">
	</div>

<div class="iconHolder egoSkills">
		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="" name="attr_egoSkill3Type"><div class="skillIcon skillNone"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Attack" name="attr_egoSkill3Type"><div class="skillIcon skillAtt"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Defend" name="attr_egoSkill3Type"><div class="type-image skillIcon skillDef"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Evade" name="attr_egoSkill3Type"><div class="type-image skillIcon skillEvd"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Action" name="attr_egoSkill3Type"><div class="type-image skillIcon skillAct"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Mass" name="attr_egoSkill3Type"><div class="type-image skillIcon skillMass"></div>
		</div>

	</div>

	</div>

	</label>
	</div>
	</div>
</div>
<!-- EGO Skill 3 block END -->


<!-- Skill 3 Palette -->
<div class="skillBuffer">
<input type="checkbox" class="hide-toggle-rev" name="attr_skill3Type" value="None" hidden="true" checked>
	<div class="hide-item-rev skillhide">
	<div class="rowContainer paletteButton skillSelectionElement" style="width: 100%;">

	<input id="select-skill3" class="skillSelector" type="checkbox" name="attr_skillSelect" value="skill3">
	<label for="select-skill3" class="skillSelectionLabel" style="width: 100%;">
	<div class="skillWrap">

	<div style="position: relative;">
	<div class="blocker"></div>
	<input type="text" class="combatPaletteName skillSelectionName" name="attr_skill3Name" data-i18n-placeholder="palette-skill3-name" placeholder="Skill (3)">
	</div>

<div class="iconHolder">
		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="" name="attr_skill3Type"><div class="skillIcon skillNone"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Attack" name="attr_skill3Type"><div class="skillIcon skillAtt weapon"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Defend" name="attr_skill3Type"><div class="type-image skillIcon skillDef outfit"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Evade" name="attr_skill3Type"><div class="type-image skillIcon skillEvd STGR"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Action" name="attr_skill3Type"><div class="type-image skillIcon skillAct tool"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Mass" name="attr_skill3Type"><div class="type-image skillIcon skillMass weapon"></div>
		</div>

	</div>

	</div>

	</label>
	</div>
	</div>
</div>
<!-- Skill 3 block END -->

<!-- EGO Skill 4 Palette -->
<div class="skillBuffer">
<input type="checkbox" class="hide-toggle-rev" name="attr_egoSkill4Type" value="None" hidden="true" checked>
	<div class="hide-item-rev skillhide">
	<div class="rowContainer paletteButton skillSelectionElement" style="width: 100%;">

	<input id="select-egoSkill4" class="skillSelector" type="checkbox" name="attr_skillSelect" value="egoSkill4">
	<label for="select-egoSkill4" class="skillSelectionLabel" style="width: 100%;">
	<div class="skillWrap">

	<div style="position: relative;">
	<div class="blocker"></div>
	<input type="text" class="combatPaletteName skillSelectionName" name="attr_egoSkill4Name" data-i18n-placeholder="palette-egoskill4-name" placeholder="MYS Skill (4)">
	</div>

<div class="iconHolder egoSkills">
		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="" name="attr_egoSkill4Type"><div class="skillIcon skillNone"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Attack" name="attr_egoSkill4Type"><div class="skillIcon skillAtt"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Defend" name="attr_egoSkill4Type"><div class="type-image skillIcon skillDef"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Evade" name="attr_egoSkill4Type"><div class="type-image skillIcon skillEvd"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Action" name="attr_egoSkill4Type"><div class="type-image skillIcon skillAct"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Mass" name="attr_egoSkill4Type"><div class="type-image skillIcon skillMass"></div>
		</div>

	</div>

	</div>

	</label>
	</div>
	</div>
</div>
<!-- EGO Skill 4 block END -->

<!-- Skill 4 Palette -->
<div class="skillBuffer">
<input type="checkbox" class="hide-toggle-rev" name="attr_skill4Type" value="None" hidden="true" checked>
	<div class="hide-item-rev skillhide">
	<div class="rowContainer paletteButton skillSelectionElement" style="width: 100%;">

	<input id="select-skill4" class="skillSelector" type="checkbox" name="attr_skillSelect" value="skill4">
	<label for="select-skill4" class="skillSelectionLabel" style="width: 100%;">
	<div class="skillWrap">

	<div style="position: relative;">
	<div class="blocker"></div>
	<input type="text" class="combatPaletteName skillSelectionName" name="attr_skill4Name" data-i18n-placeholder="palette-skill4-name" placeholder="Skill (4)">
	</div>

<div class="iconHolder">
		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="" name="attr_skill4Type"><div class="skillIcon skillNone"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Attack" name="attr_skill4Type"><div class="skillIcon skillAtt weapon"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Defend" name="attr_skill4Type"><div class="type-image skillIcon skillDef outfit"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Evade" name="attr_skill4Type"><div class="type-image skillIcon skillEvd STGR"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Action" name="attr_skill4Type"><div class="type-image skillIcon skillAct tool"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Mass" name="attr_skill4Type"><div class="type-image skillIcon skillMass weapon"></div>
		</div>

	</div>

	</div>

	</label>
	</div>
	</div>
</div>
<!-- Skill 4 block END -->

<!-- EGO Skill 5 Palette -->
<div class="skillBuffer">
<input type="checkbox" class="hide-toggle-rev" name="attr_egoSkill5Type" value="None" hidden="true" checked>
	<div class="hide-item-rev skillhide">
	<div class="rowContainer paletteButton skillSelectionElement" style="width: 100%;">

	<input id="select-egoSkill5" class="skillSelector" type="checkbox" name="attr_skillSelect" value="egoSkill5">
	<label for="select-egoSkill5" class="skillSelectionLabel" style="width: 100%;">
	<div class="skillWrap">

	<div style="position: relative;">
	<div class="blocker"></div>
	<input type="text" class="combatPaletteName skillSelectionName" name="attr_egoSkill5Name" data-i18n-placeholder="palette-egoskill5-name" placeholder="MYS Skill (5)">
	</div>

<div class="iconHolder egoSkills">
		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="" name="attr_egoSkill5Type"><div class="skillIcon skillNone"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Attack" name="attr_egoSkill5Type"><div class="skillIcon skillAtt"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Defend" name="attr_egoSkill5Type"><div class="type-image skillIcon skillDef"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Evade" name="attr_egoSkill5Type"><div class="type-image skillIcon skillEvd"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Action" name="attr_egoSkill5Type"><div class="type-image skillIcon skillAct"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Mass" name="attr_egoSkill5Type"><div class="type-image skillIcon skillMass"></div>
		</div>

	</div>

	</div>

	</label>
	</div>
	</div>
</div>
<!-- EGO Skill 5 block END -->

<!-- Skill 5 Palette -->
<div class="skillBuffer">
<input type="checkbox" class="hide-toggle-rev" name="attr_skill5Type" value="None" hidden="true" checked>
	<div class="hide-item-rev skillhide">
	<div class="rowContainer paletteButton skillSelectionElement" style="width: 100%;">

	<input id="select-skill5" class="skillSelector" type="checkbox" name="attr_skillSelect" value="skill5">
	<label for="select-skill5" class="skillSelectionLabel" style="width: 100%;">
	<div class="skillWrap">

	<div style="position: relative;">
	<div class="blocker"></div>
	<input type="text" class="combatPaletteName skillSelectionName" name="attr_skill5Name" data-i18n-placeholder="palette-skill5-name" placeholder="Skill (5)">
	</div>

<div class="iconHolder">
		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="" name="attr_skill5Type"><div class="skillIcon skillNone"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Attack" name="attr_skill5Type"><div class="skillIcon skillAtt weapon"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Defend" name="attr_skill5Type"><div class="type-image skillIcon skillDef outfit"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Evade" name="attr_skill5Type"><div class="type-image skillIcon skillEvd STGR"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Action" name="attr_skill5Type"><div class="type-image skillIcon skillAct tool"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Mass" name="attr_skill5Type"><div class="type-image skillIcon skillMass weapon"></div>
		</div>

	</div>

	</div>

	</label>
	</div>
	</div>
</div>
<!-- Skill 5 block END -->

<!-- EGO Skill 6 Palette -->
<div class="skillBuffer">
<input type="checkbox" class="hide-toggle-rev" name="attr_egoSkill6Type" value="None" hidden="true" checked>
	<div class="hide-item-rev skillhide">
	<div class="rowContainer paletteButton skillSelectionElement" style="width: 100%;">

	<input id="select-egoSkill6" class="skillSelector" type="checkbox" name="attr_skillSelect" value="egoSkill6">
	<label for="select-egoSkill6" class="skillSelectionLabel" style="width: 100%;">
	<div class="skillWrap">

	<div style="position: relative;">
	<div class="blocker"></div>
	<input type="text" class="combatPaletteName skillSelectionName" name="attr_egoSkill6Name" data-i18n-placeholder="palette-egoskill6-name" placeholder="MYS Skill (6)">
	</div>

<div class="iconHolder egoSkills">
		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="" name="attr_egoSkill6Type"><div class="skillIcon skillNone"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Attack" name="attr_egoSkill6Type"><div class="skillIcon skillAtt"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Defend" name="attr_egoSkill6Type"><div class="type-image skillIcon skillDef"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Evade" name="attr_egoSkill6Type"><div class="type-image skillIcon skillEvd"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Action" name="attr_egoSkill6Type"><div class="type-image skillIcon skillAct"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Mass" name="attr_egoSkill6Type"><div class="type-image skillIcon skillMass"></div>
		</div>

	</div>

	</div>

	</label>
	</div>
	</div>
</div>
<!-- EGO Skill 6 block END -->

<!-- Skill 6 Palette -->
<div class="skillBuffer">
<input type="checkbox" class="hide-toggle-rev" name="attr_skill6Type" value="None" hidden="true" checked>
	<div class="hide-item-rev skillhide">
	<div class="rowContainer paletteButton skillSelectionElement" style="width: 100%;">

	<input id="select-skill6" class="skillSelector" type="checkbox" name="attr_skillSelect" value="skill6">
	<label for="select-skill6" class="skillSelectionLabel" style="width: 100%;">
	<div class="skillWrap">

	<div style="position: relative;">
	<div class="blocker"></div>
	<input type="text" class="combatPaletteName skillSelectionName" name="attr_skill6Name" data-i18n-placeholder="palette-skill6-name" placeholder="Skill (6)">
	</div>

<div class="iconHolder">
		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="" name="attr_skill6Type"><div class="skillIcon skillNone"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Attack" name="attr_skill6Type"><div class="skillIcon skillAtt weapon"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Defend" name="attr_skill6Type"><div class="type-image skillIcon skillDef outfit"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Evade" name="attr_skill6Type"><div class="type-image skillIcon skillEvd STGR"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Action" name="attr_skill6Type"><div class="type-image skillIcon skillAct tool"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Mass" name="attr_skill6Type"><div class="type-image skillIcon skillMass weapon"></div>
		</div>

	</div>

	</div>

	</label>
	</div>
	</div>
</div>
<!-- Skill 6 block END -->

    
</div>	</div> <!-- Skill palette END -->



	</div> <!-- Skill section end -->






<!-- Skill data viewer -->
<div class="rowContainer contentContainer centerFlex" style="width: 100%;">
<input class="text" name="attr_selectName" value="" hidden="true">
<input class="text" name="attr_selectType" value="" hidden="true">
<input class="text" name="attr_selectRank" value="0" hidden="true">
<input class="text" name="attr_selectLight" value="0" hidden="true">
<input class="text" name="attr_selectDescription" value="" hidden="true">
<input class="text" name="attr_selectEffect" value="" hidden="true">

<input class="text" name="attr_selectAtkDice1" value="0" hidden="true">
<input class="text" name="attr_selectAtkDice2" value="0" hidden="true">
<input class="text" name="attr_selectAtkDice3" value="0" hidden="true">

<input type="text" name="attr_selectDefDice1" value="0" hidden="true">
<input type="text" name="attr_selectDefDice2" value="0" hidden="true">
<input type="text" name="attr_selectDefDice3" value="0" hidden="true">

<input type="text" name="attr_selectEvdDice1" value="0" hidden="true">
<input type="text" name="attr_selectEvdDice2" value="0" hidden="true">
<input type="text" name="attr_selectEvdDice3" value="0" hidden="true">

<input type="text" name="attr_selectDice1" value="0" hidden="true">
<input type="text" name="attr_selectDice2" value="0" hidden="true">
<input type="text" name="attr_selectDice3" value="0" hidden="true">

<input type="checkbox" class="hide-toggle-rev" name="attr_skillSelect" value="0" checked>
<div class="hide-item-rev contentContainer darkBG" style="width: 100%;">

<div class="rowContainer sectionHeader" style="width: 100%">

<div style="position: absolute; left: 0px;" class="half">
<div class="blocker"></div>
<input type="text" class="transpInput viewerName" name="attr_selectName" data-i18n-placeholder="skill-name" placeholder="Skill name" value="" style="width: 100%;">
</div>

		<div class="rollFormatBlock whiteInput" data-i18n-title="skill-dice-text" title="Dice modifiers applied when using skill" style="position: absolute; right: 30px;">
<div class="blocker"></div>
		<input type="number" class="diceCount noSpinner" name="attr_selectDice1" min="1" value="1">
		<div class="plainText">D</div>
		<input type="number" class="diceMax noSpinner" name="attr_selectDice2" min="0" value="0">
		<div class="plainText">+</div>
		<input type="number" class="dicePower noSpinner" name="attr_selectDice3" value="0">
		</div>

<div class="lightCost" style="position: absolute; top: 2px; right: 0px;" data-i18n-title="skill-light-cost" title="Light Cost">
<div class="blocker"></div>
<input type="text" class="lightCostInput" style="margin: 0px !important; padding: 0px !important;" name="attr_selectLight">

</div>

	</div>


	<div class="rowContainer weaponInfo" style="overflow: hidden; border-radius: 3px;">

        <div class="weaponDescription">
       <textarea spellcheck="false"  name="attr_selectDescription" class="augmentDescriptionInput noHover" data-i18n-placeholder="skill-desc" placeholder="Skill description."></textarea>
        </div>

        <div class="weaponEffect">
	<textarea spellcheck="false"  name="attr_selectEffect" class="weaponEffectInput noHover" data-i18n-placeholder="skill-effect" placeholder="Skill effects."></textarea>
        </div> 

<div>
<input type="checkbox" class="hide-toggle" name="attr_selectCancel" value="true">
<div class="hide-item LIGHTtext" style="position: absolute; top: 0px; left: 0px; background-color: rgba(0,0,0,0.65); height: 100%; width: 100%; padding-top: 45px;">
<b data-i18n="viewer-light-warning">NOT ENOUGH LIGHT</b>
	</div>
	</div>

	</div>

	</div>
</div>
<!-- Skill data viewer END -->

</div> <!-- skill section REALLY end -->


            </div>
        </div>

</div>
</div>
</div>

<input type="hidden" class="sheet-tabstoggle" name="attr_sheetTab" value="equipment">
<div class="rowContainer toggleButtons">


<button type="action" id="exportButton" name="act_export" data-i18n="tabs-export">Export/Import</button>
<button type="action" id="detailsButton" name="act_details" data-i18n="tabs-character">Character Details</button>
<button type="action" id="equipmentButton" name="act_equipment" data-i18n="tabs-equipment">Equipment</button>
<button type="action" id="skillsButton" name="act_skills" data-i18n="tabs-skills">Skills</button>

<input type="checkbox" class="hide-toggle" name="attr_global_editMode" value="0" hidden="true" checked>
<button type="action" class="hide-item-rev" id="editButton" name="act_edit" style="position:relative;">
<span data-i18n="tabs-edit">Editor</span> 
</button>


</div>


<!-- Equipment section -->
<div class="sheet-body sheet-equipment darkBG">

<div class="rowContainer">
	<button type="action" class="darkButton" style="width: 100px;" name="act_testA">Test button A</button> <!-- For testing. Delete later -->
	<button type="action" class="darkButton" style="width: 100px;" name="act_testB">Test button B</button> <!-- For testing. Delete later -->
</div>
<textarea name="attr_itemList"></textarea> <!-- Revealed for testing purposes. Hide this later -->

<!-- Item Settings Section. Used for both Equipment and Skills! -->
<div class="contentContainer" id="itemSettings">
	<div style="width: 100%;">
		<h3 style="height: 27px;">

			<!-- Lock Button -->
			<input type="checkbox" class="switch-toggle" name="attr_syncLockItems" value="true" hidden="true">
			<button type="action" class="lockButton largeIcon" id="lock_Items" name="act_lockSection"></button>
			<div>
				<input type="checkbox" class="hide-toggle" name="attr_syncStateItems" value="true">
				<div class="hide-item containIcon"></div>
			</div>

			<!-- Search Bar -->
			<div class="searchBar">
				<label for="itemSearch" class="searchIcon centerIcon search"></label>

				<input type="text" id="itemSearch" class="searchInput" name="attr_itemSearchInput" data-i18n-title="item-search-title" title="Search for a term in an item's name, effect or description" data-i18n-placeholder="item-search" placeholder="Search for item">
				
				<button type="action" class="searchClear centerIcon exit" name="act_clearSearchBar" data-i18n-title="item-search-clear" title="Clear the search"></button>

				<!-- Advanced Search Button -->
				<input type="checkbox" class="switch-toggle" id="hideItemSearchOptions" name="attr_hideItemSearchOptions" value="true" hidden="true">
				<label for="hideItemSearchOptions" class="searchOptions centerIcon option" data-i18n-title="item-search-options" title="Advanced search options"></label>
			</div>
			
			<!-- Edit Button -->
			<input type="checkbox" class="switch-toggle" id="hideItemSettings" name="attr_hideItemSettings" value="true" hidden="true">
			<label for="hideItemSettings" class="inventoryEditButton largeIcon edit" data-i18n-title="item-edit" title="Edit items"></label>

		</h3>
	
		<!-- Advanced Search Menu -->
		<input type="checkbox" class="hide-toggle-rev" name="attr_hideItemSearchOptions" value="true" hidden="true" checked>
		<div class="hide-item-rev searchOptionsMenu">
			<!-- Add options here later in a similar style to Ruina -->
		</div>

	</div>
</div>

<!-- Damage multipliers. Used by repeating outfits -->
<datalist id="damageModList">
    <option data-i18n="outfit-res-none" value="" selected disabled hidden>---</option>
	<option data-i18n="outfit-res-fatal" value="2">[x2]Fatal</option>
	<option data-i18n="outfit-res-weak" value="1.5">[x1.5]Weak</option>
	<option data-i18n="outfit-res-normal" value="1">[x1]Normal</option>
	<option data-i18n="outfit-res-endured" value="0.5">[x0.5]Endured</option>
	<option data-i18n="outfit-res-ineffective" value="0.25">[x0.25]Ineffective</option>
	<option data-i18n="outfit-res-immune" value="0">[x0]Immune</option>
</datalist>

<div class="contentBlock" id="equipmentSection">


	

	<!-- Repeating inventory: Outfits -->
	<div class="inventorySection outfit" >
		
		<!-- Custom add repeating item button -->
		<div class="itemHeader repcontrol_header">
			<span class="itemName">Outfits</span>
			<button type="action" class="btn repcontrol_add" id="add_outfit" name="act_addItem" data-i18n-title="item-add" title="Add new item">Add</button>
		</div>

		<fieldset class="repeating_outfits">
			
			<!-- Option: Mystery -->
			<input type="checkbox" class="itemMystery" name="attr_optionMystery" value="true" hidden="true">
			<div class="itemContainer">
				
				<!-- Item controls -->
				<div class="itemButtons">
					<button type="action" class="darkInput shareButton share" name="act_share-item" data-i18n-title="share" title="Share info"></button>
					<button type="action" class="darkInput editButton edit" name="act_edit-item" data-i18n-title="edit" title="Edit"></button>
					<button type="action" class="darkInput autoScriptButton script" name="act_edit-autoscript" data-i18n-title="autoscript-edit" title="Edit AutoScript"></button>
					<input type="text" name="attr_autoScript" hidden="true">
				</div>

				<!-- Message overlay -->
				<div class="itemMessage">
					<textarea name="attr_messageText"></textarea>
				</div>


				<!-- Item contents (Left) -->
				<div class="itemContents rowContainer">
					<div class="itemRow left columnAlign">

						<!-- Header -->
						<div class="itemHeader">

							<!-- Equip checkbox -->
							<input type="checkbox" class="largeCheck equipCheck" name="attr_equipped" value="true">

							<!-- Rank and name -->
							<input type="text" class="itemRank" name="attr_rank" placeholder="0" data-i18n-title="rank" title="Rank">
							<input type="text" class="itemName transpInput" name="attr_name" data-i18n-placeholder="outfit-name" placeholder="Outfit name">
						</div>

						<!-- Option: Custom UI -->
						<div class="itemCustomUI">
							
							<!-- Option: Weapon UI -->
							<input type="checkbox" class="hide-toggle-next" name="attr_optionWeaponUI" value="true" hidden="true">
							<div class="hide-item itemWeaponUI">
								<select name="attr_rollDamageType0" class="darkInput">
									<option value="None" data-i18n="weapon-type-None">---</option>
									<option data-i18n="weapon-type-Slash" value="Slash">Slash</option>
									<option data-i18n="weapon-type-Pierce" value="Pierce">Pierce</option>
									<option data-i18n="weapon-type-Blunt" value="Blunt">Blunt</option>
								</select>
					
								<select name="attr_range" class="darkInput">
									<option value="None" data-i18n="weapon-type-None">---</option>
									<option data-i18n="weapon-type-Melee" value="Melee">Melee</option>
									<option data-i18n="weapon-type-Ranged" value="Ranged">Ranged</option>
								</select>
							</div>

							<!-- Option: Augment UI -->
							<input type="checkbox" class="hide-toggle-next" name="attr_optionAugmentUI" value="true" hidden="true">
							<div class="hide-item itemAugmentUI">
								<select name="attr_augmentType" class="darkInput">
									<option data-i18n="augment-type-None" value="None">---</option>
									<option data-i18n="augment-type-Tattoos" value="Tattoos">Tattoos</option>
									<option data-i18n="augment-type-Drugs" value="Drugs">Serums/Drugs</option>
									<option data-i18n="augment-type-Surgery" value="Surgery">Surgery</option>
									<option data-i18n="augment-type-Prosthesis" value="Prosthesis">Prosthesis</option>
									<option data-i18n="augment-type-FullProsthesis" value="FullProsthesis">Full Prosthesis</option>
									<option data-i18n="augment-type-Other" value="Other">Other</option>
								</select>
							</div>

							<!-- Option: Special UI -->
							<input type="checkbox" class="hide-toggle-next" name="attr_optionSpecialUI" value="true" hidden="true">
							<div class="hide-item itemSpecialUI">
								<span data-i18n="special-range-text">Effect Range</span>
								<select name="attr_specialRange" class="darkInput">
									<option data-i18n="special-range-none" value="none">---</option>
									<option data-i18n="special-range-0" value="0">One or two people</option>
									<option data-i18n="special-range-1" value="1">Street</option>
									<option data-i18n="special-range-2" value="2">Neighborhood</option>
									<option data-i18n="special-range-3" value="3">Residence Area</option>
									<option data-i18n="special-range-4" value="4">Nest</option>
									<option data-i18n="special-range-5" value="5">Multiple Nests</option>
									<option data-i18n="special-range-6" value="6">City</option>
								</select>

								<span data-i18n="special-duration-text">Duration</span>
								<select name="attr_specialDuration" class="darkInput">
									<option data-i18n="special-duration-none" value="none">---</option>
									<option data-i18n="special-duration-0" value="0">A moment</option>
									<option data-i18n="special-duration-1" value="1">Seconds</option>
									<option data-i18n="special-duration-2" value="2">Minutes</option>
									<option data-i18n="special-duration-3" value="3">Hours</option>
									<option data-i18n="special-duration-4" value="4">Days</option>
									<option data-i18n="special-duration-5" value="5">Weeks</option>
									<option data-i18n="special-duration-6" value="6">Months</option>
								</select>
							</div>
						</div>

						<!-- Option: Tags (Left) -->
						<input type="checkbox" class="hide-toggle-next" name="attr_optionTags" value="true" hidden="true">
						<div class="hide-item itemTags">
							<input type="checkbox" class="hide-toggle-rev" name="attr_optionTags" value="true" hidden="true">
							<input type="text" class="hide-item-rev" data-i18n-placeholder="item-tags-outfit" placeholder="Outfit tags">
						</div>

						<!-- Description (Left) -->
						<div class="itemDescription left">
							<textarea spellcheck="false" name="attr_description" class="itemDescription" data-i18n-placeholder="outfit-desc" placeholder="Outfit description."></textarea>
							<textarea spellcheck="false" name="attr_effect" class="itemEffect" data-i18n-placeholder="outfit-effect" placeholder="Outfit effects."></textarea>
						</div>
					</div>
					

					<!-- Item contents (Right) -->
					<div class="itemRow right columnAlign">
						
						<!-- Option: Rollformats -->
						<div class="itemRollFormats columnAlign">

							<!-- Rollformat (0) -->
							<input type="checkbox" class="hide-toggle-next" name="attr_rollDisplay0" value="true" hidden="true">
							<div class="hide-item rollFormat">

								<!-- Roll icon -->
								<img name="attr_rollIcon0" class="rollFormatIcon">
								<input type="text" name="attr_rollType0" hidden="true">
								<input type="text" name="attr_rollDamageType0" hidden="true">

								<!-- Roll format -->
								<div class="rollFormatBlock">
									<input type="number" class="diceCount noSpinner" name="attr_rollCount0" min="1" value="0">
									<div class="plainText">D</div>
									<input type="number" class="diceMax noSpinner" name="attr_rollMax0" value="10">
									<div class="plainText">+</div>
									<input type="number" class="dicePower noSpinner" name="attr_rollPower0" value="0">
								</div>

								<!-- Roll button -->
								<input type="checkbox" class="hide-toggle-next" name="attr_rollMode0" value="Roll" hidden="true">
								<button type="action" class="hide-item rollButton" name="act_itemRoll0"></button>
							</div>

							<!-- Rollformat (1) -->
							<input type="checkbox" class="hide-toggle-next" name="attr_rollDisplay1" value="true" hidden="true">
							<div class="hide-item rollFormat">

								<!-- Roll icon -->
								<img name="attr_rollIcon1" class="rollFormatIcon">
								<input type="text" name="attr_rollType1" hidden="true">
								<input type="text" name="attr_rollDamageType1" hidden="true">

								<!-- Roll format -->
								<div class="rollFormatBlock">
									<input type="number" class="diceCount noSpinner" name="attr_rollCount1" min="1" value="0">
									<div class="plainText">D</div>
									<input type="number" class="diceMax noSpinner" name="attr_rollMax1" value="12">
									<div class="plainText">+</div>
									<input type="number" class="dicePower noSpinner" name="attr_rollPower1" value="0">
								</div>

								<!-- Roll button -->
								<input type="checkbox" class="hide-toggle-next" name="attr_rollMode1" value="Roll" hidden="true">
								<button type="action" class="hide-item rollButton" name="act_itemRoll1"></button>
							</div>

							<!-- Rollformat (2) -->
							<input type="checkbox" class="hide-toggle-next" name="attr_rollDisplay2" value="true" hidden="true">
							<div class="hide-item rollFormat">

								<!-- Roll icon -->
								<img name="attr_rollIcon2" class="rollFormatIcon">
								<input type="text" name="attr_rollType2" hidden="true">
								<input type="text" name="attr_rollDamageType2" hidden="true">

								<!-- Roll format -->
								<div class="rollFormatBlock">
									<input type="number" class="diceCount noSpinner" name="attr_rollCount2" min="0" value="0">
									<div class="plainText">D</div>
									<input type="number" class="diceMax noSpinner" name="attr_rollMax2" value="0">
									<div class="plainText">+</div>
									<input type="number" class="dicePower noSpinner" name="attr_rollPower2" value="0">
								</div>

								<!-- Roll button -->
								<input type="checkbox" class="hide-toggle-next" name="attr_rollMode2" value="Roll" hidden="true">
								<button type="action" class="hide-item rollButton" name="act_itemRoll2"></button>
							</div>

							<!-- Rollformat (3) -->
							<input type="checkbox" class="hide-toggle-next" name="attr_rollDisplay3" value="true" hidden="true">
							<div class="hide-item rollFormat">

								<!-- Roll icon -->
								<img name="attr_rollIcon3" class="rollFormatIcon">
								<input type="text" name="attr_rollType3" hidden="true">
								<input type="text" name="attr_rollDamageType3" hidden="true">

								<!-- Roll format -->
								<div class="rollFormatBlock">
									<input type="number" class="diceCount noSpinner" name="attr_rollCount3" min="0" value="0">
									<div class="plainText">D</div>
									<input type="number" class="diceMax noSpinner" name="attr_rollMax3" value="0">
									<div class="plainText">+</div>
									<input type="number" class="dicePower noSpinner" name="attr_rollPower3" value="0">
								</div>

								<!-- Roll button -->
								<input type="checkbox" class="hide-toggle-next" name="attr_rollMode3" value="Roll" hidden="true">
								<button type="action" class="hide-item rollButton" name="act_itemRoll3"></button>
							</div>

							<!-- Rollformat (4) -->
							<input type="checkbox" class="hide-toggle-next" name="attr_rollDisplay4" value="true" hidden="true">
							<div class="hide-item rollFormat">

								<!-- Roll icon -->
								<img name="attr_rollIcon4" class="rollFormatIcon">
								<input type="text" name="attr_rollType4" hidden="true">
								<input type="text" name="attr_rollDamageType4" hidden="true">

								<!-- Roll format -->
								<div class="rollFormatBlock">
									<input type="number" class="diceCount noSpinner" name="attr_rollCount4" min="0" value="0">
									<div class="plainText">D</div>
									<input type="number" class="diceMax noSpinner" name="attr_rollMax4" value="0">
									<div class="plainText">+</div>
									<input type="number" class="dicePower noSpinner" name="attr_rollPower4" value="0">
								</div>

								<!-- Roll button -->
								<input type="checkbox" class="hide-toggle-next" name="attr_rollMode4" value="Roll" hidden="true">
								<button type="action" class="hide-item rollButton" name="act_itemRoll4"></button>
							</div>
						</div>

						<!-- Option: Resistances -->
						<div class="itemResist">

							<!-- Option: Damage resistances -->
							<div class="itemResistDamage">

								<!-- Slash -->
								<div class="rowContainer">
									<div class="mediumIcon slashNormal"></div>
									<input type="number" class="darkInput noSpinner" name="attr_slashBaseHP" list="damageModList" min="0" value="1">
									<input type="number" class="darkInput noSpinner" name="attr_slashBaseST" list="damageModList" min="0" value="1">
									<div class="mediumIcon slashNormalSTG"></div>
								</div>

								<!-- Pierce -->
								<div class="rowContainer">
									<div class="mediumIcon pierceNormal"></div>
									<input type="number" class="darkInput noSpinner" name="attr_pierceBaseHP" list="damageModList" min="0" value="1">
									<input type="number" class="darkInput noSpinner" name="attr_pierceBaseST" list="damageModList" min="0" value="1">
									<div class="mediumIcon pierceNormalSTG"></div>
								</div>

								<!-- Blunt -->
								<div class="rowContainer">
									<div class="mediumIcon bluntNormal"></div>
									<input type="number" class="darkInput noSpinner" name="attr_bluntBaseHP" list="damageModList" min="0" value="1">
									<input type="number" class="darkInput noSpinner" name="attr_bluntBaseST" list="damageModList" min="0" value="1">
									<div class="mediumIcon bluntNormalSTG"></div>
								</div>
							</div>
						</div>

						<!-- Option: Tags (Right) -->
						<input type="checkbox" class="hide-toggle-next" name="attr_optionTags" value="true" hidden="true">
						<div class="hide-item itemTags">
							<input type="checkbox" class="hide-toggle" name="attr_optionTags" value="true" hidden="true">
							<input type="text" class="hide-item" data-i18n-placeholder="item-tags-outfit" placeholder="Outfit tags">
						</div>

						<!-- Description (Right) -->
						<div class="itemDescription right">
							<textarea spellcheck="false" name="attr_description" class="itemDescription" data-i18n-placeholder="outfit-desc" placeholder="Outfit description."></textarea>
							<textarea spellcheck="false" name="attr_effect" class="itemEffect" data-i18n-placeholder="outfit-effect" placeholder="Outfit effects."></textarea>
						</div>
					</div>
				</div>

				<!-- Description (Bottom) -->
				<div class="itemDescription bottom">
					<textarea spellcheck="false" name="attr_description" class="itemDescription" data-i18n-placeholder="outfit-desc" placeholder="Outfit description."></textarea>
					<textarea spellcheck="false" name="attr_effect" class="itemEffect" data-i18n-placeholder="outfit-effect" placeholder="Outfit effects."></textarea>
				</div>
			</div>
		</fieldset>
	</div>



















<div class="weaponContainer">

<div class="contentContainer itemContainer weapon">
	<div class="contentHeader repcontrol_header">
		<span class="contentName">Weapons</span>

		<!-- Custom add repeating item button. The default one makes it difficult to set different default values for different item types -->
		<button type="action" class="btn repcontrol_add" id="add_weapon" name="act_addItem" data-i18n-title="item-add" title="Add new item">Add</button>
	</div>

	<!-- Repeating weapon block -->
	<fieldset class="repeating_weapons">
		<div class="contentContainer">
			
			<!-- Item controls -->
			<div class="itemButtons">
				<button type="action" class="darkInput shareButton share" name="act_share-item" data-i18n-title="share" title="Share info"></button>
				<button type="action" class="darkInput editButton edit" name="act_edit-item" data-i18n-title="edit" title="Edit"></button>
				<button type="action" class="darkInput autoScriptButton script" name="act_edit-autoscript" data-i18n-title="autoscript-edit" title="Edit AutoScript"></button>
				<input type="text" name="attr_autoScript" hidden="true">
				<input type="text" name="attr_itemData" hidden="true">
			</div>
	
			<!-- Weapon header -->
			<div class="contentHeader">
				<input type="checkbox" class="largeCheck equipCheck" name="attr_equipped" value="true">

				<input type="text" class="weaponRank" name="attr_rank" placeholder="0" data-i18n-title="rank" title="Rank">
				<input type="text" class="transpInput contentName" name="attr_name" data-i18n-placeholder="equip-weapon-name" placeholder="Weapon Name">
	
				<!-- Dice roll block -->
				<div class="rowContainer combatRoll">
	
					<!-- Uses indicator -->
					<div class="buffer" style="width: 30px; height: 30px;">
						<input type="checkbox" class="hide-toggle-rev" name="attr_useType" value="Limitless" hidden="true" checked>
						<div class="hide-item-rev rowContainer centerFlex" style="position: relative;">
		
							<input type="text" class="transpInput blocker" name="attr_uses" style="text-align: center; height: 100%;" value="5">
		
							<input type="checkbox" class="fade-toggle" name="attr_useType" value="Deplete" hidden="true">
							<div class="fade-item centerIcon reusable" style="width: 30px; height: 30px;"></div>
						</div>
					</div>

					<!-- Damage type icon -->
					<div class="weaponIcons">
						<div class="icon"><input type="checkbox" class="expand-toggle" value="Slash" name="attr_damageType"><div class="type-image typeIcon slash"></div></div>
						<div class="icon"><input type="checkbox" class="expand-toggle" value="Pierce" name="attr_damageType"><div class="type-image typeIcon pierce"></div></div>
						<div class="icon"><input type="checkbox" class="expand-toggle" value="Blunt" name="attr_damageType"><div class="type-image typeIcon blunt"></div></div>
					</div>
		
					<!-- Dice format -->
					<div class="rollFormatBlock">
						<input type="number" class="diceCount noSpinner" name="attr_dice1" min="1" value="1">
						<div class="plainText">D</div>
						<input type="number" class="diceMax noSpinner" name="attr_dice2" min="0" value="0">
						<div class="plainText">+</div>
						<input type="number" class="dicePower noSpinner" name="attr_dice3" value="0">
					</div>
		
					<!-- Roll button -->
					<button type="action" class="NDice" id="autoroll_raw" name="act_rollCombat"></button>
				</div>
				<!-- Dice roll end -->

			</div>
			<!-- Header end -->
	
			<!-- Weapon Edit -->
			<div>
				<input type="checkbox" class="hide-toggle" name="attr_settingEditMode" value="true">
				<div class="hide-item editCover">
					<div class="settingStyle">
						<div class="settingStyle" style="width: 60px;"><b data-i18n="message-uses">Uses</b>:	</div> 
						<input type="text" class="transpInput" style="width: 23px;" name="attr_uses" value="5"> / 
						<input type="number" class="darkInput" name="attr_uses_max" value="5" min="1">
	
						<select name="attr_useType" class="darkInput" style="width: 70px; margin-left: 5px;">
							<option data-i18n="uses-nolimit" value="Limitless" selected>No limit</option>
							<option data-i18n="uses-reload" value="Reload">Reload</option>
							<option data-i18n="uses-deplete" value="Deplete">Deplete</option>
						</select>
					</div>
				</div>
			</div>
			<!-- Weapon Edit end -->
	
			<!-- Weapon properties -->
			<div class="weaponPropertySelect weapon"> 
				<select name="attr_damageType" class="weapon_type darkInput">
					<option value="None" data-i18n="weapon-type-None">---</option>
					<option data-i18n="weapon-type-Slash" value="Slash">Slash</option>
					<option data-i18n="weapon-type-Pierce" value="Pierce">Pierce</option>
					<option data-i18n="weapon-type-Blunt" value="Blunt">Blunt</option>
				</select>
	
				<select name="attr_range" class="weapon_distance darkInput">
					<option value="None" data-i18n="weapon-type-None">---</option>
					<option data-i18n="weapon-type-Melee" value="Melee">Melee</option>
					<option data-i18n="weapon-type-Ranged" value="Ranged">Ranged</option>
				</select>
			</div>
	
			<!-- Description/Effect section -->
			<div class="rowContainer weaponInfo">
				<div class="weaponDescription">
					<div class="descHead"></div>
					<textarea spellcheck="false"  name="attr_description" class="weaponDescriptionInput" data-i18n-placeholder="weapon-desc" placeholder="Weapon description."></textarea>
				</div>
	
				<div class="weaponEffect">
					<textarea spellcheck="false"  name="attr_effect" class="weaponEffectInput" data-i18n-placeholder="weapon-effect" placeholder="Weapon effects."></textarea>
				</div>
			</div>
			<!-- desc end -->	


			<!-- Basics -->
			<div>
				Item type: <input type="text" class="" name="attr_type" placeholder="Item type">
				Minimized: <input type="checkbox" class="" name="attr_minimized" value="true">
			</div>
			
			<!-- Equip -->
			<div>
				Equipped: <input type="checkbox" class="" name="attr_equipped" value="true">
				<div>
					Opt. Equip Slots <input type="checkbox" class="" name="attr_optionEquipSlots" value="true">
					Slot Type: <input type="text" class="" name="attr_slotType" placeholder="Slot type">
					Slot Use: <input type="number" class="" name="attr_slotUse" placeholder="1">
				</div>
			</div>

			<!-- Rollformats -->
			<div>
				Opt. Rollformat <input type="checkbox" class="" name="attr_optionRollFormat" value="true">
				<div>
					Roll Type: <input type="text" class="" name="attr_rollType0" placeholder="Roll type"> <!-- Should maybe be a checkbox -->
					Roll Mode: <input type="text" class="" name="attr_rollMode0" placeholder="Roll mode"> <!-- Should maybe be a checkbox -->
					Roll Damage Type:  <input type="text" class="" name="attr_rollDamagetype0" placeholder="Roll damage type">
					Roll Count: <input type="number" class="" name="attr_rollCount0" placeholder="1">
					Roll Max: <input type="number" class="" name="attr_rollMax0" placeholder="1">
					Roll Power: <input type="number" class="" name="attr_rollPower0" placeholder="1">
					Roll Adv: <input type="text" class="" name="attr_rollAdv0" placeholder="Roll adv">
					<div>
						Opt. Resource: <input type="checkbox" class="" name="attr_optionRollResource0" value="true">
						<div>
							Opt. Action: <input type="checkbox" class="" name="attr_optionRollAction0" value="true">
							Roll Act Cost: <input type="number" class="" name="attr_rollActionCost0" placeholder="1">
							Roll Act Type: <input type="text" class="" name="attr_rollActionType0" placeholder="Act type">
						</div>
						<div>
							Opt. Reaction: <input type="checkbox" class="" name="attr_optionRollReaction0" value="true">
							Roll React Cost: <input type="number" class="" name="attr_rollReactionCost0" placeholder="1">
							Roll React Type: <input type="text" class="" name="attr_rollReactionType0" placeholder="React type">
						</div>
					</div>
					<div>
						Opt. Store: <input type="checkbox" class="" name="attr_optionStoreRoll0" value="true">
						Store Count: <input type="number" class="" name="attr_storeCount0" placeholder="0">
						Store Max: <input type="number" class="" name="attr_storeMax0" placeholder="0">
						Store Power: <input type="number" class="" name="attr_storePower0" placeholder="0">
						Store Adv: <input type="text" class="" name="attr_storeAdv0" placeholder="Store adv">
					</div>
					Roll AutoScript: <input type="text" class="" name="attr_rollAutoScript0" placeholder="Roll AutoScript">
				</div>
			</div>

			<!-- Linked -->
			<div>
				Opt. Linked <input type="checkbox" class="" name="attr_optionLinked" value="true">
				Linked ID: <input type="text" class="" name="attr_linkedId" placeholder="Linked id">
				Equip Together: <input type="checkbox" class="" name="attr_linkedEquipTogether" value="true">
			</div>

			<!-- Limited uses -->
			<div>
				Opt. Limited <input type="checkbox" class="" name="attr_optionLimited" value="true">
				<div>
					Opt. Uses <input type="checkbox" class="" name="attr_optionUses" value="true">
					Uses Type: <input type="text" class="" name="attr_usesType" placeholder="Uses type">
					Uses Mode: <input type="text" class="" name="attr_usesMode" placeholder="Uses mode">
					Uses Max: <input type="number" class="" name="attr_usesMax" placeholder="1">
					Uses Current: <input type="number" class="" name="attr_usesCurrent" placeholder="1">
					<div>
						Opt. Resource <input type="checkbox" class="" name="attr_optionUsesResource" value="true">
						<div>
							Opt. Action: <input type="checkbox" class="" name="attr_optionUseAction0" value="true">
							Use Act Cost: <input type="number" class="" name="attr_useActionCost0" placeholder="1">
							Use Act Type: <input type="text" class="" name="attr_useActionType0" placeholder="Act type">
						</div>
						<div>
							Opt. Reaction: <input type="checkbox" class="" name="attr_optionUsesReaction0" value="true">
							Use React Cost: <input type="number" class="" name="attr_useReactionCost0" placeholder="1">
							Use React Type: <input type="text" class="" name="attr_useReactionType0" placeholder="React type">
						</div>
					</div>
				</div>
				<div>
					Opt. Light Cost <input type="checkbox" class="" name="attr_optionLightCost" value="true">
					Light Cost: <input type="number" class="" name="attr_lightCost" placeholder="1">
				</div>
			</div>
			
			<!-- Resistances -->
			<div>
				Opt. Resistance <input type="checkbox" class="" name="attr_optionResist" value="true">
				<div>
					Damage Resistance <input type="checkbox" class="" name="attr_optionResistBaseDamage" value="true">
					<div>
						Slash Mode: <input type="text" class="" name="attr_slashBaseMode" placeholder="Slash mode">
						Slash HP Base: <input type="number" class="" name="attr_slashBaseHP" placeholder="1">
						Slash ST Base: <input type="number" class="" name="attr_slashBaseST" placeholder="1">
						Slash Mode: <input type="text" class="" name="attr_slashFlatMode" placeholder="Slash mode">
						Slash HP Flat: <input type="number" class="" name="attr_slashFlatHP" placeholder="1">
						Slash ST Flat: <input type="number" class="" name="attr_slashFlatST" placeholder="1">
					</div>
					<div>
						Pierce Mode: <input type="text" class="" name="attr_pierceBaseMode" placeholder="Pierce mode">
						Pierce HP Base: <input type="number" class="" name="attr_pierceBaseHP" placeholder="1">
						Pierce ST Base: <input type="number" class="" name="attr_pierceBaseST" placeholder="1">
						Pierce Mode: <input type="text" class="" name="attr_pierceFlatMode" placeholder="Pierce mode">
						Pierce HP Flat: <input type="number" class="" name="attr_pierceFlatHP" placeholder="1">
						Pierce ST Flat: <input type="number" class="" name="attr_pierceFlatST" placeholder="1">
					</div>
					<div>
						Blunt Mode: <input type="text" class="" name="attr_bluntBaseMode" placeholder="Blunt mode">
						Blunt HP Base: <input type="number" class="" name="attr_bluntBaseHP" placeholder="1">
						Blunt ST Base: <input type="number" class="" name="attr_bluntBaseST" placeholder="1">
						Blunt Mode: <input type="text" class="" name="attr_bluntFlatMode" placeholder="Blunt mode">
						Blunt HP Flat: <input type="number" class="" name="attr_bluntFlatHP" placeholder="1">
						Blunt ST Flat: <input type="number" class="" name="attr_bluntFlatST" placeholder="1">
					</div>
				</div>
				<div>
					Ailment Resistance <input type="checkbox" class="" name="attr_optionResistFlatDamage" value="true">
					<div>
						Bleed Res.: <input type="number" class="" name="attr_BleedResist" placeholder="0">
						Burn Res.: <input type="number" class="" name="attr_BurnResist" placeholder="0">
					</div>
					<!-- Custom resistances only appear in the editor -->
				</div>
			</div>
			
			<!-- Mystery -->
			<div>
				Opt. Mystery <input type="checkbox" class="" name="attr_optionMystery" value="true">
				Mystery Activation: <input type="text" class="" name="attr_mysteryActivation" placeholder="Mystery activation">
			</div>

			<!-- Tags -->
			<div>
				Opt. Tags <input type="checkbox" class="" name="attr_optionTags" value="true">
				<!-- Tags require a similar solution to Custom resistances -->
			</div>
	
			<!-- Styling -->
			<div>
				Opt. Style <input type="checkbox" class="" name="attr_optionCustomStyle" value="true">
				<div>
					Opt. Icon <input type="checkbox" class="" name="attr_optionIcon" value="true">
					Icon Source: <input type="text" class="" name="attr_iconSource" placeholder="Icon source">
				</div>
				Color: <input type="text" class="" name="attr_color" placeholder="Color">
				Accent: <input type="text" class="" name="attr_accent" placeholder="Accent">
			</div>

			<!-- UI elements -->
			<div>
				Opt. UI <input type="checkbox" class="" name="attr_optionCustomUI" value="true">
				Damagetype UI <input type="checkbox" class="" name="attr_damageTypeUI" value="true">
				Range UI: <input type="checkbox" class="" name="attr_rangeUI" value="true">
				Special UI: <input type="checkbox" class="" name="attr_specialUI" value="true">
				Half UI: <input type="checkbox" class="" name="attr_halfUI" value="true">
			</div>

			<!-- Card -->
			<div>
				Opt. Card <input type="checkbox" class="" name="attr_optionCardCombat" value="true">
			</div>

		</div>
		
	</fieldset>
	</div>
	<!-- Repeating weapon block END -->





	<!-- Weapon1 block -->
	<div class="contentContainer">
		<div class="itemButtons">
			<button type="action" class="darkInput shareButton share" id="share_weapon1" name="act_shareWeapon" data-i18n-title="share" title="Share info"></button>
			<button type="action" class="darkInput editButton edit" name="act_editMode" data-i18n-title="edit" title="Edit"></button>
			<button type="action" class="darkInput autoScriptButton script" id="weapon1AutoScript" name="act_autoScriptEdit" data-i18n-title="autoscript-edit" title="Edit AutoScript"></button>
			<input type="text" name="attr_weapon1AutoScript" hidden="true">
		</div>

		<!-- Weapon 1 header -->
		<div class="contentHeader weapon">
			<input type="text" class="weaponRank" name="attr_weapon1Rank" placeholder="0" data-i18n-title="rank" title="Rank">
			<input type="text" class="transpInput contentName" name="attr_weapon1Name" data-i18n-placeholder="equip-weapon1-name" placeholder="Weapon Name (1)">

			<!-- Weapon dice roll block -->
			<div class="rowContainer combatRoll">

			<!-- Weapon1 Uses indicator -->
			<div class="buffer" style="width: 30px; height: 30px;">
				<input type="checkbox" class="hide-toggle-rev" name="attr_weapon1UseType" value="Limitless" hidden="true" checked>
				<div class="hide-item-rev rowContainer centerFlex" style="position: relative;">

					<input type="text" class="transpInput blocker" name="attr_weapon1Uses" style="text-align: center; height: 100%;" value="5">

					<input type="checkbox" class="fade-toggle" name="attr_weapon1UseType" value="Deplete" hidden="true">
					<div class="fade-item centerIcon reusable" style="width: 30px; height: 30px;"></div>  
				</div>
			</div>
			<!-- Weapon1 Uses indicator END -->

			<div class="weaponIcons">
				<div class="icon">
					<input type="checkbox" class="expand-toggle" value="Slash" name="attr_weapon1Type"><div class="type-image typeIcon slash"></div>
				</div>

				<div class="icon">
					<input type="checkbox" class="expand-toggle" value="Pierce" name="attr_weapon1Type"><div class="type-image typeIcon pierce"></div>
				</div>

				<div class="icon">
					<input type="checkbox" class="expand-toggle" value="Blunt" name="attr_weapon1Type"><div class="type-image typeIcon blunt"></div>
				</div>
			</div>

			<div class="rollFormatBlock">
				<input type="number" class="diceCount noSpinner" name="attr_weapon1Dice1" min="1" value="1">
				<div class="plainText">D</div>
				<input type="number" class="diceMax noSpinner" name="attr_weapon1Dice2" min="0" value="0">
				<div class="plainText">+</div>
				<input type="number" class="dicePower noSpinner" name="attr_weapon1Dice3" value="0">
			</div>

			<button type="action" class="NDice" id="autoroll_weapon1_raw" name="act_rollCombat"></button>
			<!-- dice roll end -->

		</div></div>
		<!-- header end -->

		<!-- Weapon1 Edit-->
		<div>
			<input type="checkbox" class="hide-toggle" name="attr_settingEditMode" value="true">
			<div class="hide-item editCover">
				<div class="settingStyle">
					<div class="settingStyle" style="width: 60px;"><b data-i18n="message-uses">Uses</b>:	</div> 
					<input type="text" class="transpInput" style="width: 23px;" name="attr_weapon1Uses" value="5"> / 
					<input type="number" class="darkInput" name="attr_weapon1Uses_max" value="5" min="1">

					<select name="attr_weapon1UseType" class="darkInput" style="width: 70px; margin-left: 5px;">
						<option data-i18n="uses-nolimit" value="Limitless" selected>No limit</option>
						<option data-i18n="uses-reload" value="Reload">Reload</option>
						<option data-i18n="uses-deplete" value="Deplete">Deplete</option>
					</select>
				</div>
			</div>
		</div>
		<!-- Weapon1 Edit end -->

		<div class="weaponPropertySelect weapon"> 
			<select name="attr_weapon1Type" class="weapon_type darkInput">
				<option value="None" data-i18n="weapon-type-None">---</option>
				<option data-i18n="weapon-type-Slash" value="Slash">Slash</option>
				<option data-i18n="weapon-type-Pierce" value="Pierce">Pierce</option>
				<option data-i18n="weapon-type-Blunt" value="Blunt">Blunt</option>
			</select>

			<select name="attr_weapon1Range" class="weapon_distance darkInput">
				<option value="None" data-i18n="weapon-type-None">---</option>
				<option data-i18n="weapon-type-Melee" value="Melee">Melee</option>
				<option data-i18n="weapon-type-Ranged" value="Ranged">Ranged</option>
			</select>
		</div>

		<!-- Description/Effect section -->
		<div class="rowContainer weaponInfo">
			<div class="weaponDescription">
				<div class="descHead"></div>
				<textarea spellcheck="false"  name="attr_weapon1Description" class="weaponDescriptionInput" data-i18n-placeholder="weapon-desc" placeholder="Weapon description."></textarea>
			</div>

			<div class="weaponEffect">
				<textarea spellcheck="false"  name="attr_weapon1Effect" class="weaponEffectInput" data-i18n-placeholder="weapon-effect" placeholder="Weapon effects."></textarea>
			</div>
		</div>
		<!-- desc end -->	

	</div>
	<!-- Weapon 1 Block END -->


	<!-- Weapon2 block -->
	<div class="contentContainer">
		<div class="itemButtons">
			<button type="action" class="darkInput shareButton share" id="share_weapon2" name="act_shareWeapon" data-i18n-title="share" title="Share info"></button>
			<button type="action" class="darkInput editButton edit" name="act_editMode" data-i18n-title="edit" title="Edit"></button>
			<button type="action" class="darkInput autoScriptButton script" id="weapon2AutoScript" name="act_autoScriptEdit" data-i18n-title="autoscript-edit" title="Edit AutoScript"></button>
			<input type="text" name="attr_weapon2AutoScript" hidden="true">
		</div>

		<!-- Weapon 2 header -->
		<div class="contentHeader weapon">
			<input type="text" class="weaponRank" name="attr_weapon2Rank" placeholder="0" data-i18n-title="rank" title="Rank">
			<input type="text" class="transpInput contentName" name="attr_weapon2Name" data-i18n-placeholder="equip-weapon2-name" placeholder="Weapon Name (2)">

			<!-- Weapon dice roll block -->
			<div class="rowContainer combatRoll">

			<!-- Weapon2 Uses indicator -->
			<div class="buffer" style="width: 30px; height: 30px;">
				<input type="checkbox" class="hide-toggle-rev" name="attr_weapon2UseType" value="Limitless" hidden="true" checked>
				<div class="hide-item-rev rowContainer centerFlex" style="position: relative;">

					<input type="text" class="transpInput blocker" name="attr_weapon2Uses" style="text-align: center; height: 100%;" value="5">

					<input type="checkbox" class="fade-toggle" name="attr_weapon2UseType" value="Deplete" hidden="true">
					<div class="fade-item centerIcon reusable" style="width: 30px; height: 30px;"></div>  
				</div>
			</div>
			<!-- Weapon2 Uses indicator END -->

			<div class="weaponIcons">
				<div class="icon">
					<input type="checkbox" class="expand-toggle" value="Slash" name="attr_weapon2Type"><div class="type-image typeIcon slash"></div>
				</div>

				<div class="icon">
					<input type="checkbox" class="expand-toggle" value="Pierce" name="attr_weapon2Type"><div class="type-image typeIcon pierce"></div>
				</div>

				<div class="icon">
					<input type="checkbox" class="expand-toggle" value="Blunt" name="attr_weapon2Type"><div class="type-image typeIcon blunt"></div>
				</div>
			</div>

			<div class="rollFormatBlock">
				<input type="number" class="diceCount noSpinner" name="attr_weapon2Dice1" min="1" value="1">
				<div class="plainText">D</div>
				<input type="number" class="diceMax noSpinner" name="attr_weapon2Dice2" min="0" value="0">
				<div class="plainText">+</div>
				<input type="number" class="dicePower noSpinner" name="attr_weapon2Dice3" value="0">
			</div>

			<button type="action" class="NDice" id="autoroll_weapon2_raw" name="act_rollCombat"></button>
			<!-- dice roll end -->

		</div></div>
		<!-- header end -->

		<!-- Weapon2 Edit-->
		<div>
			<input type="checkbox" class="hide-toggle" name="attr_settingEditMode" value="true">
			<div class="hide-item editCover">
				<div class="settingStyle">
					<div class="settingStyle" style="width: 60px;"><b data-i18n="message-uses">Uses</b>:	</div> 
					<input type="text" class="transpInput" style="width: 23px;" name="attr_weapon2Uses" value="5"> / 
					<input type="number" class="darkInput" name="attr_weapon2Uses_max" value="5" min="1">

					<select name="attr_weapon2UseType" class="darkInput" style="width: 70px; margin-left: 5px;">
						<option data-i18n="uses-nolimit" value="Limitless" selected>No limit</option>
						<option data-i18n="uses-reload" value="Reload">Reload</option>
						<option data-i18n="uses-deplete" value="Deplete">Deplete</option>
					</select>
				</div>
			</div>
		</div>
		<!-- Weapon2 Edit end -->

		<div class="weaponPropertySelect weapon"> 
			<select name="attr_weapon2Type" class="weapon_type darkInput">
				<option value="None" data-i18n="weapon-type-None">---</option>
				<option data-i18n="weapon-type-Slash" value="Slash">Slash</option>
				<option data-i18n="weapon-type-Pierce" value="Pierce">Pierce</option>
				<option data-i18n="weapon-type-Blunt" value="Blunt">Blunt</option>
			</select>

			<select name="attr_weapon2Range" class="weapon_distance darkInput">
				<option value="None" data-i18n="weapon-type-None">---</option>
				<option data-i18n="weapon-type-Melee" value="Melee">Melee</option>
				<option data-i18n="weapon-type-Ranged" value="Ranged">Ranged</option>
			</select>
		</div>

		<!-- Description/Effect section -->
		<div class="rowContainer weaponInfo">
			<div class="weaponDescription">
				<div class="descHead"></div>
				<textarea spellcheck="false"  name="attr_weapon2Description" class="weaponDescriptionInput" data-i18n-placeholder="weapon-desc" placeholder="Weapon description."></textarea>
			</div>

			<div class="weaponEffect">
				<textarea spellcheck="false"  name="attr_weapon2Effect" class="weaponEffectInput" data-i18n-placeholder="weapon-effect" placeholder="Weapon effects."></textarea>
			</div>
		</div>
		<!-- desc end -->	

	</div>
	<!-- Weapon 2 Block END -->

<!-- !!EXTRA!! Weapons area -->
<input type="checkbox" class="hide-toggle" name="attr_settingExtraEquip" value="true">
<div class="hide-item">

	<!-- Weapon3 block -->
	<div class="contentContainer">
		<div class="itemButtons">
			<button type="action" class="darkInput shareButton share" id="share_weapon3" name="act_shareWeapon" data-i18n-title="share" title="Share info"></button>
			<button type="action" class="darkInput editButton edit" name="act_editMode" data-i18n-title="edit" title="Edit"></button>
			<button type="action" class="darkInput autoScriptButton script" id="weapon3AutoScript" name="act_autoScriptEdit" data-i18n-title="autoscript-edit" title="Edit AutoScript"></button>
			<input type="text" name="attr_weapon3AutoScript" hidden="true">
		</div>

		<!-- Weapon 3 header -->
		<div class="contentHeader weapon">
			<input type="text" class="weaponRank" name="attr_weapon3Rank" placeholder="0" data-i18n-title="rank" title="Rank">
			<input type="text" class="transpInput contentName" name="attr_weapon3Name" data-i18n-placeholder="equip-weapon3-name" placeholder="Weapon Name (3)">

			<!-- Weapon dice roll block -->
			<div class="rowContainer combatRoll">

			<!-- Weapon3 Uses indicator -->
			<div class="buffer" style="width: 30px; height: 30px;">
				<input type="checkbox" class="hide-toggle-rev" name="attr_weapon3UseType" value="Limitless" hidden="true" checked>
				<div class="hide-item-rev rowContainer centerFlex" style="position: relative;">

					<input type="text" class="transpInput blocker" name="attr_weapon3Uses" style="text-align: center; height: 100%;" value="5">

					<input type="checkbox" class="fade-toggle" name="attr_weapon3UseType" value="Deplete" hidden="true">
					<div class="fade-item centerIcon reusable" style="width: 30px; height: 30px;"></div>  
				</div>
			</div>
			<!-- Weapon3 Uses indicator END -->

			<div class="weaponIcons">
				<div class="icon">
					<input type="checkbox" class="expand-toggle" value="Slash" name="attr_weapon3Type"><div class="type-image typeIcon slash"></div>
				</div>

				<div class="icon">
					<input type="checkbox" class="expand-toggle" value="Pierce" name="attr_weapon3Type"><div class="type-image typeIcon pierce"></div>
				</div>

				<div class="icon">
					<input type="checkbox" class="expand-toggle" value="Blunt" name="attr_weapon3Type"><div class="type-image typeIcon blunt"></div>
				</div>
			</div>

			<div class="rollFormatBlock">
				<input type="number" class="diceCount noSpinner" name="attr_weapon3Dice1" min="1" value="1">
				<div class="plainText">D</div>
				<input type="number" class="diceMax noSpinner" name="attr_weapon3Dice2" min="0" value="0">
				<div class="plainText">+</div>
				<input type="number" class="dicePower noSpinner" name="attr_weapon3Dice3" value="0">
			</div>

			<button type="action" class="NDice" id="autoroll_weapon3_raw" name="act_rollCombat"></button>
			<!-- dice roll end -->

		</div></div>
		<!-- header end -->

		<!-- Weapon3 Edit-->
		<div>
			<input type="checkbox" class="hide-toggle" name="attr_settingEditMode" value="true">
			<div class="hide-item editCover">
				<div class="settingStyle">
					<div class="settingStyle" style="width: 60px;"><b data-i18n="message-uses">Uses</b>:	</div> 
					<input type="text" class="transpInput" style="width: 23px;" name="attr_weapon3Uses" value="5"> / 
					<input type="number" class="darkInput" name="attr_weapon3Uses_max" value="5" min="1">

					<select name="attr_weapon3UseType" class="darkInput" style="width: 70px; margin-left: 5px;">
						<option data-i18n="uses-nolimit" value="Limitless" selected>No limit</option>
						<option data-i18n="uses-reload" value="Reload">Reload</option>
						<option data-i18n="uses-deplete" value="Deplete">Deplete</option>
					</select>
				</div>
			</div>
		</div>
		<!-- Weapon3 Edit end -->

		<div class="weaponPropertySelect weapon"> 
			<select name="attr_weapon3Type" class="weapon_type darkInput">
				<option value="None" data-i18n="weapon-type-None">---</option>
				<option data-i18n="weapon-type-Slash" value="Slash">Slash</option>
				<option data-i18n="weapon-type-Pierce" value="Pierce">Pierce</option>
				<option data-i18n="weapon-type-Blunt" value="Blunt">Blunt</option>
			</select>

			<select name="attr_weapon3Range" class="weapon_distance darkInput">
				<option value="None" data-i18n="weapon-type-None">---</option>
				<option data-i18n="weapon-type-Melee" value="Melee">Melee</option>
				<option data-i18n="weapon-type-Ranged" value="Ranged">Ranged</option>
			</select>
		</div>

		<!-- Description/Effect section -->
		<div class="rowContainer weaponInfo">
			<div class="weaponDescription">
				<div class="descHead"></div>
				<textarea spellcheck="false"  name="attr_weapon3Description" class="weaponDescriptionInput" data-i18n-placeholder="weapon-desc" placeholder="Weapon description."></textarea>
			</div>

			<div class="weaponEffect">
				<textarea spellcheck="false"  name="attr_weapon3Effect" class="weaponEffectInput" data-i18n-placeholder="weapon-effect" placeholder="Weapon effects."></textarea>
			</div>
		</div>
		<!-- desc end -->	

	</div>
	<!-- Weapon 3 Block END -->


	<!-- Weapon4 block -->
	<div class="contentContainer">

		<div class="itemButtons">
			<button type="action" class="darkInput shareButton share" id="share_weapon4" name="act_shareWeapon" data-i18n-title="share" title="Share info"></button>
			<button type="action" class="darkInput editButton edit" name="act_editMode" data-i18n-title="edit" title="Edit"></button>
			<button type="action" class="darkInput autoScriptButton script" id="weapon4AutoScript" name="act_autoScriptEdit" data-i18n-title="autoscript-edit" title="Edit AutoScript"></button>
			<input type="text" name="attr_weapon4AutoScript" hidden="true">
		</div>

		<!-- Weapon 4 header -->
		<div class="contentHeader weapon">
			<input type="text" class="weaponRank" name="attr_weapon4Rank" placeholder="0" data-i18n-title="rank" title="Rank">
			<input type="text" class="transpInput contentName" name="attr_weapon4Name" data-i18n-placeholder="equip-weapon4-name" placeholder="Weapon Name (4)">

			<!-- Weapon dice roll block -->
			<div class="rowContainer combatRoll">

			<!-- Weapon4 Uses indicator -->
			<div class="buffer" style="width: 30px; height: 30px;">
				<input type="checkbox" class="hide-toggle-rev" name="attr_weapon4UseType" value="Limitless" hidden="true" checked>
				<div class="hide-item-rev rowContainer centerFlex" style="position: relative;">

					<input type="text" class="transpInput blocker" name="attr_weapon4Uses" style="text-align: center; height: 100%;" value="5">

					<input type="checkbox" class="fade-toggle" name="attr_weapon4UseType" value="Deplete" hidden="true">
					<div class="fade-item centerIcon reusable" style="width: 30px; height: 30px;"></div>  
				</div>
			</div>
			<!-- Weapon4 Uses indicator END -->

			<div class="weaponIcons">
				<div class="icon">
					<input type="checkbox" class="expand-toggle" value="Slash" name="attr_weapon4Type"><div class="type-image typeIcon slash"></div>
				</div>

				<div class="icon">
					<input type="checkbox" class="expand-toggle" value="Pierce" name="attr_weapon4Type"><div class="type-image typeIcon pierce"></div>
				</div>

				<div class="icon">
					<input type="checkbox" class="expand-toggle" value="Blunt" name="attr_weapon4Type"><div class="type-image typeIcon blunt"></div>
				</div>
			</div>

			<div class="rollFormatBlock">
				<input type="number" class="diceCount noSpinner" name="attr_weapon4Dice1" min="1" value="1">
				<div class="plainText">D</div>
				<input type="number" class="diceMax noSpinner" name="attr_weapon4Dice2" min="0" value="0">
				<div class="plainText">+</div>
				<input type="number" class="dicePower noSpinner" name="attr_weapon4Dice3" value="0">
			</div>

			<button type="action" class="NDice" id="autoroll_weapon4_raw" name="act_rollCombat"></button>
			<!-- dice roll end -->

		</div></div>
		<!-- header end -->

		<!-- Weapon4 Edit-->
		<div>
			<input type="checkbox" class="hide-toggle" name="attr_settingEditMode" value="true">
			<div class="hide-item editCover">
				<div class="settingStyle">
					<div class="settingStyle" style="width: 60px;"><b data-i18n="message-uses">Uses</b>:	</div> 
					<input type="text" class="transpInput" style="width: 23px;" name="attr_weapon4Uses" value="5"> / 
					<input type="number" class="darkInput" name="attr_weapon4Uses_max" value="5" min="1">

					<select name="attr_weapon4UseType" class="darkInput" style="width: 70px; margin-left: 5px;">
						<option data-i18n="uses-nolimit" value="Limitless" selected>No limit</option>
						<option data-i18n="uses-reload" value="Reload">Reload</option>
						<option data-i18n="uses-deplete" value="Deplete">Deplete</option>
					</select>
				</div>
			</div>
		</div>
		<!-- Weapon4 Edit end -->

		<div class="weaponPropertySelect weapon"> 
			<select name="attr_weapon4Type" class="weapon_type darkInput">
				<option value="None" data-i18n="weapon-type-None">---</option>
				<option data-i18n="weapon-type-Slash" value="Slash">Slash</option>
				<option data-i18n="weapon-type-Pierce" value="Pierce">Pierce</option>
				<option data-i18n="weapon-type-Blunt" value="Blunt">Blunt</option>
			</select>

			<select name="attr_weapon4Range" class="weapon_distance darkInput">
				<option value="None" data-i18n="weapon-type-None">---</option>
				<option data-i18n="weapon-type-Melee" value="Melee">Melee</option>
				<option data-i18n="weapon-type-Ranged" value="Ranged">Ranged</option>
			</select>
		</div>

		<!-- Description/Effect section -->
		<div class="rowContainer weaponInfo">
			<div class="weaponDescription">
				<div class="descHead"></div>
				<textarea spellcheck="false"  name="attr_weapon4Description" class="weaponDescriptionInput" data-i18n-placeholder="weapon-desc" placeholder="Weapon description."></textarea>
			</div>

			<div class="weaponEffect">
				<textarea spellcheck="false"  name="attr_weapon4Effect" class="weaponEffectInput" data-i18n-placeholder="weapon-effect" placeholder="Weapon effects."></textarea>
			</div>
		</div>
		<!-- desc end -->	

	</div>
	<!-- Weapon 4 Block END -->

</div>
<!-- !!EXTRA!! Weapons end -->


<!-- Augmentation block -->
<div class="augmentBlock">
	<div class="itemButtons">
		<button type="action" class="darkInput shareButton share" name="act_shareAugment" data-i18n-title="share" title="Share info"></button>
		<button type="action" class="darkInput autoScriptButton script" id="augmentAutoScript" name="act_autoScriptEdit" data-i18n-title="autoscript-edit" title="Edit AutoScript"></button>
		<input type="text" name="attr_augmentAutoScript" hidden="true">
	</div>

	<!-- Augment header -->
	<div class="contentHeader augment rowContainer" id="augment-name">
	<input type="text" class="augmentRank" name="attr_augmentRank" placeholder="0" data-i18n-title="rank" title="Rank">
	<input type="text" class="transpInput contentName" name="attr_augmentName" data-i18n-placeholder="augment-name" placeholder="Augmentation name">

        <select name="attr_augmentType" class="darkInput contentName topRight">
	<option data-i18n="augment-type-None" value="None">---</option>
	<option data-i18n="augment-type-Tattoos" value="Tattoos">Tattoos</option>
	<option data-i18n="augment-type-Drugs" value="Drugs">Serums/Drugs</option>
	<option data-i18n="augment-type-Surgery" value="Surgery">Surgery</option>
	<option data-i18n="augment-type-Prosthesis" value="Prosthesis">Prosthesis</option>
	<option data-i18n="augment-type-FullProsthesis" value="FullProsthesis">Full Prosthesis</option>
	<option data-i18n="augment-type-Other" value="Other">Other</option>
        </select>

	</div>

	<!-- header end -->


	<!-- Description/Effect section -->
	<div class="rowContainer weaponInfo">

        <div class="weaponDescription">
       <textarea spellcheck="false"  name="attr_augmentDescription" class="augmentDescriptionInput" data-i18n-placeholder="augment-desc" placeholder="Augment description."></textarea>
        </div>

        <div class="weaponEffect">
	<textarea spellcheck="false"  name="attr_augmentEffect" class="weaponEffectInput" data-i18n-placeholder="augment-effect" placeholder="Augment effects."></textarea>
        </div>

	</div>
	<!-- desc end -->	

	</div>

<!-- Augmentation block - END -->

                </div>
<!-- Weapon section END -->

<!-- Outfit / Other equipment section -->
<div class="rowContainer" style="max-width: 600px; flex-wrap: wrap;">
<div class="outfitContainer">

<!-- Outfit block -->
<div class="contentContainer">
<div>
	<div class="itemButtons">
		<button type="action" class="darkInput shareButton share" name="act_shareOutfit" data-i18n-title="share" title="Share info"></button>
		<button type="action" class="darkInput editButton edit" name="act_editMode" data-i18n-title="edit" title="Edit"></button>
		<button type="action" class="darkInput autoScriptButton script" id="outfitAutoScript" name="act_autoScriptEdit" data-i18n-title="autoscript-edit" title="Edit AutoScript"></button>
		<input type="text" name="attr_outfitAutoScript" hidden="true">
	</div>

<!-- Outfit Burn/Bleed/Damage Resist -->
<input type="checkbox" class="hide-toggle" name="attr_settingEditMode" value="true">
<div class="editCover hide-item">

<div class="columnAlign">
<div class="rowContainer">
<div class="rowContainer">
<input type="checkbox" class="fade-toggle" name="attr_burnResist" value="0" hidden="true" checked>

        <div class="ailmentIconSelector status_effect_item centerFlex">
	<div class="icon">
	<input type="checkbox" class="hide-toggle-rev" value="true" name="attr_settingLimbusStyle"><div class="hide-item-rev skillIcon burn"></div>
	</div>

	<div class="icon">
	<input type="checkbox" class="expand-toggle" value="true" name="attr_settingLimbusStyle"><div class="type-image skillIcon burn-limbus"></div>
	</div>
	</div>

        <div class="status_effect_value"><input type="number" class="ailmentNum" name="attr_burnResist" value="0"></div>
</div>

<div class="rowContainer">
<input type="checkbox" class="fade-toggle" name="attr_bleedResist" value="0" hidden="true" checked>

        <div class="ailmentIconSelector status_effect_item rowContainer centerFlex">
	<div class="icon">
	<input type="checkbox" class="hide-toggle-rev" value="true" name="attr_settingLimbusStyle"><div class="hide-item-rev skillIcon bleed"></div>
	</div>

	<div class="icon">
	<input type="checkbox" class="expand-toggle" value="true" name="attr_settingLimbusStyle"><div class="type-image skillIcon bleed-limbus"></div>
	</div>
	</div>

       <div class="status_effect_value"><input type="number"  class="ailmentNum" name="attr_bleedResist" value="0"></div>
	</div>

<div class="rowContainer">
<input type="checkbox" class="fade-toggle" name="attr_damageResist" value="0" hidden="true" checked>

	<div class="ailmentIconSelector status_effect_item rowContainer centerFlex">
		<div class="icon">
			<input type="checkbox" class="hide-toggle-rev" value="true" name="attr_settingLimbusStyle"><div class="hide-item-rev skillIcon damageResist"></div>
		</div>

		<div class="icon">
			<input type="checkbox" class="expand-toggle" value="true" name="attr_settingLimbusStyle"><div class="type-image skillIcon damageResist-limbus"></div>
		</div>
	</div>
	
	<div class="status_effect_value"><input type="number" class="ailmentNum" name="attr_damageResist" value="0"></div>
</div>

</div>
<!-- Outfit Custom Ailment Resistances -->
<div class="customResistDisplay">
	<fieldset class="repeating_ailments">
		<input type="checkbox" class="hide-toggle" name="attr_ailCustomResistance" hidden="true" value="true">
		<div class="rowContainer hide-item">
			<input type="checkbox" class="fade-toggle" name="attr_ailCustomResistanceNum" value="0" hidden="true" checked>
			<div class="status_effect_item rowContainer centerFlex">
				<!-- Icon selector -->
				<div class="ailmentIconSelector rowContainer centerFlex">
					<div class="icon">
					<img name="attr_ailIconDisplay" class="skillIcon">
					</div>
				</div>
			</div>
			<div class="status_effect_value"><input type="number" class="ailmentNum" name="attr_ailCustomResistanceNum" value="0"></div>
		</div>
	</fieldset>
</div>
</div>
</div>

<!-- Outfit Resistances -->


<!-- Outfit header -->
	<div class="contentHeader outfit" id="outfit-name">

	<input type="text" class="outfitRank" name="attr_outfitRank" placeholder="0" data-i18n-title="rank" title="Rank">
		<input type="text" class="transpInput contentName" name="attr_outfitName" data-i18n-placeholder="outfit-name" placeholder="Outfit">

	<!-- Outfit dice roll block -->
	<div class="rowContainer combatRoll">
	
	<div class="evadeIcon typeIcon defend">
	</div>


		<div class="rollFormatBlock">
		<input type="number" class="diceCount noSpinner" name="attr_defDice1" min="1" value="1">
		<div class="plainText">D</div>
		<input type="number" class="diceMax noSpinner" name="attr_defDice2" min="0" value="0">
		<div class="plainText">+</div>
		<input type="number" class="dicePower noSpinner" name="attr_defDice3" value="0">
		</div>

	<div>
              
<button type="action" class="NDice" id="autoroll_def_raw" name="act_rollCombat"></button>

	</div>
	<!-- dice roll end -->

	</div></div>
	<!-- header end -->

	<div class="weaponRangeBox outfit"> 

	<div class="rowContainer combatRoll evadeAdjust">

	<div class="evadeIcon typeIcon evade">
	</div>


		<div class="rollFormatBlock">
		<input type="number" class="diceCount noSpinner" name="attr_evdDice1" min="1" value="1">
		<div class="plainText">D</div>
		<input type="number" class="diceMax noSpinner" name="attr_evdDice2" min="0" value="0">
		<div class="plainText">+</div>
		<input type="number" class="dicePower noSpinner" name="attr_evdDice3" value="0">
		</div>

	<div>
              
<button type="action" class="NDice" id="autoroll_evd_raw" name="act_rollCombat"></button>

	</div>

	</div>
	</div>


	<!-- Description/Effect section -->

<div class="rowContainer">

<div class="rowContainer">
	<textarea spellcheck="false"  name="attr_outfitEffect" class="weaponEffectInput" data-i18n-placeholder="outfit-effect" placeholder="Outfit effects."></textarea>

	</div>

<!-- Outfit resistance table -->
	<div class="rowContainer resistanceChart" style="margin-top: 25px">
		<div class="rowContainer centerFlex">

<div id="outfit_res_slash">
		<div class="resIconLeft">
		<div class="resistIcon slashNormal"></div>
		</div>

	</div>

                            <select name="attr_outfitImmune1" id="outfitImmune1" class="outfitResistVal dmg">
				<option data-i18n="outfit-res-none" value="" selected disabled hidden>---</option>
                                <option data-i18n="outfit-res-fatal" value="2">[x2]Fatal</option>
                                <option data-i18n="outfit-res-weak" value="1.5">[x1.5]Weak</option>
                                <option data-i18n="outfit-res-normal" value="1">[x1]Normal</option>
                                <option data-i18n="outfit-res-endured" value="0.5">[x0.5]Endured</option>
                                <option data-i18n="outfit-res-ineffective" value="0.25">[x0.25]Ineffective</option>
                                <option data-i18n="outfit-res-immune" value="0">[x0]Immune</option>
                            </select>

                            <select name="attr_outfitImmune2" id="outfitImmune2" class="outfitResistVal stg">
				<option data-i18n="outfit-res-none" value="" selected disabled hidden>---</option>
                                <option data-i18n="outfit-res-fatal" value="2">[x2]Fatal</option>
                                <option data-i18n="outfit-res-weak" value="1.5">[x1.5]Weak</option>
                                <option data-i18n="outfit-res-normal" value="1">[x1]Normal</option>
                                <option data-i18n="outfit-res-endured" value="0.5">[x0.5]Endured</option>
                                <option data-i18n="outfit-res-ineffective" value="0.25">[x0.25]Ineffective</option>
                                <option data-i18n="outfit-res-immune" value="0">[x0]Immune</option>
                            </select>

<div id="outfit_res_slashSTG">
		<div class="resIconRight">
		<div class="resistIcon slashNormalSTG"></div>
		</div>

	</div>


		</div>

		<div class="rowContainer centerFlex">


<div id="outfit_res_pierce">
		<div class="resIconLeft">
		<div class="resistIcon pierceNormal"></div>
		</div>


	</div>


                            <select name="attr_outfitImmune3" id="outfitImmune3" class="outfitResistVal dmg">
				<option data-i18n="outfit-res-none" value="" selected disabled hidden>---</option>
                                <option data-i18n="outfit-res-fatal" value="2">[x2]Fatal</option>
                                <option data-i18n="outfit-res-weak" value="1.5">[x1.5]Weak</option>
                                <option data-i18n="outfit-res-normal" value="1">[x1]Normal</option>
                                <option data-i18n="outfit-res-endured" value="0.5">[x0.5]Endured</option>
                                <option data-i18n="outfit-res-ineffective" value="0.25">[x0.25]Ineffective</option>
                                <option data-i18n="outfit-res-immune" value="0">[x0]Immune</option>
                            </select>

                            <select name="attr_outfitImmune4" id="outfitImmune4" class="outfitResistVal stg">
				<option data-i18n="outfit-res-none" value="" selected disabled hidden>---</option>
                                <option data-i18n="outfit-res-fatal" value="2">[x2]Fatal</option>
                                <option data-i18n="outfit-res-weak" value="1.5">[x1.5]Weak</option>
                                <option data-i18n="outfit-res-normal" value="1">[x1]Normal</option>
                                <option data-i18n="outfit-res-endured" value="0.5">[x0.5]Endured</option>
                                <option data-i18n="outfit-res-ineffective" value="0.25">[x0.25]Ineffective</option>
                                <option data-i18n="outfit-res-immune" value="0">[x0]Immune</option>
                            </select>


<div id="outfit_res_pierceSTG">
		<div class="resIconRight">
		<div class="resistIcon pierceNormalSTG"></div>
		</div>


	</div>



		</div>

		<div class="rowContainer centerFlex">


<div id="outfit_res_blunt">
		<div class="resIconLeft">
		<div class="resistIcon bluntNormal"></div>
		</div>


	</div>


                            <select name="attr_outfitImmune5" id="outfitImmune5" class="outfitResistVal dmg">
				<option data-i18n="outfit-res-none" value="" selected disabled hidden>---</option>
                                <option data-i18n="outfit-res-fatal" value="2">[x2]Fatal</option>
                                <option data-i18n="outfit-res-weak" value="1.5">[x1.5]Weak</option>
                                <option data-i18n="outfit-res-normal" value="1">[x1]Normal</option>
                                <option data-i18n="outfit-res-endured" value="0.5">[x0.5]Endured</option>
                                <option data-i18n="outfit-res-ineffective" value="0.25">[x0.25]Ineffective</option>
                                <option data-i18n="outfit-res-immune" value="0">[x0]Immune</option>
                            </select>

                            <select name="attr_outfitImmune6" id="outfitImmune6" class="outfitResistVal stg">
				<option data-i18n="outfit-res-none" value="" selected disabled hidden>---</option>
                                <option data-i18n="outfit-res-fatal" value="2">[x2]Fatal</option>
                                <option data-i18n="outfit-res-weak" value="1.5">[x1.5]Weak</option>
                                <option data-i18n="outfit-res-normal" value="1">[x1]Normal</option>
                                <option data-i18n="outfit-res-endured" value="0.5">[x0.5]Endured</option>
                                <option data-i18n="outfit-res-ineffective" value="0.25">[x0.25]Ineffective</option>
                                <option data-i18n="outfit-res-immune" value="0">[x0]Immune</option>
                            </select>

<div id="outfit_res_bluntSTG">
		<div class="resIconRight">
		<div class="resistIcon bluntNormalSTG"></div>
		</div>

	</div>


		</div>
</div>
<!-- Resistance chart end -->
</div>

<div class="outfitDescription"><textarea spellcheck="false"  name="attr_outfitDescription" class="outfitDescriptionInput" data-i18n-placeholder="outfit-desc" placeholder="Outfit description."></textarea></div> 


</div>

</div>





	<!-- desc end -->	

	</div>


<!-- Item section -->
<div class="toolContainer">

	<!-- Tool1 block -->
	<div class="contentContainer half" style="margin-right: 8px;">

	<!-- header -->
	<div class="contentHeader tool rowContainer">
	<input type="text" class="toolRank" name="attr_tool1Rank" placeholder="0" data-i18n-title="rank" title="Rank">
	<input type="text" class="toolName transpInput" name="attr_tool1Name" data-i18n-placeholder="tool-name" placeholder="Tool name">

	<input type="checkbox" id="attr_tool1Portable" name="attr_tool1Portable" value="Portable"><label for="attr_tool1Portable" class="centerIcon portable" data-i18n-title="tool-portable" title="Portable"></label> 

	<input type="checkbox" id="attr_tool1Reusable" name="attr_tool1Reusable" value="Reusable"><label for="attr_tool1Reusable" class="centerIcon reusable" data-i18n-title="tool-reusable" title="Reusable"> 

<div class="rowContainer centerFlex" style="width: 30px; height: 30px;">   
<input type="text" class="transpInput" name="attr_tool1Uses" style="width: 100%; height: 100%; text-align: center;" value="1">
<div class="blocker"></div>  
</div>

</label>

	</div>
	<!-- header end -->
  
	<!-- Tool1 Edit-->
<input type="checkbox" class="hide-toggle" name="attr_settingEditMode" value="true">
<div class="hide-item editCover">

	<div class="settingStyle" style="margin-bottom: 3px;">
	<div class="settingStyle" style="width: 36px;"><b data-i18n="message-icon">Icon</b>:</div> 
	<input type="text" class="darkInput" list="iconlist" name="attr_tool1Icon" style="width: 149px;" data-i18n-placeholder="message-icon-placeholder" placeholder="Icon selection" value="Hand">
	</div>
	<div class="settingStyle">
	<div class="settingStyle" style="width: 36px;"><b data-i18n="message-uses">Uses</b>:	</div> 

	<input type="text" class="transpInput" style="width: 23px;" name="attr_tool1Uses" value="1"> / 
	<input type="number" class="darkInput toolMaxInput hoverSpinner" style="width: 32px; margin-left: 2px;" name="attr_tool1Uses_max" value="3" min="1">

	</div>

</div>
<!-- Tool1 Edit end -->

<div class="itemButtons">
	<button type="action" class="darkInput shareButton share" id="share_tool1" name="act_shareTool" data-i18n-title="share" title="Share info"></button>
	<button type="action" class="darkInput editButton edit" name="act_editMode" data-i18n-title="edit" title="Edit"></button>
	<button type="action" class="darkInput autoScriptButton script" id="tool1AutoScript" name="act_autoScriptEdit" data-i18n-title="autoscript-edit" title="Edit AutoScript"></button>
	<input type="text" name="attr_tool1AutoScript" hidden="true">
</div>


	<!-- Description/Effect section -->

        <div class="toolDescription">
       <textarea spellcheck="false"  name="attr_tool1Description" class="toolDescriptionInput" data-i18n-placeholder="tool-desc" placeholder="Tool description."></textarea>
        </div>

        <div class="itemEffect">
	<textarea spellcheck="false"  name="attr_tool1Effect" class="weaponEffectInput" data-i18n-placeholder="tool-effect" placeholder="Tool effects."></textarea>
        </div>

	<!-- desc end -->	

	</div>
	<!-- Tool1 Block - end -->


	<!-- Tool2 block -->
	<div class="contentContainer half">

	<!-- header -->
	<div class="contentHeader tool rowContainer">
	<input type="text" class="toolRank" name="attr_tool2Rank" placeholder="0" data-i18n-title="rank" title="Rank">
	<input type="text" class="toolName transpInput" name="attr_tool2Name" data-i18n-placeholder="tool-name" placeholder="Tool name">

	<input type="checkbox" id="attr_tool2Portable" name="attr_tool2Portable" value="Portable"><label for="attr_tool2Portable" class="centerIcon portable" data-i18n-title="tool-portable" title="Portable"></label> 

	<input type="checkbox" id="attr_tool2Reusable" name="attr_tool2Reusable" value="Reusable"><label for="attr_tool2Reusable" class="centerIcon reusable" data-i18n-title="tool-reusable" title="Reusable"> 

<div class="rowContainer centerFlex" style="width: 30px; height: 30px;">   
<input type="text" class="transpInput" name="attr_tool2Uses" style="width: 100%; height: 100%; text-align: center;" value="1">
<div class="blocker"></div>  
</div>

</label>

	</div>
	<!-- header end -->
  
	<!-- Tool2 Edit-->
<input type="checkbox" class="hide-toggle" name="attr_settingEditMode" value="true">
<div class="hide-item editCover">

	<div class="settingStyle" style="margin-bottom: 3px;">
	<div class="settingStyle" style="width: 36px;"><b data-i18n="message-icon">Icon</b>:</div> 
	<input type="text" class="darkInput" list="iconlist" name="attr_tool2Icon" style="width: 149px;" data-i18n-placeholder="message-icon-placeholder" placeholder="Icon selection" value="Hand">
	</div>
	<div class="settingStyle">
	<div class="settingStyle" style="width: 36px;"><b data-i18n="message-uses">Uses</b>:	</div> 

	<input type="text" class="transpInput" style="width: 23px;" name="attr_tool2Uses" value="1"> / 
	<input type="number" class="darkInput toolMaxInput hoverSpinner" style="width: 32px; margin-left: 2px;" name="attr_tool2Uses_max" value="3" min="1">

	</div>

</div>
<!-- Tool2 Edit end -->

<div class="itemButtons">
	<button type="action" class="darkInput shareButton share" id="share_tool2" name="act_shareTool" data-i18n-title="share" title="Share info"></button>
	<button type="action" class="darkInput editButton edit" name="act_editMode" data-i18n-title="edit" title="Edit"></button>
	<button type="action" class="darkInput autoScriptButton script" id="tool2AutoScript" name="act_autoScriptEdit" data-i18n-title="autoscript-edit" title="Edit AutoScript"></button>
	<input type="text" name="attr_tool2AutoScript" hidden="true">
</div>

	<!-- Description/Effect section -->
        <div class="toolDescription">
       <textarea spellcheck="false"  name="attr_tool2Description" class="toolDescriptionInput" data-i18n-placeholder="tool-desc" placeholder="Tool description."></textarea>
        </div>

        <div class="itemEffect">
	<textarea spellcheck="false"  name="attr_tool2Effect" class="weaponEffectInput"
data-i18n-placeholder="tool-effect" placeholder="Tool effects."></textarea>
        </div>

	<!-- desc end -->	

	</div>
	<!-- Tool2 Block - end -->

</div>
<!-- Tool Block END -->

<!-- !!EXTRA!! Tool section -->
<input type="checkbox" class="hide-toggle" name="attr_settingExtraEquip" value="true">
<div class="hide-item">

<div class="toolContainer">

	<!-- Tool3 block -->
	<div class="contentContainer half" style="margin-right: 8px;">

	<!-- header -->
	<div class="contentHeader tool rowContainer">
	<input type="text" class="toolRank" name="attr_tool3Rank" placeholder="0" data-i18n-title="rank" title="Rank">
	<input type="text" class="toolName transpInput" name="attr_tool3Name" data-i18n-placeholder="tool-name" placeholder="Tool name">

	<input type="checkbox" id="attr_tool3Portable" name="attr_tool3Portable" value="Portable"><label for="attr_tool3Portable" class="centerIcon portable" data-i18n-title="tool-portable" title="Portable"></label> 

	<input type="checkbox" id="attr_tool3Reusable" name="attr_tool3Reusable" value="Reusable"><label for="attr_tool3Reusable" class="centerIcon reusable" data-i18n-title="tool-reusable" title="Reusable"> 

<div class="rowContainer centerFlex" style="width: 30px; height: 30px;">   
<input type="text" class="transpInput" name="attr_tool3Uses" style="width: 100%; height: 100%; text-align: center;" value="1">
<div class="blocker"></div>  
</div>

</label>

	</div>
	<!-- header end -->
  
	<!-- Tool3 Edit-->
<input type="checkbox" class="hide-toggle" name="attr_settingEditMode" value="true">
<div class="hide-item editCover">

	<div class="settingStyle" style="margin-bottom: 3px;">
	<div class="settingStyle" style="width: 36px;"><b data-i18n="message-icon">Icon</b>:</div> 
	<input type="text" class="darkInput" list="iconlist" name="attr_tool3Icon" style="width: 149px;" data-i18n-placeholder="message-icon-placeholder" placeholder="Icon selection" value="Hand">
	</div>
	<div class="settingStyle">
	<div class="settingStyle" style="width: 36px;"><b data-i18n="message-uses">Uses</b>:	</div> 

	<input type="text" class="transpInput" style="width: 23px;" name="attr_tool3Uses" value="1"> / 
	<input type="number" class="darkInput toolMaxInput hoverSpinner" style="width: 32px; margin-left: 2px;" name="attr_tool3Uses_max" value="3" min="1">

	</div>

</div>
<!-- Tool3 Edit end -->

<div class="itemButtons">
	<button type="action" class="darkInput shareButton share" id="share_tool3" name="act_shareTool" data-i18n-title="share" title="Share info"></button>
	<button type="action" class="darkInput editButton edit" name="act_editMode" data-i18n-title="edit" title="Edit"></button>
	<button type="action" class="darkInput autoScriptButton script" id="tool3AutoScript" name="act_autoScriptEdit" data-i18n-title="autoscript-edit" title="Edit AutoScript"></button>
	<input type="text" name="attr_tool3AutoScript" hidden="true">
</div>




	<!-- Description/Effect section -->

        <div class="toolDescription">
       <textarea spellcheck="false"  name="attr_tool3Description" class="toolDescriptionInput" data-i18n-placeholder="tool-desc" placeholder="Tool description."></textarea>
        </div>

        <div class="itemEffect">
	<textarea spellcheck="false"  name="attr_tool3Effect" class="weaponEffectInput" data-i18n-placeholder="tool-effect" placeholder="Tool effects."></textarea>
        </div>

	<!-- desc end -->	

	</div>
	<!-- Tool3 Block - end -->


	<!-- Tool4 block -->
	<div class="contentContainer half">

	<!-- header -->
	<div class="contentHeader tool rowContainer">
	<input type="text" class="toolRank" name="attr_tool4Rank" placeholder="0" data-i18n-title="rank" title="Rank">
	<input type="text" class="toolName transpInput" name="attr_tool4Name" data-i18n-placeholder="tool-name" placeholder="Tool name">

	<input type="checkbox" id="attr_tool4Portable" name="attr_tool4Portable" value="Portable"><label for="attr_tool4Portable" class="centerIcon portable" data-i18n-title="tool-portable" title="Portable"></label> 

	<input type="checkbox" id="attr_tool4Reusable" name="attr_tool4Reusable" value="Reusable"><label for="attr_tool4Reusable" class="centerIcon reusable" data-i18n-title="tool-reusable" title="Reusable"> 

<div class="rowContainer centerFlex" style="width: 30px; height: 30px;">   
<input type="text" class="transpInput" name="attr_tool4Uses" style="width: 100%; height: 100%; text-align: center;" value="1">
<div class="blocker"></div>  
</div>

</label>

	</div>
	<!-- header end -->
  
	<!-- Tool4 Edit-->
<input type="checkbox" class="hide-toggle" name="attr_settingEditMode" value="true">
<div class="hide-item editCover">

	<div class="settingStyle" style="margin-bottom: 3px;">
	<div class="settingStyle" style="width: 36px;"><b data-i18n="message-icon">Icon</b>:</div> 
	<input type="text" class="darkInput" list="iconlist" name="attr_tool4Icon" style="width: 149px;" data-i18n-placeholder="message-icon-placeholder" placeholder="Icon selection" value="Hand">
	</div>
	<div class="settingStyle">
	<div class="settingStyle" style="width: 36px;"><b data-i18n="message-uses">Uses</b>:	</div> 

	<input type="text" class="transpInput" style="width: 23px;" name="attr_tool4Uses" value="1"> / 
	<input type="number" class="darkInput toolMaxInput hoverSpinner" style="width: 32px; margin-left: 2px;" name="attr_tool4Uses_max" value="3" min="1">

	</div>

</div>
<!-- Tool4 Edit end -->

<div class="itemButtons">
	<button type="action" class="darkInput shareButton share" id="share_tool4" name="act_shareTool" data-i18n-title="share" title="Share info"></button>
	<button type="action" class="darkInput editButton edit" name="act_editMode" data-i18n-title="edit" title="Edit"></button>
	<button type="action" class="darkInput autoScriptButton script" id="tool4AutoScript" name="act_autoScriptEdit" data-i18n-title="autoscript-edit" title="Edit AutoScript"></button>
	<input type="text" name="attr_tool4AutoScript" hidden="true">
</div>


	<!-- Description/Effect section -->
        <div class="toolDescription">
       <textarea spellcheck="false"  name="attr_tool4Description" class="toolDescriptionInput" data-i18n-placeholder="tool-desc" placeholder="Tool description."></textarea>
        </div>

        <div class="itemEffect">
	<textarea spellcheck="false"  name="attr_tool4Effect" class="weaponEffectInput" data-i18n-placeholder="tool-effect" placeholder="Tool effects."></textarea>
        </div>

	<!-- desc end -->	

	</div>
	<!-- Tool4 Block - end -->
</div>
</div>
<!-- !!EXTRA!! Item Block END -->


</div>

</div>

<!-- ??? -->

<!-- Special Items section -->
<input type="checkbox" class="hide-toggle-rev" name="attr_settingHideSpecial" value="true">
<div class="hide-item-rev rowContainer">
<div class="contentBlock">

	<!-- Special Item1 block -->
	<div class="specialBlock">

	<!-- Item buttons -->
	<div class="itemButtons">
		<button type="action" class="darkInput shareButton share" id="share_special1" name="act_shareSpecial" data-i18n-title="share" title="Share info"></button>
		<button type="action" class="darkInput autoScriptButton script" id="special1AutoScript" name="act_autoScriptEdit" data-i18n-title="autoscript-edit" title="Edit AutoScript"></button>
		<input type="text" name="attr_special1AutoScript" hidden="true">
	</div>

	<!-- Header -->
	<div class="contentHeader special" id="special1Name">
		
	<input type="text" type="text" class="specialItemRank" name="attr_special1Rank" placeholder="0" data-i18n-title="rank" title="Rank">

	<input type="text" class="transpInput contentName" name="attr_special1Name" data-i18n-placeholder="special-name" placeholder="Special item name">

		<select name="attr_special1Risk" class="darkInput contentName topRight" data-i18n-title="special-risk-text" title="Risk Level">
			<option data-i18n="special-risk-none" value="none">---</option>
			<option data-i18n="special-risk-0" value="0">Canard</option>
			<option data-i18n="special-risk-1" value="1">Urban Myth</option>
			<option data-i18n="special-risk-2" value="2">Urban Legend</option>
			<option data-i18n="special-risk-3" value="3">Urban Plague</option>
			<option data-i18n="special-risk-4" value="4">Urban Nightmare</option>
			<option data-i18n="special-risk-5" value="5">Star of the City</option>
			<option data-i18n="special-risk-6" value="6">Impuritas Civitatis</option>
		</select>

	</div>
	<!-- header end -->


	<!-- Description/Effect section -->
	<div class="rowContainer weaponInfo">

	<div class="special" style="height: 110px;"> 

	<div class="specialColumn">
	<span data-i18n="special-range-text">Effect Range</span>
 		<select name="attr_special1Range" class="specialInput darkInput" id="special1Range" style="text-align: center;">
                          <option data-i18n="special-range-none" value="none">---</option>
                          <option data-i18n="special-range-0" value="0">One or two people</option>
                          <option data-i18n="special-range-1" value="1">Street</option>
                          <option data-i18n="special-range-2" value="2">Neighborhood</option>
                          <option data-i18n="special-range-3" value="3">Residence Area</option>
                          <option data-i18n="special-range-4" value="4">Nest</option>
                          <option data-i18n="special-range-5" value="5">Multiple Nests</option>
                          <option data-i18n="special-range-6" value="6">City</option>
               	</select>
	</div>

	<div class="specialColumn">
	<span data-i18n="special-duration-text">Duration</span>
		<select name="attr_special1Duration" class="specialInput darkInput" id="special1_duration" style="text-align: center;">
			<option data-i18n="special-duration-none" value="none">---</option>
			<option data-i18n="special-duration-0" value="0">A moment</option>
			<option data-i18n="special-duration-1" value="1">Seconds</option>
			<option data-i18n="special-duration-2" value="2">Minutes</option>
			<option data-i18n="special-duration-3" value="3">Hours</option>
			<option data-i18n="special-duration-4" value="4">Days</option>
			<option data-i18n="special-duration-5" value="5">Weeks</option>
			<option data-i18n="special-duration-6" value="6">Months</option>
              	</select>
	</div>

	</div>

       <textarea spellcheck="false"  name="attr_special1Description" class="specialDescriptionInput" data-i18n-placeholder="special-desc" placeholder="Special item description/effects."></textarea>

	</div>
	<!-- desc end -->	

	</div>
<!-- Special Item 1 Block END -->


<!-- Special Item2 block -->
	<div class="specialBlock">

	<!-- Item buttons -->
	<div class="itemButtons">
		<button type="action" class="darkInput shareButton share" id="share_special2" name="act_shareSpecial" data-i18n-title="share" title="Share info"></button>
		<button type="action" class="darkInput autoScriptButton script" id="special2AutoScript" name="act_autoScriptEdit" data-i18n-title="autoscript-edit" title="Edit AutoScript"></button>
		<input type="text" name="attr_special2AutoScript" hidden="true">
	</div>

	<!-- Header -->
	<div class="contentHeader special" id="special2Name">
		
	<input type="text" type="text" class="specialItemRank" name="attr_special2Rank" placeholder="0" data-i18n-title="rank" title="Rank">

	<input type="text" class="transpInput contentName" name="attr_special2Name" data-i18n-placeholder="special-name" placeholder="Special item name">

	<select name="attr_special2Risk" class="darkInput contentName topRight" data-i18n-title="special-risk-text" title="Risk Level">
			<option data-i18n="special-risk-none" value="none">---</option>
			<option data-i18n="special-risk-0" value="0">Canard</option>
			<option data-i18n="special-risk-1" value="1">Urban Myth</option>
			<option data-i18n="special-risk-2" value="2">Urban Legend</option>
			<option data-i18n="special-risk-3" value="3">Urban Plague</option>
			<option data-i18n="special-risk-4" value="4">Urban Nightmare</option>
			<option data-i18n="special-risk-5" value="5">Star of the City</option>
			<option data-i18n="special-risk-6" value="6">Impuritas Civitatis</option>
		</select>

	</div>
	<!-- header end -->


	<!-- Description/Effect section -->
	<div class="rowContainer weaponInfo">

	<div class="special" style="height: 110px;"> 

	<div class="specialColumn">
	<span data-i18n="special-range-text">Effect Range</span>
 		<select name="attr_special2Range" class="specialInput darkInput" id="special2Range" style="text-align: center;">
                          <option data-i18n="special-range-none" value="none">---</option>
                          <option data-i18n="special-range-0" value="0">One or two people</option>
                          <option data-i18n="special-range-1" value="1">Street</option>
                          <option data-i18n="special-range-2" value="2">Neighborhood</option>
                          <option data-i18n="special-range-3" value="3">Residence Area</option>
                          <option data-i18n="special-range-4" value="4">Nest</option>
                          <option data-i18n="special-range-5" value="5">Multiple Nests</option>
                          <option data-i18n="special-range-6" value="6">City</option>
               	</select>
	</div>

	<div class="specialColumn">
	<span data-i18n="special-duration-text">Duration</span>
		<select name="attr_special2Duration" class="specialInput darkInput" id="special2_duration" style="text-align: center;">
			<option data-i18n="special-duration-none" value="none">---</option>
			<option data-i18n="special-duration-0" value="0">A moment</option>
			<option data-i18n="special-duration-1" value="1">Seconds</option>
			<option data-i18n="special-duration-2" value="2">Minutes</option>
			<option data-i18n="special-duration-3" value="3">Hours</option>
			<option data-i18n="special-duration-4" value="4">Days</option>
			<option data-i18n="special-duration-5" value="5">Weeks</option>
			<option data-i18n="special-duration-6" value="6">Months</option>
              	</select>
	</div>

	</div>

       <textarea spellcheck="false"  name="attr_special2Description" class="specialDescriptionInput" data-i18n-placeholder="special-desc" placeholder="Special item description/effects."></textarea>

	</div>
	<!-- desc end -->	

	</div>
<!-- Special Item2 Block END -->

</div>

</div>
</div>
</div>
</div>
<!-- Equipment END -->

<!-- Skill section -->

	<div class="sheet-body sheet-skills darkBG">
        <div class="contentBlock" id="skillSection">

<!-- EGO Skills Column -->
            <div class="egoSkillContainer">

	<!-- EGO Skill1 block -->
	<div class="skillBlock">

	<!-- Item buttons -->
	<div class="itemButtons">
		<button type="action" class="darkInput shareButton share" id="share_egoSkill1" name="act_shareSkill" data-i18n-title="share" title="Share info"></button>
		<button type="action" class="darkInput autoScriptButton script" id="egoSkill1AutoScript" name="act_autoScriptEdit" data-i18n-title="autoscript-edit" title="Edit AutoScript"></button>
		<input type="text" name="attr_egoSkill1AutoScript" hidden="true">
	</div>

	<!-- header -->
	<div class="contentHeader skillE rowContainer">

	<input type="text" class="transpInput skillName" name="attr_egoSkill1Name" data-i18n-placeholder="skill-ego-name" placeholder="Mystery skill name">

<div class="iconHolder egoSkills">
		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="" name="attr_egoSkill1Type"><div class="type-image skillIcon skillNone"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Attack" name="attr_egoSkill1Type"><div class="type-image skillIcon skillAtt"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Defend" name="attr_egoSkill1Type"><div class="type-image skillIcon skillDef"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Evade" name="attr_egoSkill1Type"><div class="type-image skillIcon skillEvd"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Action" name="attr_egoSkill1Type"><div class="type-image skillIcon skillAct"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Mass" name="attr_egoSkill1Type"><div class="type-image skillIcon skillMass"></div>
		</div>

<input class="skillRank" type="text" name="attr_egoSkill1Rank" value="0" placeholder="0" data-i18n-title="rank" title="Rank">

	</div>

	<div class="rowContainer centerFlex skillE"> 

				<select name="attr_egoSkill1Type" class="whiteInput skillType" id="EGOskill1-type">
				    <option data-i18n="skill-type-None" value="None" selected>---</option>
                                    <option data-i18n="skill-type-Attack" value="Attack">Attack</option>
                                    <option data-i18n="skill-type-Defend" value="Defend">Defend</option>
                                    <option data-i18n="skill-type-Evade" value="Evade">Evade</option>
                                    <option data-i18n="skill-type-Action" value="Action">Action</option>
                                    <option data-i18n="skill-type-Mass" value="Mass">Mass</option>
                                </select>

		<div class="rollFormatBlock whiteInput" data-i18n-title="skill-dice-text" title="Dice modifiers applied when using skill">
		<input type="number" class="diceCount noSpinner" name="attr_egoSkill1Dice1" value="0">
		<div class="plainText">D</div>
		<input type="number" class="diceMax noSpinner" name="attr_egoSkill1Dice2" value="0">
		<div class="plainText">+</div>
		<input type="number" class="dicePower noSpinner" name="attr_egoSkill1Dice3" value="0">
		</div>
	

	<div class="lightCost">
				<input class="lightCostInput" type="text" name="attr_egoskill1Light" value="1" data-i18n-title="skill-light-cost" title="Light Cost">
	</div>

	</div>


	</div>
	<!-- header end -->


	<!-- Description/Effect section -->
	<div class="rowContainer weaponInfo">

        <div class="weaponDescription">
       <textarea spellcheck="false"  name="attr_egoSkill1Description" class="augmentDescriptionInput" data-i18n-placeholder="skill-desc" placeholder="Skill description."></textarea>
        </div>

        <div class="weaponEffect">
	<textarea spellcheck="false"  name="attr_egoSkill1Effect" class="weaponEffectInput" data-i18n-placeholder="skill-effect" data-i18n-placeholder="skill-effect" placeholder="Skill effects."></textarea>
        </div>

	</div>
	<!-- desc end -->
	</div>
<!-- EGO Skill1 block - END -->

<!-- EGO Skill2 block -->
	<div class="skillBlock">

	<!-- Item buttons -->
	<div class="itemButtons">
		<button type="action" class="darkInput shareButton share" id="share_egoSkill2" name="act_shareSkill" data-i18n-title="share" title="Share info"></button>
		<button type="action" class="darkInput autoScriptButton script" id="egoSkill2AutoScript" name="act_autoScriptEdit" data-i18n-title="autoscript-edit" title="Edit AutoScript"></button>
		<input type="text" name="attr_egoSkill2AutoScript" hidden="true">
	</div>

	<!-- header -->
	<div class="contentHeader skillE rowContainer">

	<input type="text" class="transpInput skillName" name="attr_egoSkill2Name" data-i18n-placeholder="skill-ego-name" placeholder="Mystery skill name">

<div class="iconHolder egoSkills">
		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="" name="attr_egoSkill2Type"><div class="type-image skillIcon skillNone"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Attack" name="attr_egoSkill2Type"><div class="type-image skillIcon skillAtt"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Defend" name="attr_egoSkill2Type"><div class="type-image skillIcon skillDef"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Evade" name="attr_egoSkill2Type"><div class="type-image skillIcon skillEvd"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Action" name="attr_egoSkill2Type"><div class="type-image skillIcon skillAct"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Mass" name="attr_egoSkill2Type"><div class="type-image skillIcon skillMass"></div>
		</div>

<input class="skillRank" type="text" name="attr_egoSkill2Rank" value="0" placeholder="0" data-i18n-title="rank" title="Rank">

	</div>

	<div class="rowContainer centerFlex skillE"> 

				<select name="attr_egoSkill2Type" class="whiteInput skillType" id="egoSkill2-type">
				    <option data-i18n="skill-type-None" value="None" selected>---</option>
                                    <option data-i18n="skill-type-Attack" value="Attack">Attack</option>
                                    <option data-i18n="skill-type-Defend" value="Defend">Defend</option>
                                    <option data-i18n="skill-type-Evade" value="Evade">Evade</option>
                                    <option data-i18n="skill-type-Action" value="Action">Action</option>
                                    <option data-i18n="skill-type-Mass" value="Mass">Mass</option>
                                </select>

		<div class="rollFormatBlock whiteInput" data-i18n-title="skill-dice-text" title="Dice modifiers applied when using skill">
		<input type="number" class="diceCount noSpinner" name="attr_egoSkill2Dice1" value="0">
		<div class="plainText">D</div>
		<input type="number" class="diceMax noSpinner" name="attr_egoSkill2Dice2" value="0">
		<div class="plainText">+</div>
		<input type="number" class="dicePower noSpinner" name="attr_egoSkill2Dice3" value="0">
		</div>
	

	<div class="lightCost">
				<input class="lightCostInput" type="text" name="attr_egoskill2Light" value="1" data-i18n-title="skill-light-cost" title="Light Cost">
	</div>

	</div>


	</div>
	<!-- header end -->


	<!-- Description/Effect section -->
	<div class="rowContainer weaponInfo">

        <div class="weaponDescription">
       <textarea spellcheck="false"  name="attr_egoSkill2Description" class="augmentDescriptionInput"data-i18n-placeholder="skill-desc" placeholder="Skill description."></textarea>
        </div>

        <div class="weaponEffect">
	<textarea spellcheck="false"  name="attr_egoSkill2Effect" class="weaponEffectInput" data-i18n-placeholder="skill-effect" placeholder="Skill effects."></textarea>
        </div>

	</div>
	<!-- desc end -->
	</div>
<!-- EGO Skill2 block - END -->

<!-- EGO Skill3 block -->
	<div class="skillBlock">

	<!-- Item buttons -->
	<div class="itemButtons">
		<button type="action" class="darkInput shareButton share" id="share_egoSkill3" name="act_shareSkill" data-i18n-title="share" title="Share info"></button>
		<button type="action" class="darkInput autoScriptButton script" id="egoSkill3AutoScript" name="act_autoScriptEdit" data-i18n-title="autoscript-edit" title="Edit AutoScript"></button>
		<input type="text" name="attr_egoSkill3AutoScript" hidden="true">
	</div>

	<!-- header -->
	<div class="contentHeader skillE rowContainer">

	<input type="text" class="transpInput skillName" name="attr_egoSkill3Name" data-i18n-placeholder="skill-ego-name" placeholder="Mystery skill name">

<div class="iconHolder egoSkills">
		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="" name="attr_egoSkill3Type"><div class="type-image skillIcon skillNone"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Attack" name="attr_egoSkill3Type"><div class="type-image skillIcon skillAtt"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Defend" name="attr_egoSkill3Type"><div class="type-image skillIcon skillDef"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Evade" name="attr_egoSkill3Type"><div class="type-image skillIcon skillEvd"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Action" name="attr_egoSkill3Type"><div class="type-image skillIcon skillAct"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Mass" name="attr_egoSkill3Type"><div class="type-image skillIcon skillMass"></div>
		</div>

<input class="skillRank" type="text" name="attr_egoSkill3Rank" value="0" placeholder="0" data-i18n-title="rank" title="Rank">

	</div>

	<div class="rowContainer centerFlex skillE"> 

				<select name="attr_egoSkill3Type" class="whiteInput skillType" id="egoSkill3-type">
				    <option data-i18n="skill-type-None" value="None" selected>---</option>
                                    <option data-i18n="skill-type-Attack" value="Attack">Attack</option>
                                    <option data-i18n="skill-type-Defend" value="Defend">Defend</option>
                                    <option data-i18n="skill-type-Evade" value="Evade">Evade</option>
                                    <option data-i18n="skill-type-Action" value="Action">Action</option>
                                    <option data-i18n="skill-type-Mass" value="Mass">Mass</option>
                                </select>

		<div class="rollFormatBlock whiteInput" data-i18n-title="skill-dice-text" title="Dice modifiers applied when using skill">
		<input type="number" class="diceCount noSpinner" name="attr_egoSkill3Dice1" value="0">
		<div class="plainText">D</div>
		<input type="number" class="diceMax noSpinner" name="attr_egoSkill3Dice2" value="0">
		<div class="plainText">+</div>
		<input type="number" class="dicePower noSpinner" name="attr_egoSkill3Dice3" value="0">
		</div>
	

	<div class="lightCost">
				<input class="lightCostInput" type="text" name="attr_egoskill3Light" value="1" data-i18n-title="skill-light-cost" title="Light Cost">
	</div>

	</div>


	</div>
	<!-- header end -->


	<!-- Description/Effect section -->
	<div class="rowContainer weaponInfo">

        <div class="weaponDescription">
       <textarea spellcheck="false"  name="attr_egoSkill3Description" class="augmentDescriptionInput"data-i18n-placeholder="skill-desc" placeholder="Skill description."></textarea>
        </div>

        <div class="weaponEffect">
	<textarea spellcheck="false"  name="attr_egoSkill3Effect" class="weaponEffectInput" data-i18n-placeholder="skill-effect" placeholder="Skill effects."></textarea>
        </div>

	</div>
	<!-- desc end -->
	</div>
<!-- EGO Skill3 block - END -->

<!-- EGO Skill4 block -->
	<div class="skillBlock">

	<!-- Item buttons -->
	<div class="itemButtons">
		<button type="action" class="darkInput shareButton share" id="share_egoSkill4" name="act_shareSkill" data-i18n-title="share" title="Share info"></button>
		<button type="action" class="darkInput autoScriptButton script" id="egoSkill4AutoScript" name="act_autoScriptEdit" data-i18n-title="autoscript-edit" title="Edit AutoScript"></button>
		<input type="text" name="attr_egoSkill4AutoScript" hidden="true">
	</div>

	<!-- header -->
	<div class="contentHeader skillE rowContainer">

	<input type="text" class="transpInput skillName" name="attr_egoSkill4Name" data-i18n-placeholder="skill-ego-name" placeholder="Mystery skill name">

<div class="iconHolder egoSkills">
		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="" name="attr_egoSkill4Type"><div class="type-image skillIcon skillNone"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Attack" name="attr_egoSkill4Type"><div class="type-image skillIcon skillAtt"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Defend" name="attr_egoSkill4Type"><div class="type-image skillIcon skillDef"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Evade" name="attr_egoSkill4Type"><div class="type-image skillIcon skillEvd"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Action" name="attr_egoSkill4Type"><div class="type-image skillIcon skillAct"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Mass" name="attr_egoSkill4Type"><div class="type-image skillIcon skillMass"></div>
		</div>

<input class="skillRank" type="text" name="attr_egoSkill4Rank" value="0" placeholder="0" data-i18n-title="rank" title="Rank">

	</div>

	<div class="rowContainer centerFlex skillE"> 

				<select name="attr_egoSkill4Type" class="whiteInput skillType" id="egoSkill4-type">
				    <option data-i18n="skill-type-None" value="None" selected>---</option>
                                    <option data-i18n="skill-type-Attack" value="Attack">Attack</option>
                                    <option data-i18n="skill-type-Defend" value="Defend">Defend</option>
                                    <option data-i18n="skill-type-Evade" value="Evade">Evade</option>
                                    <option data-i18n="skill-type-Action" value="Action">Action</option>
                                    <option data-i18n="skill-type-Mass" value="Mass">Mass</option>
                                </select>

		<div class="rollFormatBlock whiteInput" data-i18n-title="skill-dice-text" title="Dice modifiers applied when using skill">
		<input type="number" class="diceCount noSpinner" name="attr_egoSkill4Dice1" value="0">
		<div class="plainText">D</div>
		<input type="number" class="diceMax noSpinner" name="attr_egoSkill4Dice2" value="0">
		<div class="plainText">+</div>
		<input type="number" class="dicePower noSpinner" name="attr_egoSkill4Dice3" value="0">
		</div>
	

	<div class="lightCost">
				<input class="lightCostInput" type="text" name="attr_egoskill4Light" value="1" data-i18n-title="skill-light-cost" title="Light Cost">
	</div>

	</div>


	</div>
	<!-- header end -->


	<!-- Description/Effect section -->
	<div class="rowContainer weaponInfo">

        <div class="weaponDescription">
       <textarea spellcheck="false"  name="attr_egoSkill4Description" class="augmentDescriptionInput"data-i18n-placeholder="skill-desc" placeholder="Skill description."></textarea>
        </div>

        <div class="weaponEffect">
	<textarea spellcheck="false"  name="attr_egoSkill4Effect" class="weaponEffectInput" data-i18n-placeholder="skill-effect" placeholder="Skill effects."></textarea>
        </div>

	</div>
	<!-- desc end -->
	</div>
<!-- EGO Skill4 block - END -->


<!-- !!EXTRA!! EGO skills -->
<input type="checkbox" class="hide-toggle" name="attr_settingExtraEquip" value="true">
<div class="hide-item" style="width: 100%;">

<!-- EGO Skill5 block -->
	<div class="skillBlock">

	<!-- Item buttons -->
	<div class="itemButtons">
		<button type="action" class="darkInput shareButton share" id="share_egoSkill5" name="act_shareSkill" data-i18n-title="share" title="Share info"></button>
		<button type="action" class="darkInput autoScriptButton script" id="egoSkill5AutoScript" name="act_autoScriptEdit" data-i18n-title="autoscript-edit" title="Edit AutoScript"></button>
		<input type="text" name="attr_egoSkill5AutoScript" hidden="true">
	</div>

	<!-- header -->
	<div class="contentHeader skillE rowContainer">

	<input type="text" class="transpInput skillName" name="attr_egoSkill5Name" data-i18n-placeholder="skill-ego-name" placeholder="Mystery skill name">

<div class="iconHolder egoSkills">
		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="" name="attr_egoSkill5Type"><div class="type-image skillIcon skillNone"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Attack" name="attr_egoSkill5Type"><div class="type-image skillIcon skillAtt"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Defend" name="attr_egoSkill5Type"><div class="type-image skillIcon skillDef"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Evade" name="attr_egoSkill5Type"><div class="type-image skillIcon skillEvd"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Action" name="attr_egoSkill5Type"><div class="type-image skillIcon skillAct"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Mass" name="attr_egoSkill5Type"><div class="type-image skillIcon skillMass"></div>
		</div>

<input class="skillRank" type="text" name="attr_egoSkill5Rank" value="0" placeholder="0" data-i18n-title="rank" title="Rank">

	</div>

	<div class="rowContainer centerFlex skillE"> 

				<select name="attr_egoSkill5Type" class="whiteInput skillType" id="egoSkill5-type">
				    <option data-i18n="skill-type-None" value="None" selected>---</option>
                                    <option data-i18n="skill-type-Attack" value="Attack">Attack</option>
                                    <option data-i18n="skill-type-Defend" value="Defend">Defend</option>
                                    <option data-i18n="skill-type-Evade" value="Evade">Evade</option>
                                    <option data-i18n="skill-type-Action" value="Action">Action</option>
                                    <option data-i18n="skill-type-Mass" value="Mass">Mass</option>
                                </select>

		<div class="rollFormatBlock whiteInput" data-i18n-title="skill-dice-text" title="Dice modifiers applied when using skill">
		<input type="number" class="diceCount noSpinner" name="attr_egoSkill5Dice1" value="0">
		<div class="plainText">D</div>
		<input type="number" class="diceMax noSpinner" name="attr_egoSkill5Dice2" value="0">
		<div class="plainText">+</div>
		<input type="number" class="dicePower noSpinner" name="attr_egoSkill5Dice3" value="0">
		</div>
	

	<div class="lightCost">
				<input class="lightCostInput" type="text" name="attr_egoskill5Light" value="1" data-i18n-title="skill-light-cost" title="Light Cost">
	</div>

	</div>


	</div>
	<!-- header end -->


	<!-- Description/Effect section -->
	<div class="rowContainer weaponInfo">

        <div class="weaponDescription">
       <textarea spellcheck="false"  name="attr_egoSkill5Description" class="augmentDescriptionInput"data-i18n-placeholder="skill-desc" placeholder="Skill description."></textarea>
        </div>

        <div class="weaponEffect">
	<textarea spellcheck="false"  name="attr_egoSkill5Effect" class="weaponEffectInput" data-i18n-placeholder="skill-effect" placeholder="Skill effects."></textarea>
        </div>

	</div>
	<!-- desc end -->
	</div>
<!-- EGO Skill5 block - END -->

<!-- EGO Skill6 block -->
	<div class="skillBlock">

	<!-- Item buttons -->
	<div class="itemButtons">
		<button type="action" class="darkInput shareButton share" id="share_egoSkill6" name="act_shareSkill" data-i18n-title="share" title="Share info"></button>
		<button type="action" class="darkInput autoScriptButton script" id="egoSkill6AutoScript" name="act_autoScriptEdit" data-i18n-title="autoscript-edit" title="Edit AutoScript"></button>
		<input type="text" name="attr_egoSkill6AutoScript" hidden="true">
	</div>

	<!-- header -->
	<div class="contentHeader skillE rowContainer">

	<input type="text" class="transpInput skillName" name="attr_egoSkill6Name" data-i18n-placeholder="skill-ego-name" placeholder="Mystery skill name">

<div class="iconHolder egoSkills">
		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="" name="attr_egoSkill6Type"><div class="type-image skillIcon skillNone"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Attack" name="attr_egoSkill6Type"><div class="type-image skillIcon skillAtt"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Defend" name="attr_egoSkill6Type"><div class="type-image skillIcon skillDef"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Evade" name="attr_egoSkill6Type"><div class="type-image skillIcon skillEvd"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Action" name="attr_egoSkill6Type"><div class="type-image skillIcon skillAct"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Mass" name="attr_egoSkill6Type"><div class="type-image skillIcon skillMass"></div>
		</div>

<input class="skillRank" type="text" name="attr_egoSkill6Rank" value="0" placeholder="0" data-i18n-title="rank" title="Rank">

	</div>

	<div class="rowContainer centerFlex skillE"> 

				<select name="attr_egoSkill6Type" class="whiteInput skillType" id="egoSkill6-type">
				    <option data-i18n="skill-type-None" value="None" selected>---</option>
                                    <option data-i18n="skill-type-Attack" value="Attack">Attack</option>
                                    <option data-i18n="skill-type-Defend" value="Defend">Defend</option>
                                    <option data-i18n="skill-type-Evade" value="Evade">Evade</option>
                                    <option data-i18n="skill-type-Action" value="Action">Action</option>
                                    <option data-i18n="skill-type-Mass" value="Mass">Mass</option>
                                </select>

		<div class="rollFormatBlock whiteInput" data-i18n-title="skill-dice-text" title="Dice modifiers applied when using skill">
		<input type="number" class="diceCount noSpinner" name="attr_egoSkill6Dice1" value="0">
		<div class="plainText">D</div>
		<input type="number" class="diceMax noSpinner" name="attr_egoSkill6Dice2" value="0">
		<div class="plainText">+</div>
		<input type="number" class="dicePower noSpinner" name="attr_egoSkill6Dice3" value="0">
		</div>
	

	<div class="lightCost">
				<input class="lightCostInput" type="text" name="attr_egoskill6Light" value="1" data-i18n-title="skill-light-cost" title="Light Cost">
	</div>

	</div>


	</div>
	<!-- header end -->


	<!-- Description/Effect section -->
	<div class="rowContainer weaponInfo">

        <div class="weaponDescription">
       <textarea spellcheck="false"  name="attr_egoSkill6Description" class="augmentDescriptionInput"data-i18n-placeholder="skill-desc" placeholder="Skill description."></textarea>
        </div>

        <div class="weaponEffect">
	<textarea spellcheck="false"  name="attr_egoSkill6Effect" class="weaponEffectInput" data-i18n-placeholder="skill-effect" placeholder="Skill effects."></textarea>
        </div>

	</div>
	<!-- desc end -->
	</div>
<!-- EGO Skill6 block - END -->


</div>


<!-- !!EXTRA!! EGO skills - END -->

</div> 
<!-- EGO Skills Column END -->


<!-- Regular Skills column -->
            <div class="skillContainer">

	<!-- Skill1 block -->
	<div class="skillBlock">

	<!-- Item buttons -->
	<div class="itemButtons">
		<button type="action" class="darkInput shareButton share" id="share_skill1" name="act_shareSkill" data-i18n-title="share" title="Share info"></button>
		<button type="action" class="darkInput autoScriptButton script" id="skill1AutoScript" name="act_autoScriptEdit" data-i18n-title="autoscript-edit" title="Edit AutoScript"></button>
		<input type="text" name="attr_skill1AutoScript" hidden="true">
	</div>
	
	<!-- header -->
	<div class="contentHeader skillN rowContainer" style="position: relative;">

	<input type="text" class="transpInput skillName" name="attr_skill1Name" data-i18n-placeholder="skill-name" placeholder="Skill name">


<div class="iconHolder">

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="" name="attr_skill1Type"><div class="type-image skillIcon skillNone"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Attack" name="attr_skill1Type"><div class="type-image skillIcon skillAtt weapon"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Defend" name="attr_skill1Type"><div class="type-image skillIcon skillDef outfit"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Evade" name="attr_skill1Type"><div class="type-image skillIcon skillEvd STGR"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Action" name="attr_skill1Type"><div class="type-image skillIcon skillAct tool"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Mass" name="attr_skill1Type"><div class="type-image skillIcon skillMass weapon"></div>
		</div>

<input class="skillRank" type="text" name="attr_skill1Rank" value="0" placeholder="0" data-i18n-title="rank" title="Rank">


	</div>

	<div class="rowContainer centerFlex skillN"> 

				<select name="attr_skill1Type" class="whiteInput skillType">
				    <option data-i18n="skill-type-None" value="None" selected>---</option>
                                    <option data-i18n="skill-type-Attack" value="Attack">Attack</option>
                                    <option data-i18n="skill-type-Defend" value="Defend">Defend</option>
                                    <option data-i18n="skill-type-Evade" value="Evade">Evade</option>
                                    <option data-i18n="skill-type-Action" value="Action">Action</option>
                                    <option data-i18n="skill-type-Mass" value="Mass">Mass</option>
                                </select>

		<div class="rollFormatBlock whiteInput" data-i18n-title="skill-dice-text" title="Dice modifiers applied when using skill">
		<input type="number" class="diceCount noSpinner" name="attr_skill1Dice1" value="0">
		<div class="plainText">D</div>
		<input type="number" class="diceMax noSpinner" name="attr_skill1Dice2" value="0">
		<div class="plainText">+</div>
		<input type="number" class="dicePower noSpinner" name="attr_skill1Dice3" value="0">
		</div>
	

	<div class="lightCost">
				<input class="lightCostInput" type="text" name="attr_skill1Light" value="1" data-i18n-title="skill-light-cost" title="Light Cost">
	</div>

	</div>


	</div>
	<!-- header end -->


	<!-- Description/Effect section -->
	<div class="rowContainer weaponInfo">

        <div class="weaponDescription">
       <textarea spellcheck="false"  name="attr_skill1Description" class="augmentDescriptionInput"data-i18n-placeholder="skill-desc" placeholder="Skill description."></textarea>
        </div>

        <div class="weaponEffect">
	<textarea spellcheck="false"  name="attr_skill1Effect" class="weaponEffectInput" data-i18n-placeholder="skill-effect" placeholder="Skill effects."></textarea>
        </div>

	</div>
	<!-- desc end -->
	</div>
<!-- Skill1 block - END -->

	<!-- Skill2 block -->
	<div class="skillBlock">

	<!-- Item buttons -->
	<div class="itemButtons">
		<button type="action" class="darkInput shareButton share" id="share_skill2" name="act_shareSkill" data-i18n-title="share" title="Share info"></button>
		<button type="action" class="darkInput autoScriptButton script" id="skill2AutoScript" name="act_autoScriptEdit" data-i18n-title="autoscript-edit" title="Edit AutoScript"></button>
		<input type="text" name="attr_skill2AutoScript" hidden="true">
	</div>

	<!-- header -->
	<div class="contentHeader skillN rowContainer" style="position: relative;">

	<input type="text" class="transpInput skillName" name="attr_skill2Name" data-i18n-placeholder="skill-name" placeholder="Skill name">


<div class="iconHolder">

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="" name="attr_skill2Type"><div class="type-image skillIcon skillNone"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Attack" name="attr_skill2Type"><div class="type-image skillIcon skillAtt weapon"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Defend" name="attr_skill2Type"><div class="type-image skillIcon skillDef outfit"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Evade" name="attr_skill2Type"><div class="type-image skillIcon skillEvd STGR"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Action" name="attr_skill2Type"><div class="type-image skillIcon skillAct tool"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Mass" name="attr_skill2Type"><div class="type-image skillIcon skillMass weapon"></div>
		</div>

<input class="skillRank" type="text" name="attr_skill2Rank" value="0" placeholder="0" data-i18n-title="rank" title="Rank">


	</div>

	<div class="rowContainer centerFlex skillN"> 

				<select name="attr_skill2Type" class="whiteInput skillType">
				    <option data-i18n="skill-type-None" value="None" selected>---</option>
                                    <option data-i18n="skill-type-Attack" value="Attack">Attack</option>
                                    <option data-i18n="skill-type-Defend" value="Defend">Defend</option>
                                    <option data-i18n="skill-type-Evade" value="Evade">Evade</option>
                                    <option data-i18n="skill-type-Action" value="Action">Action</option>
                                    <option data-i18n="skill-type-Mass" value="Mass">Mass</option>
                                </select>

		<div class="rollFormatBlock whiteInput" data-i18n-title="skill-dice-text" title="Dice modifiers applied when using skill">
		<input type="number" class="diceCount noSpinner" name="attr_skill2Dice1" value="0">
		<div class="plainText">D</div>
		<input type="number" class="diceMax noSpinner" name="attr_skill2Dice2" value="0">
		<div class="plainText">+</div>
		<input type="number" class="dicePower noSpinner" name="attr_skill2Dice3" value="0">
		</div>
	

	<div class="lightCost">
				<input class="lightCostInput" type="text" name="attr_skill2Light" value="1" data-i18n-title="skill-light-cost" title="Light Cost">
	</div>

	</div>


	</div>
	<!-- header end -->


	<!-- Description/Effect section -->
	<div class="rowContainer weaponInfo">

        <div class="weaponDescription">
       <textarea spellcheck="false"  name="attr_skill2Description" class="augmentDescriptionInput"data-i18n-placeholder="skill-desc" placeholder="Skill description."></textarea>
        </div>

        <div class="weaponEffect">
	<textarea spellcheck="false"  name="attr_skill2Effect" class="weaponEffectInput" data-i18n-placeholder="skill-effect" placeholder="Skill effects."></textarea>
        </div>

	</div>
	<!-- desc end -->
	</div>
<!-- Skill2 block - END -->

<!-- Skill3 block -->
	<div class="skillBlock">

	<!-- Item buttons -->
	<div class="itemButtons">
		<button type="action" class="darkInput shareButton share" id="share_skill3" name="act_shareSkill" data-i18n-title="share" title="Share info"></button>
		<button type="action" class="darkInput autoScriptButton script" id="skill3AutoScript" name="act_autoScriptEdit" data-i18n-title="autoscript-edit" title="Edit AutoScript"></button>
		<input type="text" name="attr_skill3AutoScript" hidden="true">
	</div>

	<!-- header -->
	<div class="contentHeader skillN rowContainer" style="position: relative;">

	<input type="text" class="transpInput skillName" name="attr_skill3Name" data-i18n-placeholder="skill-name" placeholder="Skill name">


<div class="iconHolder">

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="" name="attr_skill3Type"><div class="type-image skillIcon skillNone"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Attack" name="attr_skill3Type"><div class="type-image skillIcon skillAtt weapon"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Defend" name="attr_skill3Type"><div class="type-image skillIcon skillDef outfit"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Evade" name="attr_skill3Type"><div class="type-image skillIcon skillEvd STGR"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Action" name="attr_skill3Type"><div class="type-image skillIcon skillAct tool"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Mass" name="attr_skill3Type"><div class="type-image skillIcon skillMass weapon"></div>
		</div>

<input class="skillRank" type="text" name="attr_skill3Rank" value="0" placeholder="0" data-i18n-title="rank" title="Rank">


	</div>

	<div class="rowContainer centerFlex skillN"> 

				<select name="attr_skill3Type" class="whiteInput skillType">
				    <option data-i18n="skill-type-None" value="None" selected>---</option>
                                    <option data-i18n="skill-type-Attack" value="Attack">Attack</option>
                                    <option data-i18n="skill-type-Defend" value="Defend">Defend</option>
                                    <option data-i18n="skill-type-Evade" value="Evade">Evade</option>
                                    <option data-i18n="skill-type-Action" value="Action">Action</option>
                                    <option data-i18n="skill-type-Mass" value="Mass">Mass</option>
                                </select>

		<div class="rollFormatBlock whiteInput" data-i18n-title="skill-dice-text" title="Dice modifiers applied when using skill">
		<input type="number" class="diceCount noSpinner" name="attr_skill3Dice1" value="0">
		<div class="plainText">D</div>
		<input type="number" class="diceMax noSpinner" name="attr_skill3Dice2" value="0">
		<div class="plainText">+</div>
		<input type="number" class="dicePower noSpinner" name="attr_skill3Dice3" value="0">
		</div>
	

	<div class="lightCost">
				<input class="lightCostInput" type="text" name="attr_skill3Light" value="1" data-i18n-title="skill-light-cost" title="Light Cost">
	</div>

	</div>


	</div>
	<!-- header end -->


	<!-- Description/Effect section -->
	<div class="rowContainer weaponInfo">

        <div class="weaponDescription">
       <textarea spellcheck="false"  name="attr_skill3Description" class="augmentDescriptionInput"data-i18n-placeholder="skill-desc" placeholder="Skill description."></textarea>
        </div>

        <div class="weaponEffect">
	<textarea spellcheck="false"  name="attr_skill3Effect" class="weaponEffectInput" data-i18n-placeholder="skill-effect" placeholder="Skill effects."></textarea>
        </div>

	</div>
	<!-- desc end -->
	</div>
<!-- Skill3 block - END -->

<!-- Skill4 block -->
	<div class="skillBlock">

	<!-- Item buttons -->
	<div class="itemButtons">
		<button type="action" class="darkInput shareButton share" id="share_skill4" name="act_shareSkill" data-i18n-title="share" title="Share info"></button>
		<button type="action" class="darkInput autoScriptButton script" id="skill4AutoScript" name="act_autoScriptEdit" data-i18n-title="autoscript-edit" title="Edit AutoScript"></button>
		<input type="text" name="attr_skill4AutoScript" hidden="true">
	</div>

	<!-- header -->
	<div class="contentHeader skillN rowContainer" style="position: relative;">

	<input type="text" class="transpInput skillName" name="attr_skill4Name" data-i18n-placeholder="skill-name" placeholder="Skill name">


<div class="iconHolder">

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="" name="attr_skill4Type"><div class="type-image skillIcon skillNone"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Attack" name="attr_skill4Type"><div class="type-image skillIcon skillAtt weapon"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Defend" name="attr_skill4Type"><div class="type-image skillIcon skillDef outfit"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Evade" name="attr_skill4Type"><div class="type-image skillIcon skillEvd STGR"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Action" name="attr_skill4Type"><div class="type-image skillIcon skillAct tool"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Mass" name="attr_skill4Type"><div class="type-image skillIcon skillMass weapon"></div>
		</div>

<input class="skillRank" type="text" name="attr_skill4Rank" value="0" placeholder="0" data-i18n-title="rank" title="Rank">


	</div>

	<div class="rowContainer centerFlex skillN"> 

				<select name="attr_skill4Type" class="whiteInput skillType">
				    <option data-i18n="skill-type-None" value="None" selected>---</option>
                                    <option data-i18n="skill-type-Attack" value="Attack">Attack</option>
                                    <option data-i18n="skill-type-Defend" value="Defend">Defend</option>
                                    <option data-i18n="skill-type-Evade" value="Evade">Evade</option>
                                    <option data-i18n="skill-type-Action" value="Action">Action</option>
                                    <option data-i18n="skill-type-Mass" value="Mass">Mass</option>
                                </select>

		<div class="rollFormatBlock whiteInput" data-i18n-title="skill-dice-text" title="Dice modifiers applied when using skill">
		<input type="number" class="diceCount noSpinner" name="attr_skill4Dice1" value="0">
		<div class="plainText">D</div>
		<input type="number" class="diceMax noSpinner" name="attr_skill4Dice2" value="0">
		<div class="plainText">+</div>
		<input type="number" class="dicePower noSpinner" name="attr_skill4Dice3" value="0">
		</div>
	

	<div class="lightCost">
				<input class="lightCostInput" type="text" name="attr_skill4Light" value="1" data-i18n-title="skill-light-cost" title="Light Cost">
	</div>

	</div>


	</div>
	<!-- header end -->


	<!-- Description/Effect section -->
	<div class="rowContainer weaponInfo">

        <div class="weaponDescription">
       <textarea spellcheck="false"  name="attr_skill4Description" class="augmentDescriptionInput"data-i18n-placeholder="skill-desc" placeholder="Skill description."></textarea>
        </div>

        <div class="weaponEffect">
	<textarea spellcheck="false"  name="attr_skill4Effect" class="weaponEffectInput" data-i18n-placeholder="skill-effect" placeholder="Skill effects."></textarea>
        </div>

	</div>
	<!-- desc end -->
	</div>
<!-- Skill4 block - END -->


<!-- !!EXTRA!! Regular Skills -->
<input type="checkbox" class="hide-toggle" name="attr_settingExtraEquip" value="true">
<div class="hide-item" style="width: 100%;">

<!-- Skill5 block -->
	<div class="skillBlock">

	<!-- Item buttons -->
	<div class="itemButtons">
		<button type="action" class="darkInput shareButton share" id="share_skill5" name="act_shareSkill" data-i18n-title="share" title="Share info"></button>
		<button type="action" class="darkInput autoScriptButton script" id="skill5AutoScript" name="act_autoScriptEdit" data-i18n-title="autoscript-edit" title="Edit AutoScript"></button>
		<input type="text" name="attr_skill5AutoScript" hidden="true">
	</div>

	<!-- header -->
	<div class="contentHeader skillN rowContainer" style="position: relative;">

	<input type="text" class="transpInput skillName" name="attr_skill5Name" data-i18n-placeholder="skill-name" placeholder="Skill name">


<div class="iconHolder">

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="" name="attr_skill5Type"><div class="type-image skillIcon skillNone"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Attack" name="attr_skill5Type"><div class="type-image skillIcon skillAtt weapon"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Defend" name="attr_skill5Type"><div class="type-image skillIcon skillDef outfit"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Evade" name="attr_skill5Type"><div class="type-image skillIcon skillEvd STGR"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Action" name="attr_skill5Type"><div class="type-image skillIcon skillAct tool"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Mass" name="attr_skill5Type"><div class="type-image skillIcon skillMass weapon"></div>
		</div>

<input class="skillRank" type="text" name="attr_skill5Rank" value="0" placeholder="0" data-i18n-title="rank" title="Rank">


	</div>

	<div class="rowContainer centerFlex skillN"> 

				<select name="attr_skill5Type" class="whiteInput skillType">
				    <option data-i18n="skill-type-None" value="None" selected>---</option>
                                    <option data-i18n="skill-type-Attack" value="Attack">Attack</option>
                                    <option data-i18n="skill-type-Defend" value="Defend">Defend</option>
                                    <option data-i18n="skill-type-Evade" value="Evade">Evade</option>
                                    <option data-i18n="skill-type-Action" value="Action">Action</option>
                                    <option data-i18n="skill-type-Mass" value="Mass">Mass</option>
                                </select>

		<div class="rollFormatBlock whiteInput" data-i18n-title="skill-dice-text" title="Dice modifiers applied when using skill">
		<input type="number" class="diceCount noSpinner" name="attr_skill5Dice1" value="0">
		<div class="plainText">D</div>
		<input type="number" class="diceMax noSpinner" name="attr_skill5Dice2" value="0">
		<div class="plainText">+</div>
		<input type="number" class="dicePower noSpinner" name="attr_skill5Dice3" value="0">
		</div>
	

	<div class="lightCost">
				<input class="lightCostInput" type="text" name="attr_skill5Light" value="1" data-i18n-title="skill-light-cost" title="Light Cost">
	</div>

	</div>


	</div>
	<!-- header end -->


	<!-- Description/Effect section -->
	<div class="rowContainer weaponInfo">

        <div class="weaponDescription">
       <textarea spellcheck="false"  name="attr_skill5Description" class="augmentDescriptionInput"data-i18n-placeholder="skill-desc" placeholder="Skill description."></textarea>
        </div>

        <div class="weaponEffect">
	<textarea spellcheck="false"  name="attr_skill5Effect" class="weaponEffectInput" data-i18n-placeholder="skill-effect" placeholder="Skill effects."></textarea>
        </div>

	</div>
	<!-- desc end -->
	</div>
<!-- Skill5 block - END -->

<!-- Skill6 block -->
	<div class="skillBlock">
		
	<!-- Item buttons -->
	<div class="itemButtons">
		<button type="action" class="darkInput shareButton share" id="share_skill6" name="act_shareSkill" data-i18n-title="share" title="Share info"></button>
		<button type="action" class="darkInput autoScriptButton script" id="skill6AutoScript" name="act_autoScriptEdit" data-i18n-title="autoscript-edit" title="Edit AutoScript"></button>
		<input type="text" name="attr_skill6AutoScript" hidden="true">
	</div>

	<!-- header -->
	<div class="contentHeader skillN rowContainer" style="position: relative;">

	<input type="text" class="transpInput skillName" name="attr_skill6Name" data-i18n-placeholder="skill-name" placeholder="Skill name">

	<div class="iconHolder">
		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="" name="attr_skill6Type"><div class="type-image skillIcon skillNone"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Attack" name="attr_skill6Type"><div class="type-image skillIcon skillAtt weapon"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Defend" name="attr_skill6Type"><div class="type-image skillIcon skillDef outfit"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Evade" name="attr_skill6Type"><div class="type-image skillIcon skillEvd STGR"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Action" name="attr_skill6Type"><div class="type-image skillIcon skillAct tool"></div>
		</div>

		<div class="icon">
		<input type="checkbox" class="expand-toggle" value="Mass" name="attr_skill6Type"><div class="type-image skillIcon skillMass weapon"></div>
		</div>

		<input class="skillRank" type="text" name="attr_skill6Rank" value="0" placeholder="0" data-i18n-title="rank" title="Rank">
	</div>

	<div class="rowContainer centerFlex skillN"> 
		<select name="attr_skill6Type" class="whiteInput skillType">
			<option data-i18n="skill-type-None" value="None" selected>---</option>
			<option data-i18n="skill-type-Attack" value="Attack">Attack</option>
			<option data-i18n="skill-type-Defend" value="Defend">Defend</option>
			<option data-i18n="skill-type-Evade" value="Evade">Evade</option>
			<option data-i18n="skill-type-Action" value="Action">Action</option>
			<option data-i18n="skill-type-Mass" value="Mass">Mass</option>
		</select>

		<div class="rollFormatBlock whiteInput" data-i18n-title="skill-dice-text" title="Dice modifiers applied when using skill">
			<input type="number" class="diceCount noSpinner" name="attr_skill6Dice1" value="0">
			<div class="plainText">D</div>
			<input type="number" class="diceMax noSpinner" name="attr_skill6Dice2" value="0">
			<div class="plainText">+</div>
			<input type="number" class="dicePower noSpinner" name="attr_skill6Dice3" value="0">
		</div>
		
		<div class="lightCost">
			<input class="lightCostInput" type="text" name="attr_skill6Light" value="1" data-i18n-title="skill-light-cost" title="Light Cost">
		</div>
	</div>


	</div>
	<!-- header end -->


	<!-- Description/Effect section -->
	<div class="rowContainer weaponInfo">

        <div class="weaponDescription">
       <textarea spellcheck="false"  name="attr_skill6Description" class="augmentDescriptionInput"data-i18n-placeholder="skill-desc" placeholder="Skill description."></textarea>
        </div>

        <div class="weaponEffect">
	<textarea spellcheck="false"  name="attr_skill6Effect" class="weaponEffectInput" data-i18n-placeholder="skill-effect" placeholder="Skill effects."></textarea>
        </div>

	</div>
	<!-- desc end -->
	</div>
<!-- Skill6 block - END -->


</div>


<!-- !!EXTRA!! Regular Skills - END -->


</div> 
<!-- Regular Skills - END -->






</div> <!-- outside of green line -->
  
              </div></div></div></div>
<!-- Skill section END -->


<!-- Character Details -->
	<div class="sheet-body sheet-details darkBG">
	<div class="contentContainer" id="characterDetails">

<div class="profileHeader" style="top: 12px; right: 10px; left: auto;">
<input type="checkbox" id="attr_distortState" name="attr_distortState" value="true"><label for="attr_distortState" class="centerIcon distortIcon" data-i18n-title="distort-toggleText" title="Distort"></label>
</div>

<!-- Normal profile -->
<input type="checkbox" class="hide-toggle-rev" name="attr_distortState" value="true">
<div class="hide-item-rev" style="width: 100%;">
<div class="rowContainer" style="padding-top: 5px;">
<div class="half" style="position: relative;">

	<div class="CharImage"><img name="attr_character_avatar">
	<div class="CharImageText" data-i18n="character-photo">Photo</div></div>

	<div class="profileData">
	<div class="textSection" data-i18n="character-name-text">Name</div>
	<input class="CharSmallNotes" type="text" name="attr_character_nameBase"></div>

	<div class="profileData">
	<div class="textSection" data-i18n="character-job">Occupation</div>
	<input class="CharSmallNotes" type="text" name="attr_character_job"></div>
               
	<div class="profileData">
	<div class="textSection" data-i18n="character-age">Age</div>
	<input class="CharSmallNotes" type="text" name="attr_age"></div>

	<div class="profileData">
	<div class="textSection" data-i18n="character-height">Height</div>
	<input class="CharSmallNotes" type="text" name="attr_height"></div>

	<div class="profileData">
	<div class="textSection" data-i18n="character-origin">Birthplace</div>
	<input class="CharSmallNotes" type="text" name="attr_character_origin"></div>

	<div class="profileData">
	<div class="textSection" data-i18n="character-residence">Residence</div>
	<input class="CharSmallNotes" type="text" name="attr_character_residence"></div>

	<div class="profileData" style="position: relative;">
	<div class="textSection" data-i18n="character-assets">Assets</div>
	<input class="CharSmallNotes" type="text" name="attr_character_assets" data-i18n-placeholder="character-assets-placeholder" placeholder="Money, items, other assets.">


<input class="CharDetail" type="text" name="attr_character_ahn" placeholder="500,000 ahn" data-i18n-placeholder="character-ahn-placeholder" style="width: 154px !important; position: absolute; right: 2px; top: 0px;">

</div>

	<div class="profileData">
	<div class="textSection" data-i18n="character-summary">Summary</div>
	<textarea spellcheck="false"  name="attr_character_summary" data-i18n-placeholder="character-summary-placeholder" class="CharMediumNotes" placeholder="General character summary."></textarea></div>

	<div class="profileData">
	<div class="textSection" data-i18n="character-history">Notable History</div>
	<textarea spellcheck="false"  name="attr_character_history" class="CharMediumNotes" data-i18n-placeholder="character-history-placeholder" placeholder="Recent or past history."></textarea>
	</div>

	<div class="profileData">
	<div class="textSection" data-i18n="character-relations">Relations</div>
	<textarea spellcheck="false"  name="attr_character_relations" class="CharMediumNotes" data-i18n-placeholder="character-relations-placeholder" placeholder="Relations with others."></textarea>
	</div>

	<div class="profileData">
	<div class="textSection" data-i18n="character-notes">Notes</div>
	<textarea spellcheck="false"  name="attr_character_notes" class="CharMediumNotes" data-i18n-placeholder="character-notes-placeholder" placeholder="Any other notes."></textarea>
	</div>

</div>


<div class="columnAlign half centerFlex" id="CharExtra">

	<div class="profileData">
	<div class="textSection" style="width: 50px !important;">URL</div>
	<input type="text" class="CharDetail" name="attr_character_url" data-i18n-placeholder="character-url-placeholder" placeholder="External sheet/reference" style="max-width: 300px;"></div>

<div class="textSection" data-i18n="character-desc">Description</div>
<div class="CharBigNotes">
<textarea spellcheck="false" name="attr_character_desc" data-i18n-placeholder="character-desc-placeholder" placeholder="Physical description."></textarea></div>


<div class="textSection" data-i18n="character-personality">Personality</div>
<div class="CharBigNotes">
<textarea spellcheck="false" name="attr_character_personality" data-i18n-placeholder="character-personality-placeholder" placeholder="Personality description."></textarea></div>


<div class="textSection" data-i18n="character-background">Background</div>
<div class="CharBigNotes">
<textarea spellcheck="false" name="attr_character_background" data-i18n-placeholder="character-background-placeholder" placeholder="Background description."></textarea></div>

</div>
</div>
</div>

<!-- Distortion profile -->
<input type="checkbox" class="hide-toggle" name="attr_distortState" value="true">
<div class="hide-item" style="width: 100%;">
<div class="rowContainer distortProfile" style="padding-top: 5px;">
<div class="half" style="position: relative;">

	<div class="CharImage"><img name="attr_character_avatar">
	<div class="CharImageText" data-i18n="character-photo">Photo</div></div>

	<div class="profileData">
	<div class="textSection" data-i18n="character-name-text">Name</div>
	<input class="whiteInput" type="text" name="attr_distort_name"></div>

	<div class="profileData">
	<div class="textSection" data-i18n="character-job">Occupation</div>
	<input class="whiteInput" type="text" name="attr_character_job"></div>
               
	<div class="profileData">
	<div class="textSection" data-i18n="character-age">Age</div>
	<input class="whiteInput" type="text" name="attr_age"></div>

	<div class="profileData">
	<div class="textSection" data-i18n="character-height">Height</div>
	<input class="whiteInput" type="text" name="attr_height"></div>

	<div class="profileData">
	<div class="textSection" data-i18n="character-origin">Birthplace</div>
	<input class="whiteInput" type="text" name="attr_character_origin"></div>

	<div class="profileData">
	<div class="textSection" data-i18n="character-residence">Residence</div>
	<input class="whiteInput" type="text" name="attr_character_residence"></div>

	<div class="profileData">
	<div class="textSection" data-i18n="distort-origin">Origin</div>
	<input class="CharDetail whiteInput" data-i18n-placeholder="distort-origin-placeholder" placeholder="Origin of Distortion." type="text" name="attr_distort_origin"></div>

	<div class="profileData">
	<div class="textSection" data-i18n="distort-summary">Summary</div>
	<textarea spellcheck="false"  name="attr_distort_summary" data-i18n-placeholder="distort-summary-placeholder" class="CharMediumNotes whiteInput" placeholder="General summary of Distortion."></textarea></div>

	<div class="profileData">
	<div class="textSection" data-i18n="distort-behavior">Behavior</div>
	<textarea spellcheck="false"  name="attr_distort_behavior" class="CharMediumNotes whiteInput" data-i18n-placeholder="distort-behavior-placeholder" placeholder="Notes on Distortion behaviour."></textarea>
	</div>

	<div class="profileData">
	<div class="textSection" data-i18n="distort-taboo">Taboos/Boons</div>
	<textarea spellcheck="false"  name="attr_distort_taboo" class="CharMediumNotes whiteInput" data-i18n-placeholder="distort-taboo-placeholder" placeholder="Distortion taboos."></textarea>
	</div>

	<div class="profileData">
	<div class="textSection" data-i18n="character-notes">Notes</div>
	<textarea spellcheck="false"  name="attr_distort_notes" class="CharMediumNotes whiteInput" data-i18n-placeholder="distort-notes-placeholder" placeholder="Other Distortion notes."></textarea>
	</div>


</div>


<div class="columnAlign half centerFlex" id="distortExtra">

	<div class="profileData">
	<div class="textSection" style="width: 50px !important;">URL</div>
	<input type="text" class="CharDetail whiteInput" name="attr_distort_url" data-i18n-placeholder="character-url-placeholder" placeholder="External sheet/reference" style="max-width: 300px;"></div>

<div class="textSection" data-i18n="distort-appearance">Appearance</div>
<div class="CharBigNotes">
<textarea spellcheck="false" class="whiteInput" name="attr_distort_appearance" data-i18n-placeholder="distort-appearance-placeholder" placeholder="Appearance of Distortion."></textarea></div>

<div class="textSection" data-i18n="distort-atmosphere">Atmosphere</div>
<div class="CharBigNotes">
<textarea spellcheck="false" class="whiteInput" name="attr_distort_atmosphere" data-i18n-placeholder="distort-atmosphere-placeholder" placeholder="Atmosphere of Distortion."></textarea></div>

<div class="textSection" data-i18n="distort-story">Story</div>
<div class="CharBigNotes">
<textarea spellcheck="false" class="whiteInput" name="attr_distort_story" data-i18n-placeholder="distort-story-placeholder" placeholder="Story of Distortion."></textarea></div>

</div>
</div>

<!-- distortion details end -->



</div>
</div>
</div>

<!-- Details END -->

<!-- Sheet Editor -->
<div class="sheet-body sheet-export darkBG">
<div class="contentContainer" id="sheetExport">
	<div class="rowContainer centerFlex">
		<button type="action" class="declare" name="act_clearButton" id="clear_editorOutput" data-i18n-title="reset-button" title="Reset" style="position: absolute; left: 0;">x</button>

		<select name="attr_exportType" class="darkInput exportSelect" style="width: 200px !important; position: absolute; left: 90px; margin-bottom: 0px;">
			<option data-i18n="export-type-All" value="All">All</option>
			<option data-i18n="export-type-Equip" value="Equip">Equipment</option>
			<option data-i18n="export-type-Skill" value="Skills">Skills</option>
			<option data-i18n="export-type-Ego" value="Ego">E.G.O</option>
			<option data-i18n="export-type-Distort" value="Distort">Distortion</option>
			<option data-i18n="export-type-Character" value="Character">Character details</option>
			<option data-i18n="export-type-Settings" value="Settings">Settings</option>
		</select>

		<button type="action" class="declare" name="act_export" data-i18n="message-export">Export</button>
		<button type="action" class="declare" name="act_swap" title="Swap" style="font-size: 14pt; margin-left: 5px; margin-right: 5px;"></button>
		<button type="action" class="declare" name="act_import" data-i18n="message-import">Import</button>
		<button type="action" class="declare" name="act_clearButton" data-i18n-title="reset-button" title="Reset" id="clear_editorInput" style="position: absolute; right: 0;">x</button>
	</div>

	<div class="rowContainer">
	<textarea spellcheck="false" name="attr_editorOutput" data-il18n-placeholder="editor-outputText" placeholder="Editor output"></textarea>
	<textarea spellcheck="false" name="attr_editorInput" data-il18n-placeholder="editor-inputText" placeholder="Editor input"></textarea>
	</div>
</div>
</div>


<!-- Sheet Editor -->
	<div class="sheet-body sheet-edit darkBG">

<input type="text" name="attr_global_editKey" hidden="true">
<div class="rowContainer centerFlex">
<input type="checkbox" class="hide-toggle" name="attr_global_accessCheck" value="0" hidden="true">
<div class="hide-item" style="width: 200px; height: 250px; text-align: center;">
<h4 data-il18n-placeholder="editor-pw">Edit Mode Password</h4>
<input type="text" class="darkInput" name="attr_global_access">
</div>
</div>

	<div class="contentContainer" id="sheetSettings">

<input type="checkbox" class="hide-toggle-rev" name="attr_global_accessCheck" value="0" hidden="true">
<div class="hide-item-rev rowContainer">


<!-- Game Setting Section -->
<div style="width: 100%;"><h3>
<input type="checkbox" class="switch-toggle" name="attr_syncLockGame" value="true" hidden="true">
<button type="action" class="lockButton largeIcon" id="lock_Game" name="act_lockSection"></button>

<div>
<input type="checkbox" class="hide-toggle" name="attr_syncStateGame" value="true">
<div class="hide-item syncIcon"></div>
</div>

<span data-i18n="editor-gamesettings">Game Settings</span> 

<label for="hideGameSettings" class="arrowholder"><input type="checkbox" class="switch-toggle" id="hideGameSettings" name="attr_hideGameSettings" value="true" style="display: none;"><div class="arrow"></div></label></h3>

<input type="checkbox" class="hide-toggle-rev" name="attr_hideGameSettings" value="true" hidden="true">
<div class="hide-item-rev" style="width: 100%;">

<div class="rowContainer centerFlex">
	<textarea spellcheck="false" name="attr_gameEditor" data-i18n-placeholder="editor-gamesettings-textedit" placeholder="Game Settings output"></textarea>
</div>
<div class="rowContainer">
<button type="action" name="act_resetGlobal" data-i18n="clear-button" class="btn">Clear</button>
<button type="action" name="act_syncGlobal" data-i18n="sync-button" class="btn">Sync Data</button>
<button type="action" name="act_exportGlobal" data-i18n="message-export" class="btn">Export</button>
<button type="action" name="act_importGlobal" data-i18n="message-import" class="btn">Import</button>
</div>


<!-- Obscured -->
<div id="globalSettings">
<fieldset class="repeating_global">

<input type="text" name="attr_editKey" hidden="true">
<textarea name="attr_gameSettingSource" hidden="true"></textarea>
<textarea name="attr_ailmentSettingSource" hidden="true"></textarea>
<textarea name="attr_generalSettingSource" hidden="true"></textarea>

<div class="rowContainer">

<!-- General settings -->
<div style="text-align: left; padding: 10px;">

<div>
<div class="settingStyle">
<div style="width: 100px">
<b data-i18n="editor-rulename">Ruleset Name</b>:</div> <input type="text" style="input" name="attr_ruleName" data-i18n="editor-rulename-placeholder" value="Original Rulebook (Default)">
</div>

<!-- Character level -->
<div class="settingStyle"><div style="width: 100px">
<b data-i18n="character-level">Level</b>:</div> <input type="number" name="attr_expCalc" value="8"> <span data-i18n="character-exp">EXP</span>
</div>

<!-- Character status bars -->
<div class="settingStyle">
<div style="width: 100px">
<b data-i18n="bar-health">Health</b>:</div> <input type="number" name="attr_healthBase" value="30">
+ (<select type="text" name="attr_healthStat" value="Instinct" style="width: 80px;">
	<option value="Instinct" data-i18n="stats-instinct">Fortitude</option>
	<option value="InstinctTemperance" data-i18n="editor-instinct-temperance">(Fortitude + Temperance)/2</option>
</select> *
	<input type="number" name="attr_healthStatMod" value="6">
) + (
	<span data-i18n="rank">Rank</span> *
	<input type="number" name="attr_healthRankMod" value="6">
)
</div>

<div class="settingStyle"><div style="width: 100px">
<b data-i18n="bar-stagres">Stagger Res</b>:</div> <input type="number" name="attr_staggerBase" value="20">
+ (
	<select type="text" name="attr_staggerStat" value="Charm" style="width: 80px;">
<option value="Charm" data-i18n="stats-charm">Charm</option>
<option value="CharmJustice" data-i18n="editor-charm-justice">(Charm + Justice)/2</option>
	</select> *  
 	<input type="number" name="attr_staggerStatMod" value="4">
) + (
	<span data-i18n="rank">Rank</span> *
	<input type="number" name="attr_staggerRankMod" value="4">
)
</div>

<div class="settingStyle"><div style="width: 100px">
<b data-i18n="bar-sanity">Sanity</b>:</div> <input type="number" name="attr_sanityBase" value="15">
+ (
	<select type="text" name="attr_sanityStat" value="Wisdom" style="width: 80px;">
<option value="Wisdom" data-i18n="stats-wisdom">Prudence</option>
<option value="WisdomInsight" data-i18n="editor-wisdom-insight">(Prudence + Insight)/2</option>
	</select> * 
	<input type="number" name="attr_sanityStatMod" value="3">
) + (
	<span data-i18n="rank">Rank</span> *
	<input type="number" name="attr_sanityRankMod" value="0">
)
</div>

<div class="settingStyle"><div style="width: 100px">
<b data-i18n="bar-light">Light</b>:</div> <input type="number" name="attr_lightBase" value="3">
 + (<span data-i18n="rank">Rank</span> * <input type="number" name="attr_lightRankMod" value="1">)
</div>

<div class="settingStyle"><div style="width: 100px">
<b data-i18n="editor-distortlight">Distort Light</b>:</div> <input type="number" name="attr_distortLightBase" value="5">
 + (<span data-i18n="rank">Rank</span> * <input type="number" name="attr_distortLightRankMod" value="1">)
</div>

<div class="settingStyle"><div style="width: 100px; height: 28px;">
<b data-i18n="editor-lightregen-cap">Light regen Cap</b>:</div> <input type="number" name="attr_lightRegenBase" value="3">
 + (<span data-i18n="rank">Rank</span> * <input type="number" name="attr_lightRegenRankMod" value="1">)
 + (<span data-i18n="stats-wisdom">Prudence</span> * <input type="number" name="attr_lightRegenStatMod" value="0">)
</div>

<div class="settingStyle"><div style="min-width: 100px; max-width: 100px;">
<b data-i18n="editor-lightregen-sources">Light regen Sources</b>:
</div><div class="settingStyle" style="flex-wrap: wrap; width: 320px;">
<div><input type="number" name="attr_lightRegenStaggerSelf" value="0"><span data-i18n="ego-active-OnStagger">On stagger</span>,&nbsp;</div>
<div><input type="number" name="attr_lightRegenStaggerEnemy" value="0"><span data-i18n="editor-lightregen-stagger-enemy">Enemy stagger</span>,&nbsp;</div>
<div><input type="number" name="attr_lightRegenDefeatEnemy" value="0"><span data-i18n="ego-active-EnemyDefeat">Enemy defeat</span>,&nbsp;</div>
<div><input type="number" name="attr_lightRegenRoundEnd" value="0"><span data-i18n="editor-lightregen-round-end">Round end</span></div>
</div></div>

<!-- Recover calculation -->
<div class="settingStyle"><div style="min-width: 100px; max-width: 100px;">
<b data-i18n="editor-combat-end-stagger">Combat end Stagger</b>:</div>
<select name="attr_combatEndStaggerMode" style="width: 40px;">
	<option value="+" selected>+</option>
	<option value="x">x</option>
	<option value="=">=</option>
</select>
<input type="text" name="attr_combatEndStaggerVal" style="width: 40px;" value="0">
</div>

<div class="settingStyle"><div style="min-width: 100px; max-width: 100px;">
<b data-i18n="editor-combat-end-light">Combat end Light</b>:</div> <input type="number" name="attr_combatEndLightBase" value="0">
+ (<span data-i18n="rank">Rank</span> * <input type="number" name="attr_combatEndLightRankMod" value="0">)
</div>

<div class="settingStyle"><div style="min-width: 100px; max-width: 100px;">
<b data-i18n="editor-recover-health">Recover Health</b>:</div> <input type="number" name="attr_recoverHPBase" value="8">
+ (<select type="text" name="attr_healthStat" value="Instinct" style="width: 80px;">
	<option value="Instinct" data-i18n="stats-instinct">Fortitude</option>
	<option value="InstinctTemperance" data-i18n="editor-instinct-temperance">(Fortitude + Temperance)/2</option>
</select>
* <input type="number" name="attr_recoverHPStatMod" value="2">)
+ (<span data-i18n="rank">Rank</span> * <input type="number" name="attr_recoverHPRankMod" value="2">)
</div>

<div class="settingStyle"><div style="min-width: 100px; max-width: 100px;">
<b data-i18n="editor-recover-sanity">Recover Sanity</b>:</div> <input type="number" name="attr_recoverSPBase" value="3">
+ (<select type="text" name="attr_sanityStat" value="Wisdom" style="width: 80px;">
	<option value="Wisdom" data-i18n="stats-wisdom">Prudence</option>
	<option value="WisdomInsight" data-i18n="editor-wisdom-insight">(Prudence + Insight)/2</option>
</select>
* <input type="number" name="attr_recoverSPStatMod" value="1">)
+ (<span data-i18n="rank">Rank</span> * <input type="number" name="attr_recoverSPRankMod" value="0">)
</div>

<div class="settingStyle"><div style="min-width: 100px; max-width: 100px;">
<b data-i18n="editor-recover-stagger">Recover Stagger Res</b>:</div>
<select name="attr_recoverStaggerMode" style="width: 40px;">
	<option value="+" selected>+</option>
	<option value="x">x</option>
	<option value="=">=</option>
</select>
<input type="text" name="attr_recoverStaggerVal" style="width: 40px;" value="0">
</div>

<div class="settingStyle"><div style="min-width: 100px; max-width: 100px;">
<b data-i18n="editor-recover-light">Recover Light</b>:</div> <input type="number" name="attr_recoverLightBase" value="1">
+ (<span data-i18n="rank">Rank</span> * <input type="number" name="attr_recoverLightRankMod" value="0">)
</div>

<!-- Attack power -->
<div class="settingStyle">
	<div style="width: 100px"><b data-i18n="helper-att-power">Att Power</b>:</div>
	<select type="text" name="attr_attStat" value="Instinct" style="width: 120px;">
<option value="Instinct" data-i18n="stats-instinct">Fortitude</option>
<option value="Rank" data-i18n="rank">Rank</option>
<option value="InstinctRank" data-i18n="editor-instinct-rank">Fortitude + Rank</option>
<option value="InstinctWisdom" data-i18n="editor-instinct-wisdom">(Fortitude + Prudence)/2</option>
</select>
+ <span data-i18n="ailments-strength">Strength</span> / <span data-i18n="ailments-feeble">Feeble</span>
</div>

<!-- Defence power -->
<div class="settingStyle">
	<div style="width: 100px"><b data-i18n="helper-def-power">Def Power</b>:</div>
	<select type="text" name="attr_defStat" value="Temperance" style="width: 120px;">
<option value="Temperance" data-i18n="stats-temperance">Temperance</option>
<option value="Rank" data-i18n="rank">Rank</option>
<option value="TemperanceRank" data-i18n="editor-temperance-rank">Temperance + Rank</option>
<option value="TemperanceCharm" data-i18n="editor-temperance-charm">(Temperance + Charm)/2</option>
</select>
+ <span data-i18n="ailments-endurance">Endurance</span> / <span data-i18n="ailments-disarm">Disarm</span>
</div>

<!-- Evade power -->
<div class="settingStyle">
	<div style="width: 100px"><b data-i18n="helper-evd-power">Evd Power</b>:</div>
	<select type="text" name="attr_evdStat" value="Insight" style="width: 120px;">
<option value="Insight" data-i18n="stats-insight">Insight</option>
<option value="Rank" data-i18n="rank">Rank</option>
<option value="InsightRank" data-i18n="editor-insight-rank">Insight + Rank</option>
<option value="InsightJustice" data-i18n="editor-insight-justice">(Insight + Justice)/2</option>
	</select>
	+
<select type="text" name="attr_evdAilment" class="transpInput" style="width: 135px; text-align: left;">
<option value="EnduranceDisarm" data-i18n="editor-endurance-disarm">Endurance/Disarm</option>
<option value="HasteBind" data-i18n="editor-haste-bind">Haste/Bind</option>
</select>
</div>

<!-- Multihit penalty -->
<div class="settingStyle"><div style="width: 100px">
<b data-i18n="editor-multihit-penalty">Multi-hit Penalty</b>:</div> <input type="number" name="attr_multiPenalty" value="-2">
<select type="text" class="transpInput" name="attr_multiStyle" style="width: 90px;">
	<option data-i18n="editor-nattacks" value="n" selected>x n Attacks</option>
	<option data-i18n="editor-flat" value="Flat">Flat</option>
</select>
</div>


<!-- Actions and reactions -->
<div class="settingStyle"><div style="width: 100px">
<b data-i18n="editor-actions">Actions</b>:</div> <input type="number" name="attr_actionBase" value="1">
 + (<span data-i18n="rank">Rank</span> * <input type="number" name="attr_actionRankMod" value="0">)
</div>

<div class="settingStyle"><div style="width: 100px">
<b data-i18n="editor-reactions">Reactions</b>:</div> <input type="number" name="attr_reactionBase" value="2">
 + (<span data-i18n="rank">Rank</span> * <input type="number" name="attr_reactionRankMod" value="0">)
</div>

<div class="settingStyle"><div style="width: 100px">
<b data-i18n="editor-use-action-for-reaction">Can use actions for reactions?</b>:</div>
<select type="text" class="transpInput" name="attr_actionTradeReaction" style="width: 90px;">
	<option data-i18n="true" value="true">True</option>
	<option data-i18n="false" value="0" selected>False</option>
</select>
</div>

</div>
</div>
<!-- General settings end -->

<!-- Default ailments -->
<input type="checkbox" value="true" name="attr_iconStyle" hidden="true" checked>
<div>
<label for="LimbusStyleInternal">
	<input type="checkbox" id="LimbusStyleInternal" name="attr_iconStyle" value="true"><span data-i18n="settings-limbusstyle">Limbus style ailment icons</span>
</label>

<div class="settingStyle columnAlign centerFlex">

<!-- Stagger -->
<div class="rowContainer repitemMock" style="width: 250px;">
	<div class="ailmentIconSelector rowContainer centerFlex">
	<div class="icon">
	<input type="checkbox" class="hide-toggle-rev" value="true" name="attr_iconStyle"><div class="hide-item-rev skillIcon stagger"></div>
	</div>
	<div class="icon">
	<input type="checkbox" class="expand-toggle" value="true" name="attr_iconStyle"><div class="type-image skillIcon stagger-limbus"></div>
	</div>
	</div>

<div class="columnAlign">
<div class="rowContainer settingStyle"><div style="width: 100px;">
<b data-i18n="editor-stg-recovery">STG Recovery</b>:</div> <input type="number" name="attr_staggerRecoverPercent" min="0" value="100" style="width:50px;">% + <input type="number" name="attr_staggerRecoverBase" value="0"></div>

<div class="rowContainer settingStyle"><div style="width: 100px;">
<b data-i18n="editor-stg-duration">STG Duration</b>:</div> <input type="number" name="attr_staggerDurationMax" value="1"></div>

<div class="rowContainer settingStyle"><div style="width: 100px;">
<b data-i18n="editor-stg-sanity">SP Damage</b>:</div> <input type="number" name="attr_staggerSanity" value="5"></div>
</div>
</div>
<!-- Stagger end -->

<!-- Generic token bars -->
<div class="rowContainer repitemMock" style="width: 300px;">
	<div class="rowContainer settingStyle">
		<div style="width: 40px;"><b data-i18n="token-bar1">Bar 1</b>:</div>
		<select name="attr_settingBar1" class="darkInput" style="width: 56px;">
			<option data-i18n="bar-health" value="HP" selected>Health</option>
			<option data-i18n="bar-stagres" value="StagRes">Stagger Res</option>
			<option data-i18n="bar-sanity" value="SP">Sanity</option>
			<option data-i18n="token-bar-none" value="None">None</option>
		</select>
	</div>
	<div class="rowContainer settingStyle">
		<div style="width: 40px;"><b data-i18n="token-bar2">Bar 2</b>:</div>
		<select name="attr_settingBar2" class="darkInput" style="width: 56px;">
			<option data-i18n="bar-health" value="HP">Health</option>
			<option data-i18n="bar-stagres" value="StagRes" selected>Stagger Res</option>
			<option data-i18n="bar-sanity" value="SP">Sanity</option>
			<option data-i18n="token-bar-none" value="None">None</option>
		</select>
	</div>
	<div class="rowContainer settingStyle">
		<div style="width: 40px;"><b data-i18n="token-bar3">Bar 3</b>:</div>
		<select name="attr_settingBar3" class="darkInput" style="width: 56px;">
			<option data-i18n="bar-health" value="HP">Health</option>
			<option data-i18n="bar-stagres" value="StagRes">Stagger Res</option>
			<option data-i18n="bar-sanity" value="SP" selected>Sanity</option>
			<option data-i18n="token-bar-none" value="None">None</option>
		</select>
	</div>
</div>
<!-- Generic token bars end -->

<div class="rowContainer centerFlex">

<!-- Burn -->
<div class="rowContainer repitemMock">
	<div class="columnAlign">
		<div class="rowContainer">
			<div class="ailmentIconSelector rowContainer centerFlex">
				<div class="icon">
					<input type="checkbox" class="hide-toggle-rev" value="true" name="attr_iconStyle"><div class="hide-item-rev skillIcon burn"></div>
				</div>

				<div class="icon">
					<input type="checkbox" class="expand-toggle" value="true" name="attr_iconStyle"><div class="type-image skillIcon burn-limbus"></div>
				</div>
			</div>

			<div class="settingStyle"><div style="width: 46px">
				<b data-i18n="message-decay">Decay</b>:</div>
			<div class="settingStyle">
			<select name="attr_burnDecayMode" class="darkInput" style="width: 40px;">
				<option value="+">+</option>
				<option value="x" selected>x</option>
				<option value="=">=</option>
			</select>
				<input type="text" name="attr_burnDecayVal" style="width: 40px;" value="0.5">
			</div>
			</div>
		</div>


		<div class="rowContainer">
			<div class="settingStyle"><div style="width: 66px; margin-left: 5px;">
				<b data-i18n="message-next-turn">Next turn</b>:
			</div> 
			<select name="attr_burnNextTurnSetting" class="darkInput" style="width: 80px;">
				<option data-i18n="false" value="false" selected>False</option>
				<option data-i18n="true" value="true">True</option>
			</select>
			</div>
		</div>
	</div>
</div>
<!-- Burn end -->

<!-- Bleed -->
<div class="rowContainer repitemMock">
	<div class="columnAlign">
		<div class="rowContainer">
			<div class="ailmentIconSelector rowContainer centerFlex">
				<div class="icon">
					<input type="checkbox" class="hide-toggle-rev" value="true" name="attr_iconStyle"><div class="hide-item-rev skillIcon bleed"></div>
				</div>
			
				<div class="icon">
					<input type="checkbox" class="expand-toggle" value="true" name="attr_iconStyle"><div class="type-image skillIcon bleed-limbus"></div>
				</div>
			</div>

			<div class="settingStyle"><div style="width: 46px">
				<b data-i18n="message-decay">Decay</b>:
			</div> 
			<select name="attr_bleedDecayMode" class="darkInput" style="width: 40px;">
				<option value="+">+</option>
				<option value="x" selected>x</option>
				<option value="=">=</option>
			  </select>
			<input type="text" name="attr_bleedDecayVal" style="width: 40px;" value="0.5">
			</div>
		</div>

		<div class="rowContainer">
			<div class="settingStyle"><div style="width: 66px; margin-left: 5px;">
				<b data-i18n="message-next-turn">Next turn</b>:
			</div> 
			<select name="attr_bleedNextTurnSetting" class="darkInput" style="width: 80px;">
				<option data-i18n="false" value="false" selected>False</option>
				<option data-i18n="true" value="true">True</option>
			</select>
			</div>
		</div>
	</div>
</div>
<!-- Bleed end -->

</div>
<div class="rowContainer centerFlex">

<!-- Smoke -->
<div class="rowContainer repitemMock">
	<div class="columnAlign">
		<div class="rowContainer">
			<div class="ailmentIconSelector rowContainer centerFlex">
				<div class="icon">
					<input type="checkbox" class="hide-toggle-rev" value="true" name="attr_iconStyle"><div class="hide-item-rev skillIcon smoke"></div>
				</div>
				
				<div class="icon">
					<input type="checkbox" class="expand-toggle" value="true" name="attr_iconStyle"><div class="type-image skillIcon smoke-limbus"></div>
				</div>
			</div>

			<div class="settingStyle"><div style="width: 46px">
				<b data-i18n="message-decay">Decay</b>:
			</div> 
			<select name="attr_smokeDecayMode" class="darkInput" style="width: 40px;">
				<option value="+">+</option>
				<option value="x" selected>x</option>
				<option value="=">=</option>
			</select>
			<input type="text" name="attr_smokeDecayVal" style="width: 40px;" value="0.5">
			</div>
		</div>

		<div class="rowContainer">
			<div class="settingStyle"><div style="width: 66px; margin-left: 5px;">
				<b data-i18n="message-next-turn">Next turn</b>:
			</div> 
			<select name="attr_smokeNextTurnSetting" class="darkInput" style="width: 80px;">
				<option data-i18n="false" value="false" selected>False</option>
				<option data-i18n="true" value="true">True</option>
			</select>
			</div>
		</div>

		<div class="rowContainer">
			<div class="settingStyle"><div style="width: 66px; margin-left: 5px;">
				<b data-i18n="message-damage-calculation">Damage</b>:
			</div>
			<select name="attr_smokeCalculationMode" class="darkInput" style="width: 40px;">
				<option value="/" selected>/</option>
				<option value="%">%</option>
				<option value="=">=</option>
			</select>
			<input type="text" name="attr_smokeCalculationVal" style="width: 40px;" value="3">
			</div>
		</div>
	</div>
</div>
<!-- Smoke end -->

<!-- Charge -->
<div class="rowContainer repitemMock">
	<div class="columnAlign">
		<div class="rowContainer">
			<div class="ailmentIconSelector rowContainer centerFlex">
				<div class="icon">
					<input type="checkbox" class="hide-toggle-rev" value="true" name="attr_iconStyle"><div class="hide-item-rev skillIcon charge"></div>
				</div>
				
				<div class="icon">
					<input type="checkbox" class="expand-toggle" value="true" name="attr_iconStyle"><div class="type-image skillIcon charge-limbus"></div>
				</div>
			</div>

			<div class="settingStyle"><div style="width: 46px">
				<b data-i18n="message-decay">Decay</b>:</div>
			<select name="attr_chargeDecayMode" class="darkInput" style="width: 40px;">
				<option value="+">+</option>
				<option value="x" selected>x</option>
				<option value="=">=</option>
			</select>
			<input type="text" name="attr_chargeDecayVal" style="width: 40px;" value="0.5">
			</div>
		</div>

		<div class="rowContainer">
			<div class="settingStyle"><div style="width: 66px; margin-left: 5px;">
				<b data-i18n="message-next-turn">Next turn</b>:
			</div> 
			<select name="attr_chargeNextTurnSetting" class="darkInput" style="width: 80px;">
				<option data-i18n="false" value="false" selected>False</option>
				<option data-i18n="true" value="true">True</option>
			</select>
			</div>
		</div>
	</div>
</div>
<!-- Charge end -->
</div>

</div>

</div></div>
<!-- Default Ailments END -->

</fieldset>
</div>
<!-- Obscured end -->

</div>
<!-- Game Setting section END -->



<!-- Custom Ailment section -->
<div>
<h3>
<input type="checkbox" class="switch-toggle" name="attr_syncLockAilment" value="true" hidden="true">
	<button type="action" class="lockButton largeIcon" id="lock_Ailment" name="act_lockSection"></button>

	<div>
	<input type="checkbox" class="hide-toggle" name="attr_syncStateAilment" value="true">
	<div class="hide-item syncIcon"></div>
	</div>

<span data-i18n="editor-customailments">Custom Ailments</span>
	<label for="hideAilmentSettings" class="arrowholder"><input type="checkbox" class="switch-toggle" id="hideAilmentSettings" name="attr_hideAilmentSettings" value="true" style="display: none;"><div class="arrow"></div></label>
</h3>


<!-- Menu -->
<input type="checkbox" class="hide-toggle-rev" name="attr_hideAilmentSettings" value="true" hidden="true">
<div class="hide-item-rev" style="width: 100%;">
	<textarea spellcheck="false" name="attr_ailmentEditor" data-i18n-placeholder="editor-customailments-textedit" placeholder="Custom Ailments Editor"></textarea>

<div class="rowContainer">
<button type="action" name="act_clearAilment" data-i18n="clear-button" class="btn">Clear</button>
<button type="action" name="act_syncAilment" data-i18n="sync-button" class="btn">Sync Data</button>

<div>
<label for="ailmentCollapse">
<div class="btn rowContainer centerFlex" style="width: 40px;"> <input type="checkbox" id="ailmentCollapse" class="switch-toggle" name="attr_settingCustomCollapse" value="true" style="display: none !important"><div class="smallarrow"></div></div>
</label>
</div>

<button type="action" name="act_exportRepeating" data-i18n="message-export" class="btn">Export</button>
<select name="attr_customImportMode" class="darkInput exportSelect" style="width: 100px;">
    <option data-i18n="import-type-replace" value="Replace" selected>Replace</option>
    <option data-i18n="import-type-add" value="Add">Add</option>
</select>
<button type="action" name="act_importRepeating" data-i18n="message-import" class="btn">Import</button>
</div>
<!-- Menu END -->


<!-- Custom ailment settings -->
<div class="ailmentCustomEditor rowContainer">

<fieldset class="repeating_ailments">
<button type="action" class="copyButton" name="act_copycustom"></button>

<input type="checkbox" class="switch-toggle" name="attr_ailDisplay" value="true" hidden="true" checked>
<button type="action" class="displayButton" name="act_displaycustom"></button>

<div class="columnAlign">
<div class="rowContainer settingStyle">

<!-- Icon selector -->
<div class="ailmentIconSelector rowContainer centerFlex">
	<div class="icon">
	<img name="attr_ailIconDisplay" class="skillIcon">
	</div>
</div>

<input type="text" name="attr_ailName" class="transpInput" data-i18n-placeholder="message-ailname-placeholder" placeholder="Ailment Name">
<input type="number" name="attr_ailNum" hidden="true">
<input type="number" name="attr_ailNumNextTurn" hidden="true">
<input type="number" name="attr_ailDecayPause" hidden="true">
</div>

<input type="checkbox" class="hide-toggle-rev" name="attr_ailCollapse" value="true" hidden="true">
<div class="hide-item-rev columnAlign" style="margin-top: 3px; width: 240px;">

<!-- Ailment icon  -->
<div class="rowContainer settingStyle">
<div class="customAilText">
<span data-i18n="message-icon">Icon</span>:
</div>
<input name="attr_ailIcon" list="iconlist" type="text" placeholder="Type for icon selection." value="Question">
</div>

<!-- Ailment trigger -->
<div class="rowContainer settingStyle">
<div class="customAilText">
<span data-i18n="message-trigger">Trigger</span>:
</div>
  <select name="attr_ailTrigger" class="whiteInput" style="width: 210px;">
    <option data-i18n="message-none" value="None" selected>None</option>
    <option data-i18n="trigger-roundend" value="RoundEnd">Round End</option>
    <option data-i18n="trigger-onaction" value="OnAction">On Action</option>
	<option data-i18n="trigger-whenhit" value="WhenHit">When Hit</option>
  </select>
</div>

<!-- Ailment next turn setting -->
<div class="rowContainer settingStyle">
	<div class="customAilText" style="width: 135px !important;">
		<span data-i18n="message-next-turn-field">Has next turn field</span>:
	</div>
	<select name="attr_ailNextTurn" class="whiteInput" style="width: 105px">
		<option data-i18n="true" value="true" selected>True</option>
		<option data-i18n="false" value="false">False</option>
	</select>
</div>

<!-- When hit settings -->
<input type="checkbox" class="hide-toggle-rev-next" name="attr_ailTrigger" value="None" hidden="true" checked>
<div class="hide-item-rev columnAlign">

<!-- When hit trigger damage type -->
<div class="rowContainer settingStyle">
	<div class="customAilText" style="width: 135px !important;">
		<span data-i18n="message-hit-trigger-damage-type">Trigger dmg type</span>:
	</div>
	<select name="attr_ailDamageTypeTrigger" class="whiteInput" style="width: 105px">
		<option data-i18n="when-hit-damage-any" value="Any" selected>Any</option>
		<option data-i18n="weapon-type-Slash" value="Slash">Slash</option>
		<option data-i18n="weapon-type-Pierce" value="Pierce">Pierce</option>
		<option data-i18n="weapon-type-Blunt" value="Blunt">Blunt</option>
	</select>
</div>

<!-- When hit resistance mode -->
<div class="rowContainer settingStyle">
	<div class="customAilText" style="width: 135px !important;">
		<span data-i18n="message-hit-resistance-mode">Resistance mode</span>:
	</div>
	<select name="attr_ailBeforeResistance" class="whiteInput" style="width: 105px">
		<option data-i18n="when-hit-mode-beforeResistance" value="beforeResistance" selected>Before Resistance</option>
		<option data-i18n="when-hit-mode-afterResistance" value="afterResistance">After Resistance</option>
	</select>
</div>

<!-- When hit decay settings -->
<div class="rowContainer settingStyle">
	<div class="customAilText" style="width: 135px !important;">
		<span data-i18n="message-hit-decaywhenhit">Decay when hit</span>:
	</div>
	<select name="attr_ailDecayWhenHit" class="whiteInput" style="width: 105px">
		<option data-i18n="true" value="true" selected>True</option>
		<option data-i18n="false" value="false">False</option>
	</select>
</div>

<div class="rowContainer settingStyle">
	<div class="customAilText" style="width: 135px !important;">
		<span data-i18n="message-hit-decayroundend">Decay round end</span>:
	</div>
	<select name="attr_ailDecayRoundEnd" class="whiteInput" style="width: 105px">
		<option data-i18n="true" value="true" selected>True</option>
		<option data-i18n="false" value="false">False</option>
	</select>
</div>

<!-- When hit positive mode -->
<input type="checkbox" class="hide-toggle-rev" name="attr_ailEffectVal" value="-n">
<input type="checkbox" class="hide-toggle-rev" name="attr_ailBeforeResistance" value="beforeResistance">
<div class="rowContainer settingStyle hide-item-rev">
	<div class="customAilText" style="width: 135px !important;">
		<span data-i18n="message-positive-type">Positive type</span>:
	</div>
	<select name="attr_ailPositiveType" class="whiteInput" style="width: 105px">
		<option data-i18n="positive-type-regen" value="Regen" selected>Regen</option>
		<option data-i18n="positive-type-reduction" value="Reduction">Reduction</option>
	</select>
</div>
</div>
<!-- When hit settings END -->

<!-- Ailment custom resistance -->
<div class="rowContainer settingStyle">
	<div class="customAilText" style="width: 135px !important;">
		<span data-i18n="message-has-custom-resistance">Custom resistance</span>:
	</div>
	<select name="attr_ailCustomResistance" class="whiteInput" style="width: 105px">
		<option data-i18n="false" value="false" selected>False</option>
		<option data-i18n="true" value="true">True</option>
	</select>
</div>

<!-- Ailment effect -->
<div class="rowContainer settingStyle">

	<div class="customAilText">
		<span data-i18n="message-effect">Effect</span>:
		</div>
		
		<select name="attr_ailEffect" class="whiteInput" style="width: 105px;">
			<option data-i18n="message-none" value="None" selected>None</option>
			<option data-i18n="bar-health-and-stagres" value="HPStagRes">Health and Stagger</option>
			<option data-i18n="bar-health" value="HP">Health</option>
			<option data-i18n="bar-stagres" value="StagRes">Stagger</option>
			<option data-i18n="bar-health-temp" value="THP">Temp HP</option>
			<option data-i18n="bar-stagres-temp" value="TST">Temp ST</option>
			<option data-i18n="bar-sanity" value="SP">Sanity</option>
			<option data-i18n="bar-light" value="Light">Light</option>
			<option data-i18n="distort-counter-full" value="distortCounter">Distortion Counter</option>
			<option data-i18n="helper-text-difficulty" value="difficulty">Difficulty</option>
		</select>

		<!-- Used by Temp HP and Temp ST -->
		<input type="number" name="attr_ailTempBarOverride" value="0" hidden="true">
		
		<select name="attr_ailEffectMode" class="darkInput" style="width: 40px;">
			<option value="+" selected>+</option>
			<option value="x">x</option>
			<option value="=">=</option>
		</select>
		
		<input type="text" name="attr_ailEffectVal" style="width: 40px;" value="-n">
		</div>

<!-- Ailment decay -->
		<div class="rowContainer settingStyle">
		
		<div class="customAilText">
		<span data-i18n="message-decay">Decay</span>:
		</div>
		
		  <select name="attr_ailDecayMin" class="whiteInput" style="width: 105px">
			<option data-i18n="decay-min-1" value="1" selected>Count (Min: 1)</option>
			<option data-i18n="decay-min-0" value="0">Count (Min: 0)</option>
		  </select>
		
		  <select name="attr_ailDecayMode" class="darkInput" style="width: 40px;">
			<option value="+">+</option>
			<option value="x">x</option>
			<option value="=" selected>=</option>
		  </select>
		
		 <input type="text" name="attr_ailDecayVal" style="width: 40px;" value="0">
	</div>

<!-- Ailment max value -->
<input type="checkbox" class="fade-toggle-next" name="attr_ailMax" value="0" hidden="true" checked>
<div class="fade-item rowContainer settingStyle">
<div class="customAilText">
<span data-i18n="message-max">Max</span>:
</div>

<div class="settingStyle">
 <input type="number" name="attr_ailMax" style="width: 40px;" min="0" value="0">

<select name="attr_ailMaxBehavior" class="transpInput" type="text" style="width: 140px;">
    <option data-i18n="max-none" value="None" selected>No Override</option>
    <option data-i18n="max-clear" value="Clear">Clear on Max</option>
    <option data-i18n="max-effect" value="Effect">Effect on Max</option>
    <option data-i18n="max-decay" value="Decay">Decay on Max</option>
    <option data-i18n="max-effectdecay" value="EffectDecay">Effect + Decay on Max</option>
   <option data-i18n="max-effectclear" value="EffectClear">Effect + Clear on Max</option>
</select>
</div>
</div>

<!-- Ailment message -->
<input type="checkbox" class="fade-toggle-next" name="attr_ailMessageCheck" value="0" hidden="true" checked>
<div class="fade-item columnAlign settingStyle">

 <select name="attr_ailMessageCheck" class="darkInput" value="0">
    <option data-i18n="message-nomessage" value="0" selected>No Message</option>
    <option data-i18n="message-sendmessage" value="true">Send Message</option>
  </select>

<div>
 <textarea name="attr_ailMessage" data-i18n="message-custom-placeholder" value="[CHAR]: [DIFF] damage from [AIL]">[CHAR]: [DIFF] damage from [AIL]</textarea>
</div>
</div>

</div>
</div>
</fieldset>
</div>
<!-- Custom ailment settings END -->

</div>
<!-- Custom Ailment section END -->



<!-- Icon Selector Data -->
<datalist id="iconlist">
    <option value="None">None</option>
    <option value="Question">Question</option>

    <option value="Burn">Burn</option>
    <option value="Bleed">Bleed</option>
    <option value="Paralysis">Paralysis</option>
    <option value="Smoke">Smoke</option>
    <option value="Charge">Charge</option>
    <option value="Fortune">Fortune</option>
    <option value="Fragile">Fragile</option>
	<option value="FragileStagger">Stagger Fragile</option>
    <option value="Protection">Protection</option>
    <option value="StaggerProtection">Stagger Protection</option>
    <option value="Strength">Strength</option>
    <option value="Feeble">Feeble</option>
    <option value="Endurance">Endurance</option>
    <option value="Disarm">Disarm</option>
    <option value="Haste">Haste</option>
    <option value="Bind">Bind</option>
    <option value="Panic">Panic</option>
    <option value="Hostile">Hostile</option>

    <option value="limbus/Burn">Burn (Limbus)</option>
    <option value="limbus/Bleed">Bleed (Limbus)</option>
    <option value="limbus/Paralysis">Paralysis (Limbus)</option>
    <option value="limbus/Smoke">Smoke (Limbus)</option>
    <option value="limbus/Charge">Charge (Limbus)</option>
    <option value="limbus/Fortune">Fortune (Limbus)</option>
    <option value="limbus/Fragile">Fragile (Limbus)</option>
	<option value="limbus/FragileStagger">Stagger Fragile (Limbus)</option>
    <option value="limbus/Protection">Protection (Limbus)</option>
    <option value="limbus/StaggerProtection">Stagger Protection (Limbus)</option>
    <option value="limbus/Strength">Strength (Limbus)</option>
    <option value="limbus/Feeble">Feeble (Limbus)</option>
    <option value="limbus/Endurance">Endurance (Limbus)</option>
    <option value="limbus/Disarm">Disarm (Limbus)</option>
    <option value="limbus/Haste">Haste (Limbus)</option>
    <option value="limbus/Bind">Bind (Limbus)</option>
    <option value="limbus/Hostile">Hostile (Limbus)</option>

    <option value="limbus/Rupture">Rupture (Limbus)</option>
    <option value="limbus/Tremor">Tremor (Limbus)</option>
	<option value="limbus/TremorChain">Tremor Chain (Limbus)</option>
	<option value="limbus/TremorDecay">Tremor Decay (Limbus)</option>
	<option value="limbus/TremorDistribution">Tremor Distribution (Limbus)</option>
	<option value="limbus/TremorEverlasting">Tremor Everlasting (Limbus)</option>
	<option value="limbus/TremorFracture">Tremor Fracture (Limbus)</option>
	<option value="limbus/TremorReverb">Tremor Reverb (Limbus)</option>
	<option value="limbus/TremorSuperposition">Tremor Superposition (Limbus)</option>
    <option value="limbus/Sinking">Sinking (Limbus)</option>
    <option value="limbus/Poise">Poise (Limbus)</option>
    <option value="limbus/Panic">Panic: !!! (Limbus)</option>
    <option value="limbus/PanicBlue">Panic: Brain (Limbus)</option>
    <option value="limbus/Frostbite">Frostbite (Limbus)</option>
    <option value="limbus/Poison">Poison (Limbus)</option>
    <option value="limbus/Nails">Nails (Limbus)</option>
    <option value="limbus/Ruin">Ruin (Limbus)</option>
    <option value="limbus/Devastation">Devastation (Limbus)</option>
    <option value="limbus/Critical">Critical (Limbus)</option>

    <option value="limbus/Aggro">Aggro (Limbus)</option>
    <option value="limbus/Bullseye">Bullseye (Limbus)</option>
    <option value="limbus/Ammo">Ammo (Limbus)</option>
    <option value="limbus/Barrier">Charge Barrier (Limbus)</option>
    <option value="limbus/Duel">Duel (Limbus)</option>
    <option value="limbus/Fist">Fist: Red (Limbus)</option>
    <option value="limbus/FistGreen">Fist: Green (Limbus)</option>
    <option value="limbus/Heal">Heal (Limbus)</option>
    <option value="limbus/KAmpule">K-Corp Ampule (Limbus)</option>
    <option value="limbus/TTime">T-Corp Time (Limbus)</option>
	<option value="limbus/RottingSkin">Rotting Skin (Limbus)</option>

	<option value="Blood">Blood</option>

    <option value="limbus/SlashProtection">Slash Protection (Limbus)</option>
    <option value="limbus/PierceProtection">Pierce Protection (Limbus)</option>
    <option value="limbus/BluntProtection">Blunt Protection (Limbus)</option>
    <option value="limbus/SlashFragility">Slash Fragility (Limbus)</option>
    <option value="limbus/PierceFragility">Pierce Fragility (Limbus)</option>
    <option value="limbus/BluntFragility">Blunt Fragility (Limbus)</option>

    <option value="limbus/Wrath">Wrath (Limbus)</option>
    <option value="limbus/Lust">Lust (Limbus)</option>
    <option value="limbus/Sloth">Sloth (Limbus)</option>
    <option value="limbus/Gluttony">Gluttony (Limbus)</option>
    <option value="limbus/Gloom">Gloom (Limbus)</option>
    <option value="limbus/Pride">Pride (Limbus)</option>
    <option value="limbus/Envy">Envy (Limbus)</option>

	<option value="limbus/DamageUp">Damage Up (Limbus)</option>
	<option value="limbus/DamageDown">Damage Down (Limbus)</option>

    <option value="community/Style">Style (Community)</option>
    <option value="community/Thorns">Thorns (Community)</option>
    <option value="community/Rhythm">Rhythm (Community)</option>

    <option value="community/Frenzy">Frenzy (Community)</option>
    <option value="community/Shock">Shock (Community)</option>
    <option value="community/Terror">Terror (Community)</option>
    <option value="community/StaggerDamageUp">Stagger Damage Up (Community)</option>
    <option value="community/StaggerDamageDown">Stagger Damage Down (Community)</option>
</datalist> 
<!-- Icon Selector Data END -->

</div>
</div>
</div>
	</div>
	</div>
<!-- Sheet Editor END -->



<!-- Roll Templates -->

<rolltemplate class="sheet-rolltemplate-message">
    <div class="sheet-template-wrapper" style="background-color: #333; border-radius: 5px; color: #fff; padding: 5px;">
    	{{icon}} {{#name}}<b>{{name}}</b>{{/name}} {{message}}
		{{#roll1}} {{roll1}} {{/roll1}}
    </div>
</rolltemplate>


<rolltemplate class="sheet-rolltemplate-errorMessage">
    <div class="sheet-template-wrapper" style="background-color: #350909; border-radius: 5px; color: #fff; padding: 5px;">
       {{icon}} {{message}}
    </div>
</rolltemplate>


<rolltemplate class="sheet-rolltemplate-damagecalculation">
    <div class="sheet-template-wrapper" style="background-color: #454545; border-radius: 5px; color: #eee; height: auto; padding: 5px; overflow: hidden;">
		<div style="background-color: #222; height: 30px; border: 2px #000 solid; color: #fff">
			<div style="float: left; height: 30px; width: 30px; margin-right: 7px; background-image: linear-gradient(to bottom right, #c25944 0% ,#c25944 50% ,#dbb748 50% , #dbb748 100%)">
				{{icon}}
			</div>
			<div style="width: 55% ; overflow: hidden ; height: 20px ; padding-top: 5px ; float: left"><b>{{#title}}{{title}}{{/title}}</b></div>
		</div>
		{{#name}}<div><b>For: </b>{{name}}</div>{{/name}}
		{{#damagecalculations}}<div>{{damagecalculations}}</div>{{/damagecalculations}}
	</div>
</rolltemplate>


<rolltemplate class="sheet-rolltemplate-autoeffect">
    <div class="sheet-template-wrapper" style="background-color: #454545; border-radius: 5px; color: #eee; height: auto; padding: 5px; overflow: hidden;">
		<div style="background-color: #222; height: 30px; border: 2px #000 solid; color: #fff">
			<div style="float: left; height: 30px; width: 30px; margin-right: 7px; background-color: #85a874;">
				{{icon}}
			</div>
			{{#title}}
			<div style="width: 80% ; overflow: hidden ; height: 20px ; padding-top: 5px ; float: left">
				<b>{{title}}</b>
		</div>
			{{/title}}
	</div>
		{{#name}}<div><b>For: </b>{{name}}</div>{{/name}}
		{{#message}}<div>{{message}}</div>{{/message}}
    </div>
</rolltemplate>


<rolltemplate class="sheet-rolltemplate-shareB">
    <div class="sheet-template-wrapper" style="background-color: #333; border-radius: 5px;  overflow: hidden; border: 1px #555 solid;">
    	<div class="sheet-template-wrapper" style="color: #fff; position: relative;">
			{{header}}
			{{body}}
		</div>
	</div>
</rolltemplate>


<rolltemplate class="sheet-rolltemplate-testFeature">
	<div class="sheet-template-wrapper" style="background-color: #333; border-radius: 5px;  overflow: hidden; border: 1px #555 solid;">
		<div class="sheet-testcontainer">
			{{#baseUrl}}[{{buttonLabel}}]({{baseUrl}}{{fragment}}){{/baseUrl}}
			{{#insert}}
				<div class="sheet-tab1" dir="{{computed::insert}}"></div>
				<div class="sheet-tab2" dir="{{computed::insert}}"></div>
				<div class="sheet-tab3" dir="{{computed::insert}}"></div>
			{{/insert}}
			{{#test}}{{test}}{{/test}}
			{{#script}}<div dir="{{computed::script}}{{computed::scriptend}}"></div>{{/script}}
		</div>
	</div>
</rolltemplate>


<rolltemplate class="sheet-rolltemplate-customRoll">
    <div class="sheet-template-wrapper" style="background-color: #454545; border-radius: 5px; color: #eee; height: auto; padding: 5px; overflow: hidden;">
		<div style="position: relative;">
			{{#header}} {{header}} {{/header}}
			{{#body}} {{body}} {{/body}}
		</div>
    </div>
</rolltemplate>


<rolltemplate class="sheet-rolltemplate-baseRoll">
    <div class="sheet-template-wrapper" style="background-color: #454545; border-radius: 5px; color: #eee; height: auto; padding: 5px; overflow: hidden;">
	<div style="position: relative;">
	{{#infodump}} {{infodump}} {{/infodump}}
			
	{{#roll1}}
	<div style="position: absolute; top: 2px; right: 0px;">
		<h4 style="background-color: #000; height: 25px; min-width: 30px; padding-left: 3px; padding-right: 3px; text-align: center; padding-top: 6px;">
			{{#allprops() infodump advantage}}
			{{value}}
			{{/allprops() infodump advantage}}
		</h4>
	</div>
	{{/roll1}}

	{{#challenge}}
	{{#roll1}}
	<div style="text-align: center; margin-top: 5px;">
				
	{{#rollLess() roll1 7}}
	<b data-i18n="message-failure">Failure...</b> <img src="https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/icons/bad.png" style="width: 25px; height: 25px;">
	{{/rollLess() roll1 7}}

	{{#rollBetween() roll1 7 9}}
	<b data-i18n="message-normal">Partial Success</b> <img src="https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/icons/normal.png" style="width: 25px; height: 25px;">
	{{/rollBetween() roll1 7 9}}

	{{#rollGreater() roll1 9}}
	<b data-i18n="message-success">Success!</b> <img src="https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/icons/good.png" style="width: 25px; height: 25px;">
	{{/rollGreater() roll1 9}}

	</div>
 	{{/roll1}}
	{{/challenge}}
	</div>
    </div>
</rolltemplate>

<!-- Chat message action buttons -->
<div style="display:none">
<button type="action" name="act_selectToken"></button>
<button type="action" name="act_deleteTokenMultiple"></button>
<button type="action" name="act_chatButtonDamage"></button>
<button type="action" name="act_chatButtonRoll"></button>
<button type="action" name="act_chatButton"></button>
</div>

<rolltemplate class="sheet-rolltemplate-chatbuttons">
    <div class="sheet-chatButtonBlocker{{whisperMode}}"></div>
	{{#allprops() whisperMode}}
	<div class="sheet-chatButtonContainer">
		<div class="sheet-button sheet-{{key}}">
			{{value}}
		</div>
	</div>
	{{/allprops() whisperMode}}
</rolltemplate>

<!-- Roll Templates END -->




<script type="text/worker">


/* --- Sheet Constants --- */

/* Names and Attributes */
const ailmentNames = [
	"Burn", "Bleed", "Paralysis", "Protection", "StaggerProtection",
	"Fragile", "Strength", "Feeble", "Endurance", "Disarm",
	"Haste", "Bind", "Smoke", "Charge", "Fortune"
]
const ailmentAttrs = [
	"ailNum", "ailName", "ailIcon", "ailDisplay", "ailTrigger", "ailNextTurn", "ailNumNextTurn",
	"ailEffect", "ailEffectMode", "ailEffectVal", "ailDecayMode", "ailDecayVal", "ailDecayMin", "ailDecayPause", // Effect and decay
	"ailDamageTypeTrigger", "ailBeforeResistance", "ailDecayWhenHit", "ailDecayRoundEnd", "ailPositiveType", // When Hit settings
	"ailCustomResistance", "ailCustomResistanceNum", "ailCustomResistanceNumEgo", // Custom resistance
	"ailMax", "ailMaxBehavior", "ailMessageCheck", "ailMessage", "ailCollapse" // Other
]

const barNames = ["HP", "ST", "SP", "Light"]
const barNamesFull = ["Health", "StagRes", "Sanity", "Light"]
const barNamesTemp = ["THP", "TST"]
const statNames = ["Instinct", "Wisdom", "Justice", "Charm", "Insight", "Temperance"]
const statNamesFull = [...statNames, "Fortitude", "Prudence"]

const resourceNames = ["Action", "Reaction", "Counter", "Block", "Evade", "Light_Regen"]
const combatRollNames = ["Attack", "Block", "Evade"]
const damageTypes = ["Slash", "Pierce", "Blunt"]

/* Contains details on the format of all AutoEffects. Used for parsing AutoScripts */
//	 value: One of "string", "number", or false. If false the AutoEffect has no value
//	 target: Array of valid targets. Includes groups of targets like "#Ailment", "#Bar", "#BarDamage" and "#BarTemp". If false the AutoEffect has no target
//	 other: Unique AutoEffect properties, ex. the percentage mode, reverse position of value and target etc.
//   copy: Makes an AutoEffect use the format of another effect
const autoEffectFormats = {
	"CustomMessage":	{value:"string", 	target:false},
	"Require":			{value:"number", 	target:["#Ailment", "#Bar", "#BarDamage", "#Resource"], 	percentageValue:true, compareValue:true, useCount:true},
	"Consume":			{value:"number", 	target:["#Ailment", "#Bar", "#Resource"],					percentageValue:true, useCount:true},
	"Reset":			{value:false,    	target:false},
	"Gain":				{value:"number", 	target:["#Ailment"],										maxLengthMod:1, useCount:true},
	"Inflict":			{copy: "Gain"},
	"Give":				{copy: "Gain"},
	"Set":				{value:"number", 	target:["#Bar", "#Resource"], 								useCount:true},
	"Add":				{value:"number",	target:["#Bar", "#BarTemp", "#Resource"], 					negativeValue:true, useCount:true},
	"Multi":			{copy: "Set"},
	"DicePower":		{value:"number", 	target:false,												negativeValue:true},
	"DiceMax":			{copy: "DicePower"},
	"DiceCount":		{copy: "DicePower"},
	"DiceAdv":			{copy: "DicePower"},
	"BaseDamage":		{value:"number", 	target:["#Bar"],											negativeValue:true, targetOptional:true},
	"FlatDamage":		{value:"number", 	target:["#Bar"],											negativeValue:true},
	"Proc":				{value:false,    	target:["#Ailment"], 										useCount:true},
	"Pause":			{value:"number", 	target:["#Ailment"], 										useCount:true},
	"ChallengeRoll":	{value:"number", 	target:["#Stat"],											negativeValue:true, reverse:true},
	"Speed":			{value:"number", 	target:false,												negativeValue:true, duration:true, maxLengthMod:1}
}

/* Contains details on the available options for AutoEffects, conditionals and triggers */
const autoEffectOptions = {
	"Silent":			["All", "-Reset", "-CustomMessage"],
	"Target":			["CustomMessage", "Require", "Consume", "Set", "Add", "Multi", "Reset", "Proc", "Pause", "ChallengeRoll", "Speed"],
	"Scaling":			["Require", "Consume"],
	"IgnoreFailure":	["Require", "Consume"],
	"Round":			["Gain", "Inflict", "Give"],
	"Duration":			["Speed"],
	"CheckResult":		["CustomMessage"]
}
const autoEffectOptionsExpand = {
	"Silent":			["Silent", "SilentSelf", "SilentTarget"],
	"Target":			["Target", "Select"],
	"CheckResult":		["CheckSuccess", "CheckFailure", "CheckIgnore"],
	"Round":			["This", "Next", "Round", "Turn"],
	"Duration":			["This", "Next", "Round", "Turn", "Combat"],
	"Scaling":			["Scaling", "ScalingN"],
}
const conditionalOptions = {
	"Section":			["All"],
	"IgnoreFailure":	["Require", "Consume"],
	"ChatButton":		[...autoEffectOptions.Target, "Inflict", "Give", "FlatDamage"]
}
const triggerOptions = [
	"First round"
]
const autoEffectTriggers = [
	"Combat start", "Round start", "Combat end",				// Turn order
	"Offensive", "Defensive", "Block", "Evade", "Challenge",	// Actions
	"Damaged", "DamagedHP", "DamagedST", "DamagedSP",			// Damage
	"Staggered", "Defeated", "Panic",							// States
	"Recover", "Permanent"										// Other
]

/* Contains all error codes and messages used by the AutoEffects functionality */
const autoEffectErrorData = {
	"Invalid AutoEffect": "autoeffect-error-invalid-name",
	"Invalid Value": "autoeffect-error-invalid-value",
	"Invalid Target": "autoeffect-error-invalid-target",
	"Invalid Format": "autoeffect-error-invalid-format",
	"Invalid Option": "autoeffect-error-invalid-option",
	"Invalid Round": "autoeffect-error-invalid-round",
	"Invalid Duration": "autoeffect-error-invalid-duration",
	"Invalid Percentage": "autoeffect-error-invalid-percentage",
	"Invalid Compare": "autoeffect-error-invalid-compare",
	"Invalid Alias": "autoeffect-error-invalid-alias",
	"Math Error": "autoeffect-error-math"
}

/* Contains default AutoScript styling and aliases */
const stylingDefault =
`/* Clash results */
(Clash Win, icons, win, red) (CW, icons, win, red)
(Clash Lose, icons, lose, yellow) (CL, icons, lose, yellow)

/* On Use and On Hit */
(On Use, icons, Portable, blue)
(On Hit, icons, Attack, purple)

/* Action buttons */
(Apply damage, icons, damage, red)
(Apply regen, icons, heal, green)
(Apply ailments, icons, lose, purple)
(Give ailments, icons, win, yellow)
(Roll challenge, icons, Speed, blue)`;

const aliasDefault = 
`/* --------------------- */
/* Weapon effects */
/* --------------------- */
{# Charge Ammo;
	(Consume 2 Charge Silent)
	(CustomMessage "[/TARGET] Charge Ammo: Not enough [TARGET]" CheckFailure)
	(CustomMessage "[/TARGET] Charge Ammo: Consumed [-NUM] [TARGET]" CheckSuccess)
#}
{# Extension Grip;
	(Consume 4 Charge Silent, Extension Grip)
	(CustomMessage "[/TARGET] Consumed [-NUM] [TARGET] to activate Extension Grip [[INITIAL] -> [RESULT]], Extension Grip)
#}
{# Loaded Magnet #N;
	(Require {2*#N} Charge_Barrier Silent)
	(CustomMessage "[/limbus/Barrier] Loaded Magnet: Target is pulled up to #N squares towards the user) (Reset)
#}


/* ------------------------------ */
/* Outfit / passive effects */
/* ------------------------------ */
{# Padded Clothing #N;
	[#Combat start, (Add {3*#N} THP) #]
#}
{# Shock Absorbent #N;
	[#Combat start, (Add {3*#N} TST) #]
#}
{# Comfy Clothes #N;
	[#Combat start, (Speed #N This combat) #]
#}


/* -------------------------------------- */
/* Dice Manipulation Augments */
/* -------------------------------------- */
{# #Ailment Bonus #N #Trigger;
	[# #Trigger,
		(Require #N #Ailment Target Silent)
		(CustomMessage "[/TARGET] [TARGET] Bonus: Gained **1** Dice Power") (DicePower 1 Silent)
	#]
#}
{# Poise Bonus #Trigger;
	[# #Trigger,
		(Require 4 Poise Silent) (CustomMessage Poise bonus: Gained [NUM] Dice Power)
		(DicePower 1 Silent)
	#]
#}
{# #Ailment Vigor #N;
	[#Offensive,
		(Require #N #Ailment Scaling3 Silent)
		(CustomMessage [/TARGET] #Ailment Vigor: Gained [SCALING] Dice Power)
		(DicePower 1 Silent)
	#]
#}

//--placeholder-- Haste Vigor



/* -------------------- */
/* Buff Augments */
/* -------------------- */
{#Activate Protection;
	[#Round start,
		(Require 25% -HP Scaling Silent)
		(CustomMessage "[/Protection] Activate Protection: Gained no Protection" CheckFailure)
		(CustomMessage "Activate Protection: Gained [SCALING] Protection [/Protection] and [SCALING] Stagger Protection [/StaggerProtection]" CheckSuccess)
		(Gain 1 Protection This turn Silent) (Gain 1 Stagger_Protection This turn Silent)
	#]
#}
{#Activate #Ailment;
	[#Round start,
		(Require 25% -HP Scaling Silent)
		(CustomMessage "[/Strength] Activate #Ailment: Gained no #Ailment" CheckFailure)
		(CustomMessage "[/Strength] Activate #Ailment: Gained [SCALING] #Ailment" CheckSuccess)
		(Gain 1 #Ailment This turn Silent)
	#]
#}
{#First-strike #N;
	[#Offensive #Defensive #First round, (DicePower N) (CustomMessage [/Strength] First-strike: Gained N dice power) #]
#}
{#Remembrance #Ailment;
	[#Round start, (Gain 2 #Ailment This round, Remembrance) #]
#}
{#Power on Takedown #N;
	[#Offensive, (Gain #N Strength, Power on Takedown) #]
#}
{# Status Barrier;
	[#Round start,
		(Require 0.5 Charge_Barrier Scaling Silent)
		(CustomMessage [/limbus/Barrier] Status Barrier: Reduce Ailments by [SCALING])
	#]
#}
{# Indomitable;
	[#Staggered,
		(Require 1 -ST Scaling Silent, Indomitable) (Add 1 ST Silent, Indomitable)
		(CustomMessage Regained all Stagger Resist (Once per combat), Indomitable)
	#]
#}


/* --------------------------------- */
/* Status Ailment Augments */
/* --------------------------------- */
{# Smoke Overflow #N;
	[#Offensive,
		(Require {4*#N+4} Smoke Silent)
		(DicePower #N Silent)
		(CustomMessage "[/Smoke] Smoke Overflow: Gained #N Dice Power")
	#]
#}
{# Puffy Brume;
	[#Offensive,
		(Require 2 Smoke Scaling Silent)
		(FlatDamage 1 HP Silent)
		(CustomMessage "[/Smoke] Puffy Brume: Deal [SCALING] [TARGET] damage")
	#]
#}
{# Dizzying Smog;
	[#Offensive,
		(Require 4 Smoke Scaling Target Silent)
		(FlatDamage 1 ST Silent)
		(CustomMessage "[/Smoke] Dizzying Smog: Deal [SCALING] [TARGET] damage")
	#]
#}
{# Flash #Ailment #N;
	[#Offensive #First round,
		(Inflict #N #Ailment Silent)
		(CustomMessage [/TARGET] Flash #Ailment: Inflict [SCALING NUM] [TARGET])
		(CustomMessage [/TARGET] Flash #Ailment: Gain [SCALING NUM] [TARGET] [[INITIAL] -> [RESULT]] Target, Apply ailments #ChatButton)
	#]
#}
{# #Ailment-maniac #N;
	[#Offensive,
		(Consume 1 #Ailment Scaling#N Silent, Clash Win)
		(Inflict 1 #Ailment Silent, Clash Win)
		(CustomMessage [/TARGET] Transferred [SCALING NUM] [TARGET] from user to target, Clash Win)
	#]
#}
{# #Ailment-maniac #N (Reverse);
	[#Offensive,
		(Consume 1 #Ailment Scaling#N Silent Target, Clash Win)
		(Gain 1 #Ailment Silent, Clash Win)
		(CustomMessage [/TARGET] Transferred [SCALING NUM] [TARGET] from target to user, Clash Win)
	#]
#}
{# Systems Online #N;
	[#Combat start, (Gain {3*#N} Charge) #]
#}
{# Constant Barrier #N;
	[#Round start,
		(CustomMessage [/limbus/Barrier] Constant Barrier: Exchange 3 Charge for 1 Barrier. Max #N uses)
		(Consume 3 Charge Silent, Constant Barrier)
		(Gain 1 Charge_Barrier This round Silent, Constant Barrier)
	#]
#}
{# Combo Master;
	[#Offensive,
		(Gain 1 Combo Silent, Clash Win)
		(CustomMessage [/TARGET] Gain 1 [TARGET]. Gain [NUM] extra [TARGET] if target is staggered or defeated, Clash Win)
	#]
	[#Offensive #Defensive,
		(Proc Combo Silent, Clash Lose)
		(CustomMessage [/TARGET] Halved [TARGET], Clash Lose)
	#]
#}
{# Kinetic Generator;
	[#Round start,
		(Require 1 Combo Scaling Silent)
		(Gain 1 Charge Silent)
		(CustomMessage [/limbus/FistGreen] Kinetic Generator: Gained [SCALING NUM] [TARGET])
	#]
#}


/* --------------------- */
/* Mark Augments */
/* --------------------- */
{# Target for Exploitation;
	[#Offensive, (Gain 2 Charge, On hit: Marked) #]
#}


/* ---------------------- */
/* Other Augments */
/* ---------------------- */
{# Cursed #N;
	[#Permanent,
		(Require #N Ruin Silent) (CustomMessage [/TARGET] Cursed: [TARGET] set to [NUM] CheckFailure) (Reset)
		(Require #N Devastation Silent) (CustomMessage [/TARGET] Cursed: [TARGET] set to [NUM] CheckFailure) (Reset)
		(Consume 1 Ruin Scaling#N Silent) (Reset) (Gain #N Ruin Silent)
		(Consume 1 Devastation Scaling#N Silent) (Reset) (Gain #N Devastation Silent)
	#]
#}


/* ---------------------------------------- */
/* Dice Manipulation Skill Effects */
/* ---------------------------------------- */
{# Skill #Ailment Vigor #N #X?;
	(Require {#X+#N} Ailment Silent)
	(CustomMessage [/TARGET] [TARGET] Vigor: Gained #N Dice Power)
	(DicePower #N Silent) (Reset)
#}
{# Skill #Ailment Bonus #N #X;
	(Require {#X+#N} #Ailment Target Silent)
	(CustomMessage "[/TARGET] [TARGET] Bonus: Gained #N Dice Power")
	(DicePower #N Silent) (Reset)
#}
{# Overcoming Crisis #N;
	(Require {#N*25%} -HP Silent)
	(CustomMessage Overcoming Crisis: Not below [NUM] **HP** CheckFailure)
	(DicePower #N Silent)
	(CustomMessage Overcoming Crisis: Gained [NUM] **Dice Power** CheckSuccess) (Reset)
#}
{# Press Advantage, #Clash? #Result?;
	(Require 2 Bind Target Scaling Silent #IgnoreFailure, #Clash #Result)
	(Inflict 1 TYPE_Fragility Silent, #Clash #Result)
	(CustomMessage "[/Bind] Press Advantage: Gain [SCALING] [TARGET] next round [[INITIAL] -> [RESULT]]" Target, Apply ailments #ChatButton)
	(CustomMessage "[/Bind] Press Advantage: Inflict **TYPE Fragility** on the target equal to half their **Bind**", #Clash #Result)
	(Reset, #Clash #Result)
#}


/* ---------------------------- */
/* Burn Support Effects */
/* ---------------------------- */
{# Detonate;
	(Proc Burn Target Silent, Clash Win, Detonate #ChatButton)
	(CustomMessage "[/Burn] Detonate: Activate **Burn**" Target, Clash Win, Detonate #ChatButton)
#}
{# Smokey Detonate;
	(Require 1 Burn Scaling Target Silent, Clash Win, Smokey Detonate #ChatButton)
	(Inflict 0.5 Smoke Silent, Clash Win, Smokey Detonate #ChatButton)
	(CustomMessage "[/TARGET] Gain [SCALING NUM] [TARGET] [[INITIAL] -> [RESULT]]" Target, Clash Win, Smokey Detonate #ChatButton)
	(Proc Burn Target, Clash Win, Smokey Detonate #ChatButton)
	(CustomMessage "Activate **Burn** on the target and inflict **Smoke** equal to the remaining **Burn**", Clash Win, Smokey Detonate #Section)
#}
{# Renewed Blaze;
	(Pause 1 Burn Target, Clash Win)
	(CustomMessage "Renewed Blaze: **Burn** on target does not decay for its next activation", Clash Win)
#}
{# Fireball N;
	(Require 1 Burn Scaling Target Silent, Clash Win, Fireball #ChatButton)
	(FlatDamage 1 Select, Clash Win, Fireball #ChatButton, Fireball Area Damage #ChatButton)
	(CustomMessage "Activate **Burn** on the target. All characters within N square(s) of the target take [SCALING] **Burn** damage (affected by resistances)", Clash Win, Fireball #Section)
	(Proc Burn Target, Clash Win, Fireball #ChatButton)
#}


/* --------------------------------- */
/* Frostbite Support Effects */
/* --------------------------------- */
{# Cold Snap #ChatButton;
	(Proc Frostbite Target, Clash Win, Cold Snap #ChatButton)
	(Consume 1 Frostbite Target Scaling, Clash Win, Cold Snap #ChatButton)
	(CustomMessage "Activate **Frostbite** on the target, then fully clear Frostbite", Clash Win, Cold Snap #ChatButton)
#}
{# Deep Chill;
	(Pause 1 Frostbite Target, Clash Win)
	(CustomMessage "Deep Chill: **Frostbite** on target does not decay for its next activation", Clash Win)
#}
{# Shatter #N;
	(CustomMessage [/limbus/Frostbite] Consumed **{3+#N} Frostbite** to deal **#Nd8** Force damage Target, Clash Win)
	(Consume 5 Frostbite Silent Target #IgnoreFailure, Clash Win )
	(CustomMessage "Shatter: Consume [-NUM] [TARGET] on the target to deal Force damage", Clash Win)
	(Reset, Clash Win)
#}
{# Chill Out #N;
	(Require {3+#N} Frostbite Target Silent #IgnoreFailure, Clash Win)
	(Require 2 Frostbite Scaling{3+#N} Target Silent #IgnoreFailure, Clash Win)
	(Inflict 1 Bind Silent, Clash Win)
	(CustomMessage Chill Out: Gain [SCALING] [TARGET] [[INITIAL] -> [RESULT]]" Target, Clash Win)
	(Reset, Clash Win)
	(CustomMessage "Chill Out: Inflict **Bind** to the target equal to half their **Frostbite**" Target, Apply ailments #ChatButton)
#}


/* ------------------------------- */
/* Smoke Support Effects */
/* ------------------------------- */


Ended off here!


Smoke - Gain N
Consumes X amount of Smoke on the target to gain N ailment. Requires targeting
{# Smoke - Gain Ailment N;
(Consume X Smoke Target, #Clash #Result #IgnoreFailure)
(Gain N Ailment, #Clash #Result)
(Reset, #Clash #Result)
#}
[Replace #Clash #Result with Clash Win or Clash Lose, or remove it and the comma before it if the effect is On Use. Replace X with the Smoke needed for the effect. Replace N with the gained ailment count. Replace Ailment with your ailment of choice]
Smoke - Inflict N
Consumes X amount of Smoke on the target to inflict N ailment. Requires targeting
{# Smoke - Inflict Ailment N;
(Consume X Smoke Target, #Clash #Result #IgnoreFailure)
(Inflict N Ailment, #Clash #Result)
(Reset, #Clash #Result)
#}
[Replace #Clash #Result with Clash Win or Clash Lose, or remove it and the comma before it if the effect is On Use. Replace X with the Smoke needed for the effect. Replace N with the inflicted ailment count. Replace Ailment with your ailment of choice]








/* ------------------------------- */
/* Combo Support Effects */
/* ------------------------------- */



{# Combo Cost X;
(Consume X Combo, Clash Win #IgnoreFailure) (Reset)
(Consume X Combo, Clash Lose #IgnoreFailure)

[Replace X with the total Combo cost of every Combo effect across the entire skill]
#}

{# Sweep N;
(Inflict 3*N Bind Silent, Clash Win)
(CustomMessage "[/limbus/FistGreen] Sweep: Gain [NUM] [TARGET] next round [[INITIAL] -> [RESULT]]" Target, Clash Win)
(CustomMessage "[/limbus/FistGreen] Sweep: Inflict [NUM] [TARGET] next round", Clash Win)
(Inflict 0 Burn Silent, Clash Win)

[Replace 3*N with the result of the calculation, and N with the effect potency. Dont change the last Inflict]
#}

{# Vital Strike N;
(FlatDamage 2*N HP Silent, Clash Win)
(CustomMessage "[/limbus/FistGreen] Vital Strike: Deal [NUM] [TARGET] Damage. Use the Apply Damage button twice if this was a reaction", Clash Win)
(CustomMessage "[/limbus/FistGreen] Vital Strike: Receive [-NUM] [TARGET] Damage" Target, Clash Win)
(FlatDamage 0 HP Silent, Clash Win)
#}
[Replace 2*N with the result of the calculation, and N with the effect potency. Dont change the last FlatDamage]
{# Knockout Strike N;
(FlatDamage N ST Silent, Clash Win)
(CustomMessage "[/limbus/FistGreen] Knockout Strike: Deal [NUM] [TARGET] Damage. Use the Apply Damage button twice if this was a reaction", Clash Win)
(CustomMessage "[/limbus/FistGreen] Knockout Strike: Receive [-NUM] [TARGET] Damage" Target, Clash Win)
(FlatDamage 0 ST Silent, Clash Win)
#}
[Replace 2*N with the result of the calculation, and N with the effect potency. Dont change the last FlatDamage]
{# Guard Up N;
(Gain N Protection Silent, Clash Win)
(Gain N Stagger_Protection Silent, Clash Win)
(Gain N Endurance Silent, Clash Win)
(CustomMessage "[/limbus/FistGreen] Guard Up: Gain [NUM] **Protection**, **Stagger Protection** and **Endurance** next round", Clash Win)
#}
[Replace N with the effect potency]

{# Feint;
(Pause 1 Combo)
(Pause 0 Combo, Clash Win)
(CustomMessage "[/limbus/FistGreen] Feint: Lose no **Combo**", Clash Lose)
#}
{# Stomp N;
(Give 2*N Bind Silent, Clash Win)
(CustomMessage "[/limbus/FistGreen] Stomp: Gain [NUM] [TARGET] next round [[INITIAL] -> [RESULT]]" Target, Clash Win)
(CustomMessage "[/limbus/FistGreen] Stomp: All creatures within **N** squares of the target gain [NUM] [TARGET] next round. Use Give Ailments to apply [TARGET]. Area becomes **Difficult terrain** for **2** turns. Can be avoided with an **Evade** roll vs. the original roll", Clash Win)
(Give 0 Burn Silent, Clash Win)
#}
[Replace 2*N with the result of the calculation, and N with the effect potency. Dont change the last FlatDamage]

{# Headlock;
(ChallengeRoll Fortitude 0 Silent, Clash Win)
(CustomMessage "[/limbus/FistGreen] Headlock: Rolling to Grapple target", Clash Win)
#}

/* ---------------------------------- */
/* Mark Skill Support Effects */
/* ---------------------------------- */
{# Steal Energy #N;
	(Gain {3*#N} Charge, Clash Win)
	(Consume #N Charge Target Silent #IgnoreFailure, Clash Win)
	(CustomMessage Reduce [TARGET] by [-NUM] [[INITIAL] -> [RESULT]] Target, Clash Win #ChatButton)
	(CustomMessage Steal Energy: Reduce **Charge** of target by **1**, Clash Win)
	(Reset, Clash Win)
#}


/* -------------------------------------- */
/* Charge Skill Support Effects */
/* -------------------------------------- */

{# Charge Cost X;
(Consume X Charge)
#}
[Replace X with the total Charge cost of every Charge effect across the entire skill]
{# Charge - Give Ailment N;
(Give N Ailment, #Clash #Result)
(CustomMessage Give ailments can be used on user or ally)
#}
[Replace Ailment with your ailment of choice. Replace N with the effect potency. Replace #Clash #Result with Clash Win, Clash Lose or remove it and the comma before it if On Use]

{# Charge - Flashy Extension N;
Treat this as Charge - Combo and follow the rules outlined at the start of this section
{# Charge - Repellent Barrier N;
(Require N Charge_Barrier Silent, #Clash #Result #IgnoreFailure)
(CustomMessage "[/TARGET] Repellent Barrier: Not enough [TARGET]" CheckFailure, CheckResult)
(CustomMessage "[/TARGET] Repellent Barrier: Push target [SCALING NUM] SQR away" CheckSuccess, #Clash #Result)
(Reset, #Clash #Result)
#}
[Replace N with the effect potency. Replace #Clash #Result with Clash Win, Clash Lose or remove it and the comma before it if On Use]





`;
/* --- Sheet Constants end --- */



/* --- orcsAsync+ --- */
// Includes all orcsAsync finctions, as well as two custom functions
function isRunningOnServer() { return self.dispatchEvent == undefined; }
function setActiveCharacterId(charId) {
    var oldActId=getActiveCharacterId();
    var msg={"id":"0", "type":"setActiveCharacter", "data":charId};
    
    if(isRunningOnServer()==false){ //if in a browser, use "dispatchEvent" to process the message
        var ev = new CustomEvent("message");
        ev.data=msg; 
        self.dispatchEvent(ev);
    }else{ //otherwise, use the API (server) message processor, "onmessage"
        self.onmessage({data:msg});
    }
    return oldActId; //return what the value used to be, so calling code can be a little cleaner 
} 
var _sIn=setInterval;
setInterval=function(callback, timeout) {
    var actId=getActiveCharacterId();
    _sIn(
        function(){
            var prevActId=setActiveCharacterId(actId);
            callback();
            setActiveCharacterId(prevActId);
        }
    ,timeout);
}
var _sto=setTimeout
setTimeout=function(callback, timeout) {
    var actId=getActiveCharacterId();
    _sto(
        function(){
            var prevActId=setActiveCharacterId(actId);
            callback();
            setActiveCharacterId(prevActId);
        }
    ,timeout);
}
function getAttrsAsync(props) {
    var actId=getActiveCharacterId(); //save the current activeCharacterID in case it has changed when the promise runs 
    var prevActId=null;               //local variable defined here, because it needs to be shared across the promise callbacks defined below
    return new Promise((resolve,reject)=>{
            prevActId=setActiveCharacterId(actId);  //in case the activeCharacterId has changed, restore it to what we were expecting and save the current value to restore later
            try{ getAttrs(props,(values)=>{ resolve(values); }); }
            catch{ reject(); }
    }).finally(()=>{
        setActiveCharacterId(prevActId); //restore activeCharcterId to what it was when the promise first ran
    });
}
function setAttrsAsync(propObj, options={}) {
    var actId=getActiveCharacterId();
    var prevActId=null;
    return new Promise((resolve,reject)=>{
            prevActId=setActiveCharacterId(actId);
            try{ setAttrs(propObj,options,(values)=>{ resolve(values); }); }
            catch{ reject(); }
    }).finally(()=>{
        setActiveCharacterId(prevActId);
    });
}
function getSectionIDsAsync(sectionName) {
    var actId = getActiveCharacterId();
    var prevActId=null;
    return new Promise((resolve,reject)=>{
            prevActId = setActiveCharacterId(actId);
            try{ getSectionIDs(sectionName,(values)=>{ resolve(values); }); }
            catch{ reject(); }
    }).finally(()=>{
        setActiveCharacterId(prevActId);
    });
}

/* Custom Async Functions */
/* Functions like getAttrs, except it gets values from another character! */
/* Requires the character_id of the target character. Works for both players and GMs */
function getAttrsById(actId, props) {
    var prevActId = getActiveCharacterId();
    return new Promise((resolve,reject)=>{
            setActiveCharacterId(actId);
            try{ getAttrs(props,(values)=>{ resolve(values); }); }
            catch{ reject(); }
    }).finally(()=>{
        setActiveCharacterId(prevActId);
    });
}

/* Functions like on(clicked:button), but also provides all eventinfo of a JQuery event on the same button */
/* Gives the following additional eventinfo: altKey, shiftKey, metaKey, ctrlKey, pageX, pageY */
/* JQuery becomes unresponsive after uploading *new* code in the sandbox. In this cases the function reverts to working like on(clicked:button) */
let setJQuery;
function onJQ(eventString, callback=()=>{}) {
	let buttonNames = eventString.replaceAll(/\b(clicked[:\w]*):(\w+)/g,`[name*="$2"]`).replace(" ", ", ");

	/* Register JQuery events */
	$20(buttonNames).on("click", async (e) => {
		if (typeof setJQuery == "undefined") {
			setJQuery = e;
		}
		else if (typeof setJQuery == "function") {
			setJQuery(e);
		}
	});
	
	/* Register on(click) events */
	on(eventString, async (info) => {
		let infoJQ = {}
		if (typeof setJQuery == "undefined") {
			infoJQ = await getJQuery(false, {});
		}
		else if (["object", "string"].includes(typeof setJQuery)) {
			infoJQ = setJQuery;
		}
		callback({...info, ...infoJQ});
		setJQuery = undefined; 
	});
}

const timeoutJQuery = 50;
function getJQuery(prop, onfail) {
	let actId = getActiveCharacterId();
	let jQueryPromise = new Promise(resolve => {
		if (prop) setJQuery = (e) => { resolve(e[prop]); } 		// If a property is specified, return that property
		else setJQuery = (e) => { resolve(e); }					// Otherwise return the entire eventinfo object from the JQuery event
		setTimeout(() => { resolve(onfail); }, timeoutJQuery); 	// If no JQuery event was called, returns a provided onfail value or undefined
	}).finally(() => {
		setActiveCharacterId(actId);
	});
	return jQueryPromise;
}

/* Does not function for players
function setAttrsById(actId, propObj, options={}) {
    var prevActId = getActiveCharacterId();
    return new Promise((resolve,reject)=>{
            setActiveCharacterId(actId);
            try{ setAttrs(propObj,options,(values)=>{
					setActiveCharacterId(prevActId);
					resolve(values); }); }
            catch{ reject(); }
    }).finally(()=>{
        setActiveCharacterId(prevActId);
    });
}*/
/* --- orcsAsync+ end --- */



/* --- Update Loop begins --- */
let loopDelay = 10000;
let trackerItemName = "Round end";
on('sheet:opened change:settingLoopEnabled change:configLoopDelay change:configTrackerItemName change:prevRoundInitAttempts', (info) => {
	getAttrs(["settingLoopEnabled", "configLoopDelay", "configTrackerItemName"], function(values) {
		setAttrs({"loopEnabled":"false"});
		if (values.settingLoopEnabled == "true") {
			loopDelay = parseInt(values.configLoopDelay);
			trackerItemName = values.configTrackerItemName;
			restartLoop();
		} else {
			setAttrs({"prevRoundInit": 0, "prevRoundInitAttempts":1});
		}
	});
});
function restartLoop() {
	setTimeout(function() {
		//console.log("reset complete")
		setAttrs({"loopEnabled":"true"});
	}, loopDelay + 1000);
}

on('change:loopEnabled', (info) => {
	if (info.newValue == "true") {
		getAttrs(["character_id"], function(values) {
			//console.log("beginning loop")
			stepLoop(values.character_id);
		});
	}
});
function stepLoop(charId) {
	setActiveCharacterId(charId);
	getAttrs(["loopEnabled", "prevRoundInitAttempts", "settingTargeting", "character_id", "targetId", "targetTokenId", "targetSettings", "settingLimbusStyle"], async function(values) {
		//console.log(values.prevRoundInitAttempts)
		if (values.loopEnabled == "true" && parseInt(values.prevRoundInitAttempts) < 6) {
			let output = {}

			/* Auto: Update */
			let newRoundInit = await getInitiative(trackerItemName);
			if (newRoundInit == "") {
				output = {...output, prevRoundInitAttempts: parseInt(values.prevRoundInitAttempts) + 1}
			} else {
				output = {...output, prevRoundInit: newRoundInit, prevRoundInitAttempts: 0}
			}

			/* Sync: Target Ailment/Bar lists */
			let targetSettings = Data.unpackage(values.targetSettings);
			updateTargetAttrLists(values.settingTargeting, values.character_id, values.targetId, values.targetTokenId, targetSettings, values.settingLimbusStyle, (targetAttrs) => {
				if (values.targetId != "") {
					setAttrs({...output, ...targetAttrs});
				} else {
					setAttrs(output);
				}
			});
			
			setTimeout(stepLoop.bind(this, charId), loopDelay);
		} else {
			//console.log("ending loop");
		}
	});
}

async function getInitiative(trackerName="") {
	let selectAttrs = {}
	let rollBase = `! {{trackerInitiative=[[0[@{tracker|${trackerName}}]]]}}`;
	let selectRoll = await startRoll(rollBase);
	let trackerInitiative = selectRoll.results.trackerInitiative.expression.match(/^0\[(.*)\]\s*$/)[1];
	finishRoll(selectRoll.rollId);
	return trackerInitiative;
}
on('change:prevRoundInit', (info) => {
	if (parseInt(info.newValue) < parseInt(info.previousValue)) {
		Update();
	}
})
/* --- Update Loop ends --- */



/* --- Token interaction functions --- */

/* Select token instance functionality */
on('clicked:selectToken', async function(info) {
	getTokenAttrs("selected", "select", "true");
});
on('clicked:repeating_tokens:selectinstance', async function(info) {
	setAttrs({"tokenId_selected":info.sourceAttribute.replace("repeating_tokens_","").replace("_selectinstance","")});
});

/* Gets the tokenId, tokenName and bar values of a token. Also gets the bar and bar max values from the sheet */
/* setSelectModes: select (always set selection or bars), false (do not set selection or bars), unset (set if unset)*/
function getTokenAttrs(target="selected", setSelectMode="false", queryGenericMode="false", callback=()=>{}) {
	getAttrs(["tokenId_selected", "settingGenericTokenMode"], function(values) {
		let tokenId_selected = values.tokenId_selected;
	
	/* If setting is disabled, ask if it should be enabled. Continue if yes */
	checkGenericMode(values.settingGenericTokenMode, queryGenericMode, async function(genericModeCheck) {
		if (genericModeCheck == "false") { return; }

		/* Get selected token attributes */
		let selectAttrs = {}
		let rollBase = `! {{token_id=[[0[@{${target}|token_id}]]]}} {{token_name=[[0[@{${target}|token_name}]]]}}
			{{HP=[[0[@{${target}|HP}]]]}} {{StagRes=[[0[@{${target}|StagRes}]]]}} {{SP=[[0[@{${target}|SP}]]]}}
			{{HP_max=[[0[@{${target}|HP_max}]]]}} {{StagRes_max=[[0[@{${target}|StagRes_max}]]]}} {{SP_max=[[0[@{${target}|SP_max}]]]}}
			{{bar1=[[0[@{${target}|bar1}]]]}} {{bar2=[[0[@{${target}|bar2}]]]}} {{bar3=[[0[@{${target}|bar3}]]]}}`.replaceAll("\n","").replaceAll("\t","");
		
		let selectRoll = await startRoll(rollBase);
		selectAttrs = {
			tokenName: selectRoll.results.token_name.expression.match(/^0\[(.*)\]\s*$/)[1],
			tokenId: selectRoll.results.token_id.expression.match(/^0\[(.*)\]\s*$/)[1].replaceAll("_",""),
			HP: selectRoll.results.HP.expression.match(/^0\[(.*)\]\s*$/)[1],
			StagRes: selectRoll.results.StagRes.expression.match(/^0\[(.*)\]\s*$/)[1],
			SP: selectRoll.results.SP.expression.match(/^0\[(.*)\]\s*$/)[1],
			HP_max: selectRoll.results.HP_max.expression.match(/^0\[(.*)\]\s*$/)[1],
			StagRes_max: selectRoll.results.StagRes_max.expression.match(/^0\[(.*)\]\s*$/)[1],
			SP_max: selectRoll.results.SP_max.expression.match(/^0\[(.*)\]\s*$/)[1],
			bar1: selectRoll.results.bar1.expression.match(/^0\[(.*)\]\s*$/)[1],
			bar2: selectRoll.results.bar2.expression.match(/^0\[(.*)\]\s*$/)[1],
			bar3: selectRoll.results.bar3.expression.match(/^0\[(.*)\]\s*$/)[1]
		}
		finishRoll(selectRoll.rollId);

		/* If token instance does not exist, ask if it should be added. Continue if yes */
		checkTokenInstance(selectAttrs, setSelectMode, async function(addTokenInstance) {
			if (addTokenInstance == "false") { return; };

		if (setSelectMode == "select" || setSelectMode == "add" || (setSelectMode == "unset" && tokenId_selected == "")) {
			setAttrs({"tokenId_selected":selectAttrs.tokenId});
		}

		/* If the token already exists, update its token bar values */
		getSectionIDs(`repeating_tokens`, async function(idarray) {
			if (idarray.includes(selectAttrs.tokenId.toLowerCase()) && setSelectMode != "false") {
				updateToken(selectAttrs, "tokenbars");
			}
		});

		callback(selectAttrs);
	});
	});
	});
}

/* Manipulate token instances functionality */
on('clicked:addToken', async function(info) {
	getTokenAttrs("selected", "add", "true", (selectAttrs) => {
		updateToken(selectAttrs);
	});
});
on('clicked:addTokenMultiple', async function(info) {
	addTokenMultiple();
});
function addTokenMultiple() {
	getTokenAttrs(`target|Target`, "add", "true", (selectAttrs) => {
		updateToken(selectAttrs);
		addTokenMultiple();
	});
}

on('clicked:deleteToken', async function(info) {
	getAttrs(["tokenId_selected"], function(values) {
		let selectedId = values.tokenId_selected;
		if (info.htmlAttributes != {}) {
			if (selectedId != "") {
				deleteToken(selectedId);
				setAttrs({"tokenId_selected":""});
			}
		} else {
			getTokenAttrs("selected", "false", "false", (selectAttrs) => {
				deleteToken(selectAttrs.tokenId);
				if (selectAttrs.tokenId == selectedId) {
					setAttrs({"tokenId_selected":""});
				}
			});
		}
	});
});
on('clicked:deleteTokenMultiple', async function(info) {
	getAttrs(["tokenId_selected"], async function(values) {
		let selectedId = values.tokenId_selected;
		deleteTokenMultiple(selectedId);
	});
});
function deleteToken(tokenId) {
	removeRepeatingRow("repeating_tokens_" + tokenId);
}
function deleteTokenMultiple(selectedId) {
	getTokenAttrs("target|Target", "false", "false", (selectAttrs) => {
		deleteToken(selectAttrs.tokenId);
		if (selectAttrs.tokenId == selectedId) {
			setAttrs({"tokenId_selected":""});
		};
		deleteTokenMultiple(selectedId);
	});
}

/* On changing the selected token, imports the status bars and ailments of that token */
on('change:tokenId_selected', (info) => {
	getAttrs(["tokenId_suppressUpdate", "settingGenericTokenMode"], function(values) {
		if (values.tokenId_suppressUpdate == "true") {
			setAttrs({"tokenId_suppressUpdate": "false"});
		} else {
			if (values.settingGenericTokenMode == "true") {
				/* Clears conditional buttons and re-generates any Permanent buttons */
				resetConditionals();
				AutoScriptMain("", "Permanent", "true", "true");

				updateSelectedToken(info);
			}
		}
	});
});
function updateSelectedToken(info, callback=()=>{}) {
	let output = {}
	
	/* Clear the old selection if there was one */
	if (info.previousValue && info.newValue) {
		output = {[`repeating_tokens_${info.previousValue}_token_selected`]:"false"}
	}

	/* Import values from new selection */
	if (info.newValue) {
		let tokenPrefix = `repeating_tokens_${info.newValue}`;
		let tokenValues = [`${tokenPrefix}_tokenAilmentList`];

		let barlist = ["HP", "StagRes", "SP", "Light"];
		barlist.forEach(bar => {
			tokenValues.push(`${tokenPrefix}_${bar}`/*, `${tokenPrefix}_${bar}_max`,*/);
		});

		let tempbarlist = ["THP", "TST"];
		tempbarlist.forEach(tempbar => {
			tokenValues.push(`${tokenPrefix}_token${tempbar}_Sources`);
		});

		let statelist = ["PanicState", "StaggerState", "StaggerDuration", "SealState", "ImmobileState", "DefeatState"];
		statelist.forEach(state => {
			tokenValues.push(`${tokenPrefix}_token${state}`, state);
		});

		getAttrs([...tokenValues], async function(values) {

			/* Set bars to that of the token instance */
			barlist.forEach(bar => {
				output[`${bar}`] = values[`${tokenPrefix}_${bar}`];
				/*output[`${bar}_max`] = values[`${tokenPrefix}_${bar}_max`];*/
			});

			tempbarlist.forEach(tempbar => {
				/* For temp bar values from ailments, add an override to make sure any ailment list updates do not change the temp bar value */
				let tempBarSourceRaw = values[`${tokenPrefix}_token${tempbar}_Sources`];
				let tempBarSource = Data.unpackage(tempBarSourceRaw);
				for (const [sourceName, sourceVals] of Object.entries(tempBarSource)) {
					if (sourceName != "AutoEffects") {
						output[`${sourceName.replace("ailnum","ailTempBarOverride")}`] = sourceVals[0];
					}
				}
				output[`${tempbar}_Sources`] = tempBarSourceRaw;
			});

			/* If a state changes between token, suppress the change event listener for the state */
			statelist.forEach(state => {
				output[`${state}`] = values[`${tokenPrefix}_token${state}`];
				if (output[`${state}`] != values[`${state}`]) {
					output[`${state}SuppressUpdate`] = "true";
				}
			});

			/* Sets ailments to those of the token instance. If ailmentList is unset, initialize a new empty ailmentList */
			let ailmentList = values[`${tokenPrefix}_tokenAilmentList`];
			if (ailmentList != "") {
				output = {...output, ...importAilmentList(Data.unpackage(ailmentList), "true")}
			} else {
				resetAilments(() => {
					exportAilmentList({}, function(newAilmentList) {
						setAttrs({[`${tokenPrefix}_tokenAilmentList`]: Data.package(newAilmentList)});
					});
				});
			}

			/* Set new selection */
			output[`${tokenPrefix}_token_selected`] = "true";
			setAttrs(output, {}, () => {
				callback();
			});
		});
	} else {
		setAttrs(output);
	}
}
function getSelectedToken(callback=()=>{}) {
	getAttrs(["tokenId_selected"], function(values) {
		callback(values.tokenId_selected);
	});
}

/* Hides token bar value in display if it matches that of the character sheet */
let barList = ["hp", "stagres", "sp", "light"];
barList.forEach(bar => {
	on(`change:repeating_tokens:${bar} change:repeating_tokens:${bar}_token`, (info) => {
		let attr_sheet = `${info.sourceAttribute}`;
		let attr_token = `${info.sourceAttribute}`;
		if (info.sourceAttribute.match(/_token/g).length == 2) {
			attr_sheet = `${info.sourceAttribute.replace(/_token([^_]*)$/, '$1')}`;
		} else {
			attr_token = `${info.sourceAttribute}` + "_token";
		}
		getAttrs(["settingGenericTokenMode", `${attr_sheet}`, `${attr_token}`], function(values) {
			if (values.settingGenericTokenMode == "true") {
				let bar_sheet = values[`${attr_sheet}`];
				let bar_token = values[`${attr_token}`];
				setAttrs({[`${attr_token + "_display"}`]:"" + (bar_sheet != bar_token)});
			}
		});
	});
});

/* Sync: Token Status bars */
barList.forEach(bar => {
	on(`change:${bar} change:repeating_tokens:${bar}`, (info) => {
		if (info.newValue) {
			getAttrs(["tokenId_selected", "settingGenericTokenMode", "character_id", "targetedBy"], function(values) {
				if (values.settingGenericTokenMode == "true") {
					let selectedId = values.tokenId_selected;
					if (selectedId != "") {
						if (barList.includes(info.sourceAttribute)) {
							setAttrs({[`repeating_tokens_${selectedId}_${bar}`]:info.newValue});
						} else {
							if (info.sourceAttribute.includes(selectedId.toLowerCase())) {
								setAttrs({[`${bar}`]:info.newValue});
							}

							/* Announce instance bar change */
							//let tokenId = info.sourceAttribute.match(/(-[\w\d]{19})/)[0];
							//announceBarChange(Data.unpackage(values.targetedBy), values.character_id, tokenId, `${bar}_target`, info.newValue);
						}
					}
				}
			});
		}
	});
});

/* Sync: Token Temporary status bars */
let tempBarList = ["thp", "tst"];
tempBarList.forEach(tempBar => {
	on(`change:${tempBar}_sources`, (info) => {
		if (info.newValue) {
			getAttrs(["tokenId_selected", "settingGenericTokenMode"], function(values) {
				if (values.settingGenericTokenMode == "true") {
					let selectedId = values.tokenId_selected;
					if (selectedId != "") {
						if (tempBarList.includes(info.sourceAttribute.replace("_sources", ""))) {
							setAttrs({[`repeating_tokens_${selectedId}_token${tempBar}_sources`]:info.newValue});
						}
					}
				}
			});
		}
	});
});

/* Sync: Token States */
let stateList = ["panicstate", "staggerstate", "staggerduration", "sealstate", "immobilestate", "defeatstate"];
stateList.forEach(state => {
	on(`change:${state}`, (info) => {
		getAttrs(["tokenId_selected", "settingGenericTokenMode"], function(values) {
			if (values.settingGenericTokenMode == "true") {
				let selectedId = values.tokenId_selected;
				if (selectedId != "") {
					if (stateList.includes(info.sourceAttribute)) {
						/* newValue will in some cases not be set when decreasing staggerduration. This ensures the value is properly decreased */
						if (info.newValue == undefined && info.sourceAttribute == "staggerduration") {
							info.newValue = parseInt(info.previousValue) - 1;
						}
						setAttrs({[`repeating_tokens_${selectedId}_token${state}`]:info.newValue});
					}
				}
			}
		});
	});
});

/* Sync: Token Ailments */
on(`change:ailmentList`, (info) => {
	if (info.newValue) {
		getAttrs(["tokenId_selected", "settingGenericTokenMode", "settingLimbusStyle"], function(values) {
			if (values.settingGenericTokenMode == "true") {
				let ailmentList = Data.unpackage(info.newValue);
				let selectedId = values.tokenId_selected;
				if (selectedId != "") {
					setAttrs({
						[`repeating_tokens_${selectedId}_tokenAilmentList`]: info.newValue,
						...updateAilmentDisplay(`repeating_tokens_${selectedId}_token`, 4, ailmentList, values.settingLimbusStyle, "true")
					});
				}
			}
		});
	}
});
for (let i = 0; i <= 4; i++) {
	on(`change:repeating_tokens:tokenAilment${i}Num`, (info) => {
		if (info.newValue) {
			let tokenPrefix = info.sourceAttribute.match(/(repeating_tokens_[^_]+)/g)[0];
			let tokenIndex = info.sourceAttribute.match(/([\d])num/g)[0].replace("num","");
			//let tokenId = info.sourceAttribute.match(/(-[\w\d]{19})/g)[0];

			getAttrs(["tokenId_selected", "settingGenericTokenMode", "settingLimbusStyle", `${tokenPrefix}_tokenAilmentList`,
				`${tokenPrefix}_tokenAilment${tokenIndex}Name`, `${tokenPrefix}_tokenAilment${tokenIndex}Num`, "character_id", "targetedBy"], function(values) {
				
				if (values.settingGenericTokenMode == "true") {

					let selectedId = values.tokenId_selected;
					let ailmentList = Data.unpackage(values[`${tokenPrefix}_tokenAilmentList`]);
					let ailmentName = values[`${tokenPrefix}_tokenAilment${tokenIndex}Name`];
					let ailmentNum = values[`${tokenPrefix}_tokenAilment${tokenIndex}Num`];
					let output = {}
	
					ailmentList[ailmentName][1] = ailmentNum;
					ailmentList[ailmentName][3] = ailmentNum;
					output[`${tokenPrefix}_tokenAilmentList`] = Data.package(ailmentList);
	
					if (tokenPrefix.includes(selectedId.toLowerCase())) {
						output["ailmentList"] = Data.package(ailmentList);
						if (ailmentList[ailmentName][5] != 0) {
							output[`repeating_ailments_${ailmentList[ailmentName][5]}_ailNum`] = ailmentNum;
						} else {
							output[`${ailmentName}`] = ailmentNum;
						}
					}
					setAttrs(output);

					/* Announce instance ailment change */
					//announceAilmentChange(Data.unpackage(values.targetedBy), values.character_id, tokenId, ailmentList, values.settingLimbusStyle);
				}
			});
		}
	});
}
function updateAilmentDisplay(ailmentPrefix, ailmentDisplayCount, ailmentList, settingLimbusStyle, returnMode="false") {
	let ailmentDisplayList = [];
	if (length(ailmentList) > 0) {
		for (var ailmentName in ailmentList) {
			ailmentDisplayList.push([ailmentName, ailmentList[ailmentName]]);
		}
		ailmentDisplayList.sort(function(ail1, ail2) {
			return ail1[1][1] - ail2[1][1];
		});
		ailmentDisplayList = ailmentDisplayList.slice(ailmentDisplayList.length - ailmentDisplayCount).reverse();
		
		let output = {}
		for (i = 0; i < ailmentDisplayCount; i++) {
			output[`${ailmentPrefix}Ailment${i+1}Icon`] = getIcon("ailments", ailmentDisplayList[i][1][6], settingLimbusStyle, "url");
			output[`${ailmentPrefix}Ailment${i+1}Num`] = ailmentDisplayList[i][1][1];
			output[`${ailmentPrefix}Ailment${i+1}Name`] = ailmentDisplayList[i][0];
		}
	
		if (returnMode == "true") {
			return output;
		} else {
			setAttrs(output);
		}
	} else {
		return resetAilmentDisplay(ailmentPrefix, ailmentDisplayCount, returnMode="false")
	}
}
function resetAilmentDisplay(ailmentPrefix, ailmentDisplayCount, returnMode="false") {
	let output = {}
	for (i = 0; i < ailmentDisplayCount; i++) {
		output[`${ailmentPrefix}Ailment${i+1}Icon`] = "";
		output[`${ailmentPrefix}Ailment${i+1}Num`] = 0;
		output[`${ailmentPrefix}Ailment${i+1}Name`] = "";
	}
	if (returnMode == "true") {
		return output;
	} else {
		setAttrs(output);
	}
}

on('change:settingGenericTokenMode', (info) => { 
	if (info.newValue == "0") {
		getSectionIDs(`repeating_tokens`, async function(idarray) {
			idarray.forEach(tokenId => {
				removeRepeatingRow("repeating_tokens_" + tokenId);
			});
			setAttrs({"tokenId_selected":""});
		});
	}
});

on('change:settingTargeting', (info) => {
	getAttrs(["character_id", "targetId"], function(values) {
		if (info.newValue == "0") {
			setAttrs({...resetTarget(values.character_id, values.targetId, "true"), "lastDefenceRoll": 0});
		}
	});
});

/* Sync: Action number */
/*on(`change:actNum change:repeating_tokens:actNum`, (info) => {
	
});*/


/* --- Token helper functions --- */
async function checkGenericMode(genericMode, executeQuery, callback=()=>{}) {
	if (genericMode != "true" && executeQuery == "true") {
		let queryResults = await sendQuery(["enableGenericMode",
			getTranslationByKeyCustom("Generic token mode not enabled for sheet. Enable setting?", "query-enable-generic-mode"), {
				[getTranslationByKeyCustom("No","query-no")]:"false",
				[getTranslationByKeyCustom("Yes","query-yes")]:"true"
			}
		]);
		if (queryResults.enableGenericMode == "true") {
			setAttrs({"settingGenericTokenMode":"true"});
		}
		callback(queryResults.enableGenericMode);
	} else {
		callback(genericMode);
	}
}
async function checkTokenInstance(selectAttrs, setSelectMode, callback=()=>{}) {
	getSectionIDs(`repeating_tokens`, async function(idarray) {
		if (!idarray.includes(selectAttrs.tokenId.toLowerCase()) && setSelectMode == "select") {
			let queryResults = await sendQuery(["addTokenInstance",
				getTranslationByKeyCustom("Token does not have a token instance. Add instance?", "query-add-token-instance"), {
					[getTranslationByKeyCustom("No","query-no")]:"false",
					[getTranslationByKeyCustom("Yes","query-yes")]:"true"
				}
			]);
			if (queryResults.addTokenInstance == "true") {
				updateToken(selectAttrs);
			}
			callback(queryResults.addTokenInstance)
		} else {
			callback("true")
		}
	});
}
async function updateToken(selectAttrs, mode="full") {
	getSectionIDs(`repeating_global`, idarray => {
		let id = `repeating_global_${idarray[0]}`;
	
	getAttrs([`${id}_settingBar1`, `${id}_settingBar2`, `${id}_settingBar3`, "HP_max", "StagRes_max", "SP_max", "Light_max"], function(values) {
		selectAttrs = {...selectAttrs, barHP: values.HP_max, barStagRes: values.StagRes_max, barSP: values.SP_max}
		for (let i = 1; i <= 3; i++) {
			/* Matches token bars to the correct status bars */
			if (values[`${id}_settingBar${i}`] != "None") { selectAttrs[`bar${values[`${id}_settingBar${i}`]}`] = selectAttrs[`bar${i}`]; }
		}

		let tokenPrefix = `repeating_tokens_${selectAttrs.tokenId}`;
		let tokenValues = {
			[`${tokenPrefix}_tokenName`]:selectAttrs.tokenName,
			[`${tokenPrefix}_tokenId`]:selectAttrs.tokenId,
			[`${tokenPrefix}_HP`]:selectAttrs.barHP, [`${tokenPrefix}_HP_max`]:values.HP_max, // Supposed to be selectAttrs.HP_max. Currently bugged and gives the default value (30) and not the calculated value
			[`${tokenPrefix}_StagRes`]:selectAttrs.barStagRes, [`${tokenPrefix}_StagRes_max`]:values.StagRes_max, // Supposed to be selectAttrs.StagRes_max
			[`${tokenPrefix}_SP`]:selectAttrs.barSP, [`${tokenPrefix}_SP_max`]:values.SP_max, // Supposed to be selectAttrs.SP_max
			[`${tokenPrefix}_Light`]:values.Light_max, [`${tokenPrefix}_Light_max`]:values.Light_max,
		}
		if (mode == "tokenbars") {
			tokenValues = {}
		}
		tokenValues = {...tokenValues,
			[`${tokenPrefix}_HP_token`]:selectAttrs.barHP,
			[`${tokenPrefix}_StagRes_token`]:selectAttrs.barStagRes,
			[`${tokenPrefix}_SP_token`]:selectAttrs.barSP
		}
		setAttrs(tokenValues);
	});
	});
}
async function changeActiveToken(tokenId, callback=()=>{}) {
	getAttrs(["settingGenericTokenMode", "tokenId_selected"], function(values) {
		if (values.settingGenericTokenMode != "true" || tokenId == "" || tokenId == values.tokenId_selected) {
			callback();
		} else {
			/* Makes certain the tokenId update is being suppressed before setting the attribute */
			setAttrs({"tokenId_suppressUpdate": "true"}, {}, () => {
				setAttrs({"tokenId_selected": tokenId}, {}, () => {
					let info = {newValue: tokenId}
					if (values.tokenId_selected != "") { info.previousValue = values.tokenId_selected; }
					updateSelectedToken(info, ()=>{
						callback();
					});
				});
			})
		}
	});
}
/* --- Token interaction functions end  --- */



/* --- Select target functionality --- */
async function getTargetAttrs(attrList, callback=()=>{}) {
	
	let rollBase = "! ";
	attrList.forEach(attribute => {
		rollBase += `{{${attribute}=[[0[@{target|${attribute}}]]]}}`;
	});
	
	let targetRoll = await startRoll(rollBase);
	
	let values = {}
	attrList.forEach(attribute => {
		values[attribute] = targetRoll.results[attribute].expression.match(/^0\[(.*)\]\s*$/)[1];
	});
	finishRoll(targetRoll.rollId);

	callback(values);
}

on('clicked:selectTarget', (info) => {
	getAttrs(["settingTargeting", "character_id", "character_name", "settingLimbusStyle", "targetId"], function(selfValues) {
		getTargetAttrs(["character_id", "character_name", "selfToken", "token_name", "token_id",
			"settingGenericTokenMode", "settingHideBarUpdate", "settingHideDetailsFromTargeting", "settingLimbusStyle"], async function(targetValues) {

			let targetSettings = {
				"genericTokenMode": targetValues.settingGenericTokenMode,
				"hideBarUpdate": targetValues.settingHideBarUpdate,
				"hideDetailsFromTargeting": targetValues.settingHideDetailsFromTargeting,
				"settingLimbusStyle": targetValues.settingLimbusStyle
			}
			let output = {
				"targetId": targetValues.character_id,
				"targetName": targetValues.character_name,
				"targetToken": targetValues.selfToken,
				"targetTokenId": targetValues.token_id.replaceAll("_",""),
				"targetTokenName": targetValues.token_name,
				"targetSettings": Data.package(targetSettings)
			}

			if (output.targetId.includes("@{target|") || output.targetId == selfValues.character_id) {
				resetTarget(selfValues.character_id, selfValues.targetId);
			} else {
				isValidTarget(selfValues.character_name, selfValues.character_id, output.targetId, output.targetTokenId, targetSettings, (result) => {
					if (result) {
						updateTargetAttrLists(selfValues.settingTargeting, selfValues.character_id, output.targetId, output.targetTokenId, targetSettings, selfValues.settingLimbusStyle, (targetAttrs) => {
							setAttrs({...output, ...targetAttrs});
							//checkGM(output.targetId, selfValues.character_id, () => {
							//	setAttrsById(output.targetId, addTargeting(selfValues.character_id, output.targetTokenId));
							//	setActiveCharacterId(selfValues.character_id);
							//});
						});
					} else {
						resetTarget(selfValues.character_id, selfValues.targetId);
					}
				});
			}
		});
	}); 
});


/* Callback if the character is controlled by a GM */
/* If isGM is currently unset, executes a test to check if the character is a GM or not */
/*var isGM = "unset";
on("sheet:opened", function(info) {
	getAttrs(["targetId", "character_id", "testIsGM"], function(values) {
		if (values.targetId != "" && values.targetId) {
			checkGM(values.targetId, values.character_id);
		}
		if (values.testIsGM == "unset") {
			setAttrs({"testIsGM": values.character_id});
		}
	});
})
async function checkGM(targetId, charId, callback=()=>{}) {
	if (targetId != "" && targetId != charId) {
		if (isGM == "unset") {
			let initialValue = await getAttrsById(targetId, ["testIsGM"]);
			let newValue = await setAttrsById(targetId, {"testIsGM": (initialValue.testIsGM != charId) ? charId : generateRowID()});
			let finalValue = await getAttrsById(targetId, ["testIsGM"]);
			setActiveCharacterId(charId);
			initialValue = initialValue.testIsGM;
			finalValue = finalValue.testIsGM;
			
			if (initialValue != "unset" && initialValue != finalValue && (initialValue == charId || finalValue == charId)) {
				isGM = "true";
				callback();
			} else {
				isGM = "false";
				return;
			}
		} else if (isGM == "true") {
			callback();
		} else {
			return;
		}
	}
}


/* Field used by other characters to announce they are targeting the character */
/*on("change:announceTargeting", function(info) {
	getAttrs(["targetedBy"], function(values) {
		updateTargetedBy(Data.unpackage(info.newValue), Data.unpackage(values.targetedBy));
	});
});
function updateTargetedBy(input, targetedBy) {
	
	if(isGM == "true") {
		if (input.remove) {
			delete targetedBy[input.remove];
		}
		if (input.add) {
			targetedBy = {...targetedBy, ...input.add}
		}
		setAttrs({"targetedBy": Data.package(targetedBy)});
	}
}
function addTargeting(charId, targetTokenId, package="package") {
	let targetingData = {"announceTargeting": {"remove": charId, "add": {[`${charId}`]: targetTokenId}}}
	if (package == "package") { targetingData.announceTargeting = Data.package(targetingData.announceTargeting) }
	return targetingData;
}
function removeTargeting(charId, package="package") {
	let targetingData = {"announceTargeting": {"remove": charId}}
	if (package == "package") { targetingData.announceTargeting = Data.package(targetingData.announceTargeting) }
	return targetingData;
}*/

/* Checks if a token is an invalid target. Currently happens if genericTokenMode is enabled but the token has not been added as an instance  */
async function isValidTarget(characterName, charId, targetId, targetTokenId, targetSettings, callback=()=>{}) {
	if (targetSettings.genericTokenMode == "true") {
		let values = await getAttrsById(targetId, [`repeating_tokens_${targetTokenId}_tokenId`]);
		setActiveCharacterId(charId);
		
		if (targetTokenId != values[`repeating_tokens_${targetTokenId}_tokenId`]) {
			
			let alertIcon = getIcon("ailments", "Aggro", "true", "markdown");
			let alertMessage = getTranslationByKeyCustom("Invalid Target: Token is not a token instance", "message-invalid-target");
			startRoll((`/w ${characterName} &{template:errorMessage} {{icon=${alertIcon}}} {{message=${alertMessage}}}`), (results) => {
				finishRoll(results.rollId);
			});

			callback(false);
		} else {
			callback(true);
		}
	} else {
		callback(true);
	}
}

async function updateTargetAttrLists(settingTargeting, charId, targetId, targetTokenId, targetSettings, settingLimbusStyle, callback=()=>{}) {
	if (settingTargeting != "0" && targetId != "" && targetId) {
		
		let output = {}
		
		/* Get target attributes  */
		let targetPrefix = (targetSettings.genericTokenMode == "true") ? `repeating_tokens_${targetTokenId}_` : "";
		let targetBarAttrs = barList.reduce((rows,bar) => [...rows, `${targetPrefix}${bar}`, `${targetPrefix}${bar}_max`], '');
		let targetAilmentListName = (targetSettings.genericTokenMode == "true") ? `${targetPrefix}tokenAilmentList` : "ailmentList";

		let values = await getAttrsById(targetId, [...targetBarAttrs, ...statNames, ...resourceNames, ...resourceNames.map(r => r+'_max'), targetAilmentListName]);
		setActiveCharacterId(charId);

		/* Update target bar lists */
		let targetBarList = {}
		let targetBarMaxList = {}
		let targetBarDamageList = {}
		barList.forEach(bar => {
			let barName = "";
			switch (bar) {
				case "hp": barName = "HP"; break;
				case "stagres": barName = "ST"; break;
				case "sp": barName = "SP"; break;
				case "light": barName = "Light"; break;
			}
			targetBarList[`${barName}`] = parseInt(values[`${targetPrefix}${bar}`]);
			targetBarMaxList[`${barName}`] = parseInt(values[`${targetPrefix}${bar}_max`]);
			targetBarDamageList[`-${barName}`] = targetBarMaxList[`${barName}`] - targetBarList[`${barName}`];
		});

		if (targetSettings.hideDetailsFromTargeting == "true") {
			output = unknownTarget();
		} else if (targetSettings.hideBarUpdate == "true") {
			output = {"HP_target":"???", "StagRes_target":"???", "SP_target":"???"}
		} else {
			output = {"HP_target":targetBarList.HP, "StagRes_target":targetBarList.ST, "SP_target":targetBarList.SP}
		}

		/* Update target ailment list */
		let targetAilmentList = values[targetAilmentListName] || "{}";
		if (targetAilmentList != "{}") {
			output = {...output, ...updateAilmentDisplay("target", 6, Data.unpackage(targetAilmentList), settingLimbusStyle, "true")}
		}

		/* Update target resources. Uses new vars system */
		let targetResourceVars = resourceNames.reduce((acc, attr) => Object.assign(acc, {[`target${attr}`]:parseInt(values[attr]), [`target${attr}_max`]:parseInt(values[`${attr}_max`])}), {});

		/* Update target stats. Uses new vars system */
		let targetStatVars = Object.entries(values).filter(attr => statNamesFull.includes(attr[0])).reduce((acc, attr) => Object.assign(acc, {["target"+updateStatName(attr[0])]:parseInt(attr[1])}), {});
		
		if (callback != "()=>{}") {
			callback({...output, targetBarList, targetBarMaxList, targetBarDamageList, targetAilmentList, targetStatVars, targetResourceVars});
		} else {
			setAttrs(output);
		}
	} else {
		callback({});
	}
}

/*function announceAilmentChange(targetedBy, charId, tokenId, ailmentList, settingLimbusStyle) {
	if (isGM == "true") {
		let output = updateAilmentDisplay("target", 6, ailmentList, settingLimbusStyle, "true");
		for (const [targeterId, targetedTokenId] of Object.entries(targetedBy)) {
			if (tokenId == 0 || tokenId == targetedTokenId.toLowerCase()) {
				setAttrsById(targeterId, output);
				setActiveCharacterId(charId);
			}
		}
	}
}
function announceBarChange(targetedBy, charId, tokenId, barName, barVal) {
	if (isGM == "true") {
		for (const [targeterId, targetedTokenId] of Object.entries(targetedBy)) {
			if (tokenId == 0 || tokenId == targetedTokenId.toLowerCase()) {
				setAttrsById(targeterId, {[`${barName}`]: barVal});
				setActiveCharacterId(charId);
			}
		}
	}
}*/

function resetTarget(charId, targetId, returnMode="false") {
	//setAttrsById(targetId, removeTargeting(charId));
	//setActiveCharacterId(charId);
	
	let output = {
		...resetAilmentDisplay("target", 6, "true"),
		"targetId": "",
		"targetName": "",
		"targetToken": "",
		"targetTokenId": "",
		"targetTokenName": "",
		"targetSettings": "{}",
		"HP_target":"---",
		"StagRes_target":"---",
		"SP_target":"---"
	}

	if (returnMode == "true") {
		return output;
	} else {
		setAttrs(output);
	}
}
function unknownTarget(returnMode="false") {
	let output = {
		...resetAilmentDisplay("target", 6, "true"),
		"targetTokenName": "?????",
		"HP_target":"???",
		"StagRes_target":"???",
		"SP_target":"???"
	}

	if (returnMode == "true") {
		return output;
	} else {
		setAttrs(output);
	}
}
/* --- Select target functionality end --- */



/* --- Action button functionality --- */

/* Creates one or more action buttons and post them to the chat */
/* Taken in a buttonList of the format: {target1: {name1: {icon, color, data, type}, name2: {...}, ...}, target2: {...}, ...} */
/*   size: One of "half" or "third". Used for styling the width of chat buttons */
/* The reactions option can be included to show reaction buttons. If set to a tokenId, the buttons will target that generic token (if it exists) */
async function createChatButtons(buttonList, options={reactions:false}) {
	getAttrs(["settingHideChatButtons", "settingWhisperRolls", "settingWhisperTarget"], async function(values) {

	if (values.settingHideChatButtons == "true") { return; }

	let whisperrolls = values.settingWhisperRolls;
	let whispertarget = values.settingWhisperTarget;
	let i = 0;

	/* Include reaction buttons if requested */
	if (options.reactions !== false) {
		/* If all buttons use selected, show the buttons to all characters. Otherwise only show reaction buttons for targeted characters */
		if (buttonList.selected && length(buttonList) == 1) {
			buttonList.selected = {...generateReactionButtons(), ...buttonList.selected}
		} else {
			for (const buttonTarget of Object.keys(buttonList).filter(key => key != "selected")) {
				buttonList[buttonTarget] = {...generateReactionButtons(options.reactions), ...buttonList[buttonTarget]}
			}
		}
	}

	for (const [buttonTarget, buttons] of Object.entries(buttonList)) {

		/* Whisper roll */
		let whispermode = whisper = "";
		if(whisperrolls == "true") {
			whisper =  `/w ${whispertarget} `;
			whispermode = "Whisper";
		}
		else if (buttonTarget != "selected") {
			whisper =  `/w ${buttonTarget} `
			whispermode = "Whisper";
		}

		let rollBase = whisper + `&{template:chatbuttons} {{whisperMode=${whispermode}}} `;
		
		for (const [buttonName, buttonValues] of Object.entries(buttons)) {
			
			rollBase += `{{${buttonValues.size}Button${i++}=[${buttonValues.color}](${buttonValues.icon})[${buttonName}](~${buttonTarget}|${buttonValues.transferFunction}||${Data.package(buttonValues.data)})}}`;

			/* If targeting, add targeting update data to the action button */
			//if (isGM == "false" && dataList[`targetid${i}`] == targetName) {
			//	let targetingData = (targetId != "" && targetId) ? addTargeting(charId, targetTokenId, "unpackage") : removeTargeting(charId, "unpackage");
			//	dataList[`datapackage${i}`] = {...dataList[`datapackage${i}`], ...targetingData};
			//}
			//dataList[`datapackage${i}`] = Data.package(dataList[`datapackage${i}`]);
		}
		let buttonRoll = await startRoll(rollBase);
		finishRoll(buttonRoll.rollId);
	}
	});
}

function generateChatButton(buttonList, target, name, icon, color, data, transferFunction, size) {
	name = name.replace(/(Apply damage)/ig, getTranslationByKeyCustom("Apply damage", "helper-text-applydamage"));
	name = name.replace(/(Apply ailments)/ig, getTranslationByKeyCustom("Apply ailments", "helper-text-applyailments"));
	name = name.replace(/(Give ailments)/ig, getTranslationByKeyCustom("Give ailments", "helper-text-giveailments"));

	let newButton = {icon:icon, color:color, data:data, transferFunction:transferFunction, size:size}
	
	/* Create new button. If the button already exist, append the AutoEffect to the button's AutoScript */
	if (buttonList[target] && buttonList[target][name]) {
		buttonList[target][name].data.buttonAutoScript += data.buttonAutoScript;
	} else {
		if (!buttonList[target]) { buttonList[target] = {} }
		buttonList[target][name] = newButton;
	}
	return buttonList;
}

function generateReactionButtons(targetTokenId="") {
	return {
		"Counter": {
			"icon": "https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/icons/Attack.png",
			"color": "red",
			"data": {"roll":"attack", "reaction":"true", "targetTokenId":targetTokenId},
			"size": "third",
			"transferFunction": "chatButtonRoll"
		},
		"Block": {
			"icon": "https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/icons/defend.png",
			"color": "blue",
			"data": {"roll":"block", "reaction":"true", "targetTokenId":targetTokenId},
			"size": "third",
			"transferFunction": "chatButtonRoll"
		},
		"Evade": {
			"icon": "https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/icons/evade.png",
			"color": "yellow",
			"data": {"roll":"evade", "reaction":"true", "targetTokenId":targetTokenId},
			"size": "third",
			"transferFunction": "chatButtonRoll"
		}
	}
}

/* Action button functions */
on('clicked:chatButtonDamage', async (data) => {
	getAttrs(["lastDefenceRoll", "targetedBy"], async function(values) {
		
		let defenceRoll = parseInt(values.lastDefenceRoll);
		data = Data.unpackage(data.originalRollId);
		chatButtonTokenIdHelper(data.targetTokenId, async (tokenId) => {

			/* If the damage type is unset (such as for ranged weapon) query the player for a damage type */
			if (data.damageTypeOverride == "---") {
				let queryResults = await sendQuery(["damageTypeOverride",
					getTranslationByKeyCustom("Select damage type of attack", "query-damage-type"), {
						[getTranslationByKeyCustom("---", "weapon-type-None")]:"None",
						[getTranslationByKeyCustom("Slash","weapon-type-Slash")]:"Slash",
						[getTranslationByKeyCustom("Pierce","weapon-type-Pierce")]:"Pierce",
						[getTranslationByKeyCustom("Blunt","weapon-type-Blunt")]:"Blunt"
					}
				]);
				data.damageTypeOverride = queryResults.damageTypeOverride;
			}

			/* If taking Light damage, process it as an Add AutoEffect */
			if (data.flatLightOverride && data.flatLightOverride != 0) {
				data.autoScriptOverride = `(Add -${data.flatLightOverride} Light)`;
			}

			damageHelper({...data, tokenId: tokenId}, defenceRoll);

			//updateTargetedBy(data.announceTargeting, Data.unpackage(values.targetedBy));
			setAttrs({"lastDefenceRoll": 0});
		});
	});
});
on('clicked:chatButtonRoll', async (data) => {
	data = Data.unpackage(data.originalRollId);
	chatButtonTokenIdHelper(data.targetTokenId, (tokenId) => {
		
		let rollType = (data.roll == "attack") ? "weapon1"
					 : (data.roll == "block") ? "def"
					 : (data.roll == "evade") ? "evd"
					 : "unknown roll";
		
		rollCombat({htmlAttributes: {id: "autoroll_" + rollType}}); // Still need to use data.reaction to indicate if the roll is an action or a reaction
	});
});
on('clicked:chatButton', async (data) => {
	//getAttrs(["targetedBy"], async function(values) {
		data = Data.unpackage(data.originalRollId);
		chatButtonTokenIdHelper(data.targetTokenId, (tokenId) => {
			AutoScriptMain(data.buttonAutoScript, "None", "false", "true", { tokenId: tokenId }, () => {}, data.buttonName);
		});
		//updateTargetedBy(data.announceTargeting, Data.unpackage(values.targetedBy));
	//});
});

/* Helper function that gets and returns the selected token's instance if generic token mode is enabled */
/* If a tokenId is provided by the action button (the enemy is using targeting) no token needs to be selected */
function chatButtonTokenIdHelper(targetTokenId, callback=()=>{}) {
	getAttrs(["settingGenericTokenMode"], function(values) {
		if (targetTokenId == "" && values.settingGenericTokenMode == "true") {
			getTokenAttrs("selected", "unset", "false", (selectAttrs) => {
				callback(selectAttrs.tokenId);
			});
		} else {
			callback(targetTokenId);
		}
	});
}
/* --- Action button functionality --- */



/* Auto: Recalculate derived stats */
on("change:instinct change:wisdom change:justice change:charm change:insight change:temperance change:repeating_global", function() {
getSectionIDs(`repeating_global`, idarray => {
        let id = `repeating_global_${idarray[0]}`;

	getAttrs(["instinct", "wisdom", "justice", "charm", "insight", "temperance", "distortState", "settingTestOption", 
	`${id}_healthBase`, `${id}_healthStat`, `${id}_healthStatMod`, `${id}_healthRankMod`,
	`${id}_staggerBase`, `${id}_staggerStat`, `${id}_staggerStatMod`, `${id}_staggerRankMod`,
	`${id}_sanityBase`, `${id}_sanityStat`, `${id}_sanityStatMod`, `${id}_sanityRankMod`,
	`${id}_lightBase`, `${id}_lightRankMod`, `${id}_distortLightBase`, `${id}_distortLightRankMod`,
	`${id}_attStat`, `${id}_defStat`, `${id}_evdStat`,
	`${id}_burnNextTurnSetting`, `${id}_bleedNextTurnSetting`, `${id}_smokeNextTurnSetting`, `${id}_chargeNextTurnSetting`,
	`${id}_lightRegenBase`, `${id}_lightRegenRankMod`, `${id}_lightRegenStatMod`,
	`${id}_actionBase`, `${id}_actionRankMod`, `${id}_reactionBase`, `${id}_reactionRankMod`, `${id}_actionTradeReaction`], function(values) {

	let instinctVal = parseInt(values.instinct);
	let wisdomVal = parseInt(values.wisdom);
	let justiceVal = parseInt(values.justice);
	let charmVal = parseInt(values.charm);
	let insightVal = parseInt(values.insight);
	let temperanceVal = parseInt(values.temperance);

	let distortState = values.distortState;
	let optionstate = values.settingTestOption;

	let healthBase = parseInt(values[`${id}_healthBase`]);
	let healthStat = values[`${id}_healthStat`];
	let healthStatMod = parseInt(values[`${id}_healthStatMod`]);
	let healthRankMod = parseInt(values[`${id}_healthRankMod`]);

	let staggerBase = parseInt(values[`${id}_staggerBase`]);
	let staggerStat = values[`${id}_staggerStat`];
	let staggerStatMod = parseInt(values[`${id}_staggerStatMod`]);
	let staggerRankMod = parseInt(values[`${id}_staggerRankMod`]);

	let sanityBase = parseInt(values[`${id}_sanityBase`]);
	let sanityStat = values[`${id}_sanityStat`];
	let sanityStatMod = parseInt(values[`${id}_sanityStatMod`]);
	let sanityRankMod = parseInt(values[`${id}_sanityRankMod`]);

	let lightBase = parseInt(values[`${id}_lightBase`]);
	let lightRankMod = parseInt(values[`${id}_lightRankMod`]);

	let dlightBase = parseInt(values[`${id}_distortLightBase`]);
	let dlightRankMod = parseInt(values[`${id}_distortLightRankMod`]);

	let attStat = values[`${id}_attStat`];
	let defStat = values[`${id}_defStat`];
	let evdStat = values[`${id}_evdStat`];

	let burnNextTurn = values[`${id}_burnNextTurnSetting`];
	let bleedNextTurn = values[`${id}_bleedNextTurnSetting`];
	let smokeNextTurn = values[`${id}_smokeNextTurnSetting`];
	let chargeNextTurn = values[`${id}_chargeNextTurnSetting`];

	let [lightRegenBase, lightRegenRankMod, lightRegenStatMod] = [parseFloat(values[`${id}_lightRegenBase`]), parseFloat(values[`${id}_lightRegenRankMod`]), parseFloat(values[`${id}_lightRegenStatMod`])]
	let [actionBase, actionRankMod, reactionBase, reactionRankMod] = [parseFloat(values[`${id}_actionBase`]), parseFloat(values[`${id}_actionRankMod`]), parseFloat(values[`${id}_reactionBase`]), parseFloat(values[`${id}_reactionRankMod`])]
	let actionTradeReaction = values[`${id}_actionTradeReaction`]

	let ranknew = parseInt((instinctVal+wisdomVal+justiceVal+charmVal+insightVal+temperanceVal)/(6));
	let rnum = Math.min(ranknew, 6);
	let worknew = "4";

	if (ranknew > 5) {
	ranknew = "EX";
	worknew = "8";
	} else {
		switch (ranknew) {
			case 2: case 3: worknew = "6"; break;
			case 4: case 5: worknew = "8"; break;
	} 
	}

	let hpnew = parseInt(healthBase + (instinctVal * healthStatMod) + (rnum * healthRankMod));
	let stagresnew = parseInt(staggerBase + (charmVal * staggerStatMod) + (rnum * staggerRankMod));
	let spnew = parseInt(sanityBase + (wisdomVal * sanityStatMod) + (rnum * sanityRankMod));
	let mixVal = "";

	if(healthStat == "InstinctTemperance"){
	mixVal = parseInt((instinctVal + temperanceVal)/2);
	hpnew = parseInt(healthBase + (mixVal * healthStatMod) + (rnum * healthRankMod));
	}

	if(staggerStat == "CharmJustice"){
	mixVal = parseInt((charmVal + justiceVal)/2);
	stagresnew = parseInt(staggerBase + (mixVal * staggerStatMod) + (rnum * staggerRankMod));
	}

	if(sanityStat == "WisdomInsight"){
	mixVal = parseInt((wisdomVal + insightVal)/2);
	spnew = parseInt(sanityBase + (mixVal * sanityStatMod) + (rnum * sanityRankMod));
	}

	let lightnew = parseInt((rnum * lightRankMod) + lightBase);
	if(distortState == "true"){
	lightnew = parseInt((rnum * dlightRankMod) + dlightBase);
	}

	/* Att, Def, Evd Calculation */
	let newAtt = instinctVal;
	let newDef = temperanceVal;
	let newEvd = insightVal;

	switch (attStat) {
		case "Rank": newAtt = rnum; break;
		case "InstinctRank": newAtt = parseInt(instinctVal) + parseInt(rnum); break;
		case "InstinctWisdom": newAtt = parseInt((instinctVal + wisdomVal)/2); break;
	}

	switch (defStat) {
		case "Rank": newDef = rnum; break;
		case "TemperanceRank": newDef = parseInt(temperanceVal) + parseInt(rnum); break;
		case "TemperanceCharm": newDef = parseInt((temperanceVal + charmVal)/2); break;
	}

	switch (evdStat) {
		case "Rank": newEvd = rnum; break;
		case "InsightRank": newEvd = parseInt(insightVal) + parseInt(rnum); break;
		case "InsightJustice": newEvd = parseInt((insightVal + justiceVal)/2); break;
	}

	/* Base resource counts and settings */
	let newLightRegenBase = Math.max(parseInt(lightRegenBase + (rnum * lightRegenRankMod) + (wisdomVal * lightRegenStatMod)), 0);
	let [newActionBase, newReactionBase] = [Math.max(parseInt(actionBase + (rnum * actionRankMod)), 1), Math.max(parseInt(reactionBase + (rnum * reactionRankMod)), 0)]

	setAttrs({
		"charRankBase":ranknew, "charRankNum":rnum,
		"HP_max":hpnew, "StagRes_max":stagresnew, "SP_max":spnew, "Light_max":lightnew,
		"distortWorkBase":worknew, "attPower":newAtt, "defPower":newDef, "evdPower":newEvd,
		"burnNextTurnSetting":burnNextTurn, "bleedNextTurnSetting":bleedNextTurn, "smokeNextTurnSetting":smokeNextTurn, "chargeNextTurnSetting":chargeNextTurn,
		"Light_Regen_base":newLightRegenBase, "Action_base":newActionBase, "Reaction_base":newReactionBase, "actionTradeReaction":actionTradeReaction
	});
	});
	});
});

/* Recalculate level */
on("change:EXP change:repeating_global:expCalc", function(){
getSectionIDs(`repeating_global`, idarray => {
        let id = `repeating_global_${idarray[0]}`;

	getAttrs(["EXP", `${id}_expCalc`], function(values) {
		let exp = parseInt(values.EXP);
		let calc = parseInt(values[`${id}_expCalc`]);
		let newlevel = parseInt(exp/calc);

		setAttrs({"level":newlevel});
		});
	});
});

/* Set Icon Style */
on("change:settingLimbusStyle change:repeating_global:iconStyle", function(info) {
getSectionIDs(`repeating_global`, idarray => {
    let id = `repeating_global_${idarray[0]}`;
	
	setAttrs({"settingLimbusStyle":info.newValue, [`${id}_iconStyle`]:info.newValue});
	});
});

/* Change stagger duration */
on("change:repeating_global:staggerDurationMax", function() {
getSectionIDs(`repeating_global`, idarray => {
	let id = `repeating_global_${idarray[0]}`;
	
	getAttrs(["StaggerDuration", `${id}_staggerDurationMax`], function(values) {
	
	if (values.StaggerDuration != values[`${id}_staggerDurationMax`]) {
		setAttrs({"StaggerDuration":values[`${id}_staggerDurationMax`]});
	}
	});
	});
});

/* Edit toggle */
on("change:settingHideShare", function() {
	setAttrs({"settingEditMode":"0"});
});

/* Auto: Community Rules (Test) */
on("change:settingTestOption", function() {
getAttrs(["settingTestOption", "instinct", "charRankNum"], function(values) {
	let state = values.settingTestOption;

	/* Rank-based Attack Power */
	let instinct = parseInt(values.instinct);
	let charRankNum = parseInt(values.charRankNum);
	
	if (state == "true") {
		setAttrs({"attPower":charRankNum});
	} else {
		setAttrs({"attPower":instinct});
	}
	});
});

/* Auto: Setting Evade influence */
on("change:settingEvdInfluence", function() {
getSectionIDs(`repeating_global`, idarray => {
        let id = `repeating_global_${idarray[0]}`;

	getAttrs(["settingEvdInfluence", `${id}_evdAilment`, "insight", "Haste", "Bind", "Endurance", "Disarm"], function(values) {
	let evdinfluence = values[`${id}_evdAilment`];
	let newevd = "0";	
	let insight = parseInt(values.insight);
	let positive = 0;
	let negative = 0;
	
	if (evdinfluence == "HasteBind") {
		positive = parseInt(values.Haste);
		negative = parseInt(values.Bind);
		setAttrs({"evdPositive":positive, "evdNegative":negative});
	} else {
		positive = parseInt(values.Endurance);
		negative = parseInt(values.Disarm);
		setAttrs({"evdPositive":positive, "evdNegative":negative});
	}
	});
	});
});

/* Auto: Set Distortion state */
on("change:distortState", function() {
getSectionIDs(`repeating_global`, idarray => {
        let id = `repeating_global_${idarray[0]}`;

	getAttrs(["distortState", "distortStateTemp", "character_name", "character_nameBase", "distort_name", "egoCondition", "egoConditionTemp", "settingDistortSave", "editorInput", "editorOutput", `${id}_lightBase`, `${id}_lightRankMod`, `${id}_distortLightBase`, `${id}_distortLightRankMod`, "charRankNum"], function(values) {
	let state = values.distortState;
	let prevstate = values.distortStateTemp;

	let updatename = "";
	let origname = values.character_name;
	let basename = values.character_nameBase;
	let distortname = values.distort_name;
	let distortstring = getTranslationByKeyCustom("Distorted", "message-distorted");
	let newcondition = "";
	let currentcondition = values.egoCondition;
	let prevcondition = values.egoConditionTemp;
	let save = values.settingDistortSave;

	let rnum = parseInt(values.charRankNum);

	let lightBase = parseInt(values[`${id}_lightBase`]);
	let lightRank = parseInt(values[`${id}_lightRankMod`]);

	let dlightBase = parseInt(values[`${id}_distortLightBase`]);
	let dlightRank = parseInt(values[`${id}_distortLightRankMod`]);

	let light = values.Light_max;

	if(prevcondition == "" || (state == "true" && prevcondition != currentcondition)){
		prevcondition = values.egoCondition;
	}

	if(origname != "" && basename == ""){
		basename = origname;
		newcondition = prevcondition;
	}

	if(state == "true" && distortname != ""){
		updatename = distortname;
		newcondition = "AlwaysActive";
	}
	else if(state == "true" && distortname == ""){
		updatename = basename + " (" + distortstring + ")";
		newcondition = "AlwaysActive";	
	}
	else {
		newcondition = prevcondition;
		updatename = basename;
	}

	/* Auto Save/Load data */
	if (save == "true") {
		let input = values.editorInput;
		let output = values.editorOutput;
		setAttrs({"editorOutput":input, "editorInput":output});
		dataExport("All");
		dataImport();
	}

	if (state == "true") {
		light = parseInt((rnum * dlightRank) + dlightBase);
	} else {
		light = parseInt((rnum * lightRank) + lightBase);
	}

	setAttrs({"character_nameBase":basename, "character_name":updatename, "Light_max":light, "Light":light});
	});
	});
});

/* Auto: Update Distortion Name */
on("change:distort_name", function() {
	getAttrs(["distortState", "distort_name", "character_nameBase"], function(values) {
	let name = values.distort_name;
	let basename = values.character_nameBase;
	let state = values.distortState;
	let distortstring = getTranslationByKeyCustom("Distorted", "message-distorted");

	if(state == "true" && name != ""){
		setAttrs({"character_name":name});
	}
	else if(state == "true" && name == ""){
		setAttrs({"character_name":`${basename} (${distortstring})`});
	}
	});
});

/* Auto: Update Base name */
on("change:character_nameBase", function() {
	getAttrs(["distortState", "character_name", "character_nameBase"], function(values) {
	let name = values.character_name;
	let basename = values.character_nameBase;
	let state = values.distortState;

	if(state != "true" && name != basename){
	setAttrs({"character_name":basename});
	}
	});
});

/* Auto: Initialize Base name and distort state */
on("sheet:opened", function() {
	getAttrs(["distortState", "character_name", "character_nameBase"], function(values) {
	let name = values.character_name;
	let basename = values.character_nameBase;
	let state = values.distortState;

	if(state != "true" && basename != name){
		setAttrs({"character_nameBase":name});
		setAttrs({"distortState":"0"});
	}
	});
});

/* Auto: Initialize token image url */
/* character_token and character_avatar cannot be retrieved from outside the charactersheet. As such a copy is made which can be retrieved */
on("sheet:opened", function() {
	getAttrs(["character_token", "selfToken"], function(values) {
		let token = values.character_token;
		let selfToken = values.selfToken;

		if(token != selfToken){
			setAttrs({"selfToken": token});
		}
	});
});

/* Auto: Detect empty Temp Bar source */
/* The sheet doesn't properly detect these fields for some reason.  */
on("sheet:opened", function() {
	getAttrs(["THP_Sources", "TST_Sources"], function(values) {
		setAttrs({"THP_Sources": values.THP_Sources, "TST_Sources": values.TST_Sources});
	});
});



/* Auto: Recalc Advantage state */
on("change:advNum change:disadvNum", function() {
	getAttrs(["advNum", "disadvNum"], function(values) {
	let currentadv = parseInt(values.advNum);
	let currentdisadv = parseInt(values.disadvNum);
	let newstate = "0";

	if (currentadv > currentdisadv) { newstate = "Advantage"; }
	else if (currentdisadv > currentadv) { newstate = "Disadvantage"; }

	setAttrs({"advNum":currentadv, "disadvNum":currentdisadv, "advState":newstate});
	});
});

/* Auto: Recalc Advantages */
on("change:Fortune change:Paralysis", function() {
	getAttrs(["Fortune", "Paralysis"], function(values) {
	let currentadv = parseInt(values.Fortune);
	let currentdisadv = parseInt(values.Paralysis);
	
	let newadv = Math.max(currentadv - currentdisadv, 0);
	let newdisadv = Math.max(currentdisadv - currentadv, 0);
	let newstate = "0";

	if (newadv > newdisadv) { newstate = "Advantage"; }
	else if (newdisadv > newadv) { newstate = "Disadvantage"; }

	setAttrs({"advNum":newadv, "disadvNum":newdisadv, "advState":newstate});
	});
});

/* Auto: EGO - Clear skill select */
on("change:egoActiveState", function() {
	getAttrs(["egoActiveState"], function(values) {
	let egostate = values.egoActiveState;
	let output = {};

	if(egostate == "0"){
		output["skillSelect"] = "0";
	}
	output["toolSelect"] = "";

	setAttrs(output);
	});
});

/* Auto: Skill loadout change - Clear skill select */
let skillList = "";
for (let i = 1; i <= 6; i++) { skillList += `change:skill${i}Type change:egoSkill${i}Type`; }
on(skillList, function() {
	setAttrs({"skillSelect":"0"});
});



/* Auto: Detect Hostile */
on("change:distortCounter", function() {
	getAttrs(["settingAutoDetect", "HostileState", "distortCounter"], function(values) {
	let detect = values.settingAutoDetect;
	let hostilestate = values.HostileState;
	let currentcounter = parseInt(values.distortCounter);

	/* AutoDetect check */
	if(detect != "0"){
		if(currentcounter <= 0 && hostilestate == "0"){
			setAttrs({"HostileState":"Hostile"});
		}
		else if(currentcounter > 0 && hostilestate != "0"){
		setAttrs({"HostileState":"0"});
		}
	}
	});
});

/* Auto: Detect Stagger */
on("change:StagRes", function() {
	getSectionIDs(`repeating_global`, idarray => {
        let id = `repeating_global_${idarray[0]}`;

	getAttrs(["StagRes", "StaggerState", `${id}_staggerDurationMax`, "settingGenericTokenMode", "character_id", "targetedBy"], function(values) {
	let currentstag = parseInt(values.StagRes);
	let currentstate = values.StaggerState;
	let statedurationmax = parseInt(values[`${id}_staggerDurationMax`]);

	if (currentstag <= 0 && currentstate == "0") {
		setAttrs({"StaggerState":"Staggered", "StaggerDuration":statedurationmax});
	}

	/* Announce update */
	//if (values.settingGenericTokenMode != "true") {
	//	announceBarChange(Data.unpackage(values.targetedBy), values.character_id, 0, "StagRes_target", currentstag);
	//}
	});
		});
});

/* Auto: Detect Panic */
on("change:SP", function() {
	getAttrs(["settingAutoDetect", "settingMuteMessage", "settingGenericTokenMode", "PanicState", "SP", "character_id", "targetedBy"], function(values) {
	let detect = values.settingAutoDetect;
	let mutemessage = values.settingMuteMessage;
	let panicstate = values.PanicState;
	let currentsan = parseInt(values.SP);

	/* AutoDetect check */
	if(detect != "0"){
		if(currentsan <= 0 && panicstate == "0"){
			setAttrs({"PanicState":"Panic"});
		}
		else if(currentsan > 0 && panicstate != "0"){
		setAttrs({"PanicState":"0"});
		}
	}

	/* Announce update */
	//if (values.settingGenericTokenMode != "true") {
	//	announceBarChange(Data.unpackage(values.targetedBy), values.character_id, 0, "SP_target", currentsan);
	//}
	});
});



/* Auto: HP related updates (Detect Defeat, Detect EGO activation) */
on("change:HP", function() {
	getAttrs(["settingAutoDetect", "settingMuteMessage", "settingGenericTokenMode",
	"DefeatState", "egoActiveState", "HP", "HP_max", "egoCondition", "character_id", "targetedBy"], function(values) {
	let detect = values.settingAutoDetect;
	let mutemessage = values.settingMuteMessage;
	let defeatstate = values.DefeatState;
	let iconnew = "";
	let currenthp = parseInt(values.HP);
	let halfhp = parseInt((values.HP_max) / 2);
	let egocon = values.egoCondition;
	let egostate = values.egoActiveState;

	/* EGO check*/
	if(egocon == "HalfHealth" && currenthp <= halfhp && egostate != "true"){
		setAttrs({"egoActiveState":"true"});
	}

	/* Defeat check */
	if(currenthp <= 0 && detect != "0" && defeatstate == "0"){

		setAttrs({"DefeatState":"Defeated"});

	}

	/* Announce update */
	//if (values.settingGenericTokenMode != "true") {
	//	announceBarChange(Data.unpackage(values.targetedBy), values.character_id, 0, "HP_target", currenthp);
	//}
	});
});



/* Auto: Hostile State updates */
on("change:HostileState", function() {
	getAttrs(["distortCounter", "distortCounter_max", "HostileState", "settingWhisperRolls", "settingWhisperTarget", "settingMuteMessage", "messageOverride", "settingLimbusStyle"], async function(values) {

	let currentstate = values.HostileState;
	let currentcounter = values.distortCounter;
	let messagestate = values.settingMuteMessage;
	let overridecheck = values.messageOverride;

	/* Whisper roll */
	let whisperrolls = values.settingWhisperRolls;
	let whispertarget = values.settingWhisperTarget;
	let whisper = "";
	if(whisperrolls == "true"){
	whisper = "/w " + whispertarget;
	}

	if(overridecheck == "true"){
	messagestate = "true";
	setAttrs({"messageOverride":"0"});
	}

	if(currentstate != "Hostile" && currentcounter == "0"){
	let newcounter = values.distortCounter_max;
	setAttrs({"distortCounter":newcounter});
	}
	
	if(messagestate != "true") {
		let iconnew = getIcon("ailments", "Hostile", values.settingLimbusStyle, "markdown");
		let langState = (currentstate == "Hostile")
			? getTranslationByKeyCustom(" is Hostile!", "message-hostile1")
			: getTranslationByKeyCustom(" is no longer Hostile.", "message-hostile2");
	
		let results = await startRoll((whisper + `&{template:message} {{icon=${iconnew}}} {{name=@{character_name}}} {{message=${langState}}}`));
        finishRoll(results.rollId);
	}
	});
});

/* Auto: Panic State updates */
on("change:PanicState", function(info) {
	getAttrs(["PanicStateSuppressUpdate", "SP", "PanicState", "settingWhisperRolls", "settingWhisperTarget", "settingMuteMessage", "messageOverride", "settingLimbusStyle"], async function(values) {
	if (values.PanicStateSuppressUpdate == "true") { setAttrs({"PanicStateSuppressUpdate":"false"}); return; }

	let currentstate = values.PanicState;
	let messagestate = values.settingMuteMessage;
	let overridecheck = values.messageOverride;
	let overrideeffect = values.settingHideBaseEffect;

	/* Whisper roll */
	let whisperrolls = values.settingWhisperRolls;
	let whispertarget = values.settingWhisperTarget;
	let whisper = "";
	if(whisperrolls == "true"){
	whisper = "/w " + whispertarget;
	}

	if(overridecheck == "true"){
	messagestate = "true";
	setAttrs({"messageOverride":"0"});
	}

	/* AutoScripts */
	resetConditionals();
	let autoScriptTrigger = (currentstate == "Panic") ? "Panic" : "None";
	AutoScriptMain("", autoScriptTrigger, "true", "true", {}, ()=>{}, getTranslationByKeyCustom("Panic", "autoeffect-trigger-panic"));
	
	if(messagestate != "true") {
		let iconnew = getIcon("ailments", "Panic", values.settingLimbusStyle, "markdown");
		let langState = (currentstate == "Panic")
			? getTranslationByKeyCustom(" went into Panic!", "message-panic1")
			: getTranslationByKeyCustom(" is no longer Panicked", "message-panic2");
	
		let results = await startRoll((whisper + `&{template:message} {{icon=${iconnew}}} {{name=@{character_name}}} {{message=${langState}}}`));
		finishRoll(results.rollId);
	}
	});
});

/* Auto: Defeat State updates */
on("change:DefeatState", function() {
	getAttrs(["DefeatStateSuppressUpdate", "DefeatState", "settingWhisperRolls", "settingWhisperTarget", "settingMuteMessage", "messageOverride", "settingLimbusStyle"], async function(values) {
	if (values.DefeatStateSuppressUpdate == "true") { setAttrs({"DefeatStateSuppressUpdate":"false"}); return; }

	let currentstate = values.DefeatState;
	let messagestate = values.settingMuteMessage;
	let overridecheck = values.messageOverride;

	/* Whisper roll */
	let whisperrolls = values.settingWhisperRolls;
	let whispertarget = values.settingWhisperTarget;
	let whisper = "";
	if(whisperrolls == "true"){
		whisper = "/w " + whispertarget;
	}

	if(overridecheck == "true"){
	messagestate = "true";
	setAttrs({"messageOverride":"0"});
	}

	/* AutoScripts */
	resetConditionals();
	AutoScriptMain("", "Defeated", "true", "true", {}, ()=>{}, getTranslationByKeyCustom("Defeated", "autoeffect-trigger-defeated"));
	
	if(messagestate != "true" && currentstate == "Defeated"){
		let iconnew = getIcon("ailments", "Defeat", values.settingLimbusStyle, "markdown");
		let langDefeat = getTranslationByKeyCustom(" can no longer fight.", "message-defeat");

		let results = await startRoll((whisper + `&{template:message} {{icon=${iconnew}}} {{name=@{character_name}}} {{message=${langDefeat}}}`));
		finishRoll(results.rollId);
	}
	});
});

/* Auto: Stagger State updates */
on("change:StaggerState change:StaggerDuration", function(info) {
	//console.log(info)
	
getSectionIDs(`repeating_global`, idarray => {
    let id = `repeating_global_${idarray[0]}`;

	getAttrs([`${info.sourceAttribute}SuppressUpdate`, "StagRes", "StaggerState", "StaggerDuration", "settingWhisperRolls", "settingWhisperTarget", "settingMuteMessage", "SP", "egoCondition", "egoActiveState", "messageOverride", "distortState", `${id}_staggerSanity`, `${id}_staggerDurationMax`, "settingLimbusStyle"], function(values) {
	if (values[`${info.sourceAttribute}SuppressUpdate`] == "true") { setAttrs({[`${info.sourceAttribute}SuppressUpdate`]:"false"}); return; }

	let type = (info.sourceAttribute == "staggerduration") ? "duration" : "state";
	let currentstate = values.StaggerState;
	let stateduration = parseInt(values.StaggerDuration);
	let statedurationmax = parseInt(values[`${id}_staggerDurationMax`]);
	let messagestate = values.settingMuteMessage;
	let egocon = values.egoCondition;
	let egostate = values.egoActiveState;
	let sanity = parseInt(values.SP) - parseInt(values[`${id}_staggerSanity`]);
	let output = {}
	
	/* Aborts the function if staggerduration is set to its max value. Hinders a double messages when Staggered or Unstaggered (StaggerState and StaggerDuration are both changed) */
	if (type == "duration" && stateduration == statedurationmax) { return; }

	if(type == "state" && egocon == "OnStagger" && currentstate != "0"){
		output.egoActiveState = "true";
	}
	if(type == "state" && currentstate == "Staggered" && values.distortState != "true") {
		output.SP = sanity;
	}

	let overridecheck = values.messageOverride;
	if(overridecheck == "true"){
		messagestate = "true";
		output.messageOverride = "0";
	}

		/* AutoScripts */
	if (type == "state" && currentstate == "Staggered") {
		resetConditionals();
		let autoScriptTrigger = currentstate == "Staggered" ? "Staggered" : "None";
		AutoScriptMain("", autoScriptTrigger, "true", "true", {}, ()=>{}, getTranslationByKeyCustom("Staggered", "autoeffect-trigger-staggered"));
	}

	/* Whisper roll */
	let whisperrolls = values.settingWhisperRolls;
	let whispertarget = values.settingWhisperTarget;
	let whisper = "";
	if(whisperrolls == "true"){
		whisper = "/w " + whispertarget;
	}

	/* Chat message */
	if(messagestate != "true") {
	let iconnew = getIcon("ailments", "FragileStagger", values.settingLimbusStyle, "markdown");
	let langStateTrue = getTranslationByKeyCustom(" is Staggered!", "message-stagger1");
	let langStateFalse = getTranslationByKeyCustom(" is no longer Staggered.", "message-stagger2");
	let langStateDurationNextRound = getTranslationByKeyCustom(" will stop being Staggered next round.", "message-stagger3");
	let langStateDurationMultiRound = getTranslationByKeyCustom(" will stop being Staggered in ", "message-stagger4") + parseInt(stateduration + 1) + " " + getTranslationByKeyCustom("rounds", "message-round-plural");
	let messageDescription = "";

	if (type == "state" && currentstate == "Staggered") {
		messageDescription = langStateTrue;
	}
	else if (type == "duration" && stateduration == 0) {
		messageDescription = langStateDurationNextRound;
	}
	else if (type == "duration" && stateduration < statedurationmax) {
		messageDescription = langStateDurationMultiRound;
	}
	else if (type == "state" && currentstate != "Staggered") {
		messageDescription = langStateFalse;
	}
	
		startRoll((whisper + `&{template:message} {{icon=${iconnew}}} {{name=@{character_name}}} {{message=${messageDescription}}}`), (results) => {
            finishRoll(results.rollId);
			setAttrs(output);
        });
	} else {
		setAttrs(output);
	}
	});
	});
});

/* Auto: Immobile State updates */
on("change:ImmobileState", function() {
	getAttrs(["ImmobileStateSuppressUpdate", "ImmobileState", "settingWhisperRolls", "settingWhisperTarget", "settingMuteMessage", "messageOverride", "settingLimbusStyle"], async function(values) {
	if (values.ImmobileStateSuppressUpdate == "true") { setAttrs({"ImmobileStateSuppressUpdate":"false"}); return; }

	let currentstate = values.ImmobileState;
	let messagestate = values.settingMuteMessage;
	let overridecheck = values.messageOverride;

	if(overridecheck == "true"){
		messagestate = "true";
		setAttrs({"messageOverride":"0"});
	}

	/* Whisper roll */
	let whisperrolls = values.settingWhisperRolls;
	let whispertarget = values.settingWhisperTarget;
	let whisper = "";
	if(whisperrolls == "true"){
		whisper = "/w " + whispertarget;
	}

	if(messagestate != "true") {
		let iconnew = getIcon("ailments", "Immobile", values.settingLimbusStyle, "markdown");
		let langState = (currentstate == "Immobile")
			? getTranslationByKeyCustom(" is Immobile!", "message-immobile1")
			: getTranslationByKeyCustom(" is no longer Immobile.", "message-immobile2");
	
		let results = await startRoll((whisper + `&{template:message} {{icon=${iconnew}}} {{name=@{character_name}}} {{message=${langState}}}`));
		finishRoll(results.rollId);
	}
	});
});

/* Auto: Seal State updates */
on("change:SealState", function() {
	getAttrs(["SealStateSuppressUpdate", "SealState", "settingWhisperRolls", "settingWhisperTarget", "settingMuteMessage", "messageOverride", "settingLimbusStyle"], async function(values) {
	if (values.SealStateSuppressUpdate == "true") { setAttrs({"SealStateSuppressUpdate":"false"}); return; }

	let currentstate = values.SealState;
	let messagestate = values.settingMuteMessage;
	let overridecheck = values.messageOverride;

	if(overridecheck == "true"){
		messagestate = "true";
		setAttrs({"messageOverride":"0"});
	}

	/* Whisper roll */
	let whisperrolls = values.settingWhisperRolls;
	let whispertarget = values.settingWhisperTarget;
	let whisper = "";
	if(whisperrolls == "true"){
	whisper = "/w " + whispertarget;
	}

	if(messagestate != "true") {
		let iconnew = getIcon("ailments", "Seal", values.settingLimbusStyle, "markdown");
		let langState = (currentstate == "Seal")
			? getTranslationByKeyCustom(" is Sealed!", "message-seal1")
			: getTranslationByKeyCustom(" is no longer Sealed.", "message-seal2");
	
		let results = await startRoll((whisper + `&{template:message} {{icon=${iconnew}}} {{name=@{character_name}}} {{message=${langState}}}`));
		finishRoll(results.rollId);
	}
	});
});

/* Auto: Update Evd power (Endurance/Disarm) */
on("change:Endurance change:Disarm", function() {

getSectionIDs(`repeating_global`, idarray => {
        let id = `repeating_global_${idarray[0]}`;

	getAttrs(["settingEvdInfluence", `${id}_evdAilment`, "evdPositive", "evdNegative", "Endurance", "Disarm"], function(values) {
	let evdinfluence = values[`${id}_evdAilment`];

	let endurancenum = parseInt(values.Endurance);
	let disarmnum = parseInt(values.Disarm);

	/* Update Evd */
	if(evdinfluence == "EnduranceDisarm"){
		setAttrs({"evdPositive":endurancenum, "evdNegative":disarmnum});
	}
	});
	});
});

/* Auto: Update calculated speed | Update Evd power (Haste/Bind) */
on("change:Haste change:Bind change:thisRoundSpeed change:baseSpeed", function() {
getSectionIDs(`repeating_global`, idarray => {
    let id = `repeating_global_${idarray[0]}`;

	getAttrs(["settingTurnUpdate", "baseSpeed", "prevSpeed", "thisRoundSpeed", "Haste", "Bind", "character_name", "settingEvdInfluence", `${id}_evdAilment`, "evdPositive", "evdNegative"], function(values) {
	let turnupdate = values.settingTurnUpdate;
	let evdinfluence = values[`${id}_evdAilment`];

	let basespeed = parseInt(values.baseSpeed);
	let prevspeed = parseInt(values.prevSpeed);
	let thisRoundSpeed = parseInt(values.thisRoundSpeed);

	let hastenum = parseInt(values.Haste);
	let bindnum = parseInt(values.Bind);
	let name = values.character_name;
	let newspeed = basespeed + hastenum - bindnum + thisRoundSpeed;
	let command = "[[" + newspeed + "&{tracker} ]]";
	let message = "Speed update: ";
	
	setAttrs({"calcSpeed":newspeed, "prevSpeed":newspeed});

	/* Update Evd */
	if(evdinfluence == "HasteBind"){
	setAttrs({"evdPositive":hastenum, "evdNegative":bindnum});

	}

	if(turnupdate == "true"){
	if(prevspeed != newspeed){
	startRoll("/w @{character_name} Speed updated: [[@{calcSpeed} &{tracker}]]", (results) => {
            finishRoll(results.rollId, {} );
       			 });
			}
		}	
	});
	});
});


/* Auto: Update ailment and tool icons */
on("sheet:opened", function(info) {
	getSectionIDs(`repeating_ailments`, idarray => {
	let fieldnames = idarray.reduce((rows,id) => [...rows, `repeating_ailments_${id}_ailIcon`, `repeating_ailments_${id}_ailIconDisplay`], '');
	for (let i = 1; i <= 4; i++) { fieldnames = [...fieldnames, `tool${i}Icon`, `tool${i}IconDisplay`] }

	getAttrs([...fieldnames,], function(values) {
	let output = {}
	
	idarray.forEach(id => {
		if (!(values[`repeating_ailments_${id}_ailIconDisplay`].includes("http"))) {
			updateIcon("ailment", values[`repeating_ailments_${id}_ailIcon`], id, output);
		}
	});
	for (let i = 1; i <= 4; i++) {
		if (!(values["tool", `tool${i}IconDisplay`].includes("http"))) {
			updateIcon("tool", values[`tool${i}Icon`], i, output);
		}
	}
	setAttrs(output);
	});
	});
});
on("change:repeating_ailments:ailIcon", function(info) {
	updateIcon("ailment", info.newValue, info.sourceAttribute.split("_")[2]);
});
on("change:tool1Icon change:tool2Icon change:tool3Icon change:tool4Icon", function(info) {
	updateIcon("tool", info.newValue, info.sourceAttribute.match(/tool(\d)icon/)[1]);
});
function updateIcon(type, baseIcon, id, returnOutput=false) {
	baseIcon = (baseIcon) ? baseIcon : (type == "ailment") ? "Question" : "Hand";
	
	/* If using icon from url */
	let newicon = (baseIcon.includes("http")) ? baseIcon : "";

	/* If using built in icons*/
	if (newicon == "") {
		let [iconFolder, iconName] = baseIcon.split("/");
		switch (iconFolder.toLowerCase()) {
			case "limbus": newicon = getIcon("ailments", iconName, "true", "url"); break;
			case "community": newicon = getIcon("community", iconName, "false", "url"); break;
			case "question": newicon = getIcon("icons", "question", "false", "url"); break;
			case "hand": newicon = getIcon("icons", "Portable", "false", "url"); break;
			default: newicon = getIcon("ailments", iconFolder, "false", "url"); break;
		}
	}

	/* Set new icon */
	let attrPrefix = (type == "ailment") ? `repeating_ailments_${id}_ail` : `tool${id}`;
	if (returnOutput) {
		returnOutput[`${attrPrefix}IconDisplay`] = newicon;
	} else {
		setAttrs({[`${attrPrefix}IconDisplay`]: newicon})
	}
}


/* Auto: Update ailment list */
let ailmentEvents = `sheet:opened change:repeating_ailments:ailIcon change:repeating_ailments:ailNum change:repeating_ailments:ailNumNextTurn change:repeating_ailments:ailName change:repeating_ailments:ailDecayPause clicked:importRepeating clicked:importGlobal
	change:settingHideNextTurn change:repeating_global:burnNextTurnSetting change:repeating_global:bleedNextTurnSetting change:repeating_global:smokeNextTurnSetting change:repeating_global:chargeNextTurnSetting`;
ailmentEvents += ailmentNames.reduce((rows, ailment) => rows += ` change:${ailment} change:${ailment}NextTurn change:${ailment}DecayPause`, '')
on(ailmentEvents, function() {
	getAttrs(["targetedBy", "character_id", "settingLimbusStyle", "settingGenericTokenMode"], function(values) {
		exportAilmentList({}, function(ailmentList) {
			setAttrs({ailmentList: Data.package(ailmentList)});
			
			/* Announce update */
			//if (values.settingGenericTokenMode != "true") {
			//	announceAilmentChange(Data.unpackage(values.targetedBy), values.character_id, 0, ailmentList, values.settingLimbusStyle);
			//}
		});
	});
});

/* Action: Reset Ailments */
on('clicked:resetAilments', function() {
	resetAilments();
});
function resetAilments(callback=()=>{}) {
	getSectionIDs(`repeating_global`, idarray => {
        let id = `repeating_global_${idarray[0]}`;

	getAttrs(["SP", `${id}_staggerDurationMax`], function(values) {
	let newsan = parseInt(values.SP);
	let staggerdurationmax = parseInt(values[`${id}_staggerDurationMax`]);

	if(newsan <= "0"){
	newsan = "1";
	}

	setAttrs({"messageOverride":"true"});

	let attributeObject = {};
	ailmentNames.forEach(ailment => {
		attributeObject[`${ailment}`] = 0;
		attributeObject[`${ailment}NextTurn`] = 0;
		attributeObject[`${ailment}DecayPause`] = 0;
	});
	setAttrs({...attributeObject, "StaggerState":"0", "StaggerDuration":staggerdurationmax, "PanicState":"0", "SealState":"0", "ImmobileState":"0", "DefeatState":"0", "Seal":"0", "SP":newsan, "THP_Sources":"", "TST_Sources":""});	});

	/* Custom Ailments */
        getSectionIDs(`repeating_ailments`, idarray => {
            const fieldnames = idarray.reduce((rows,id) => [...rows, `repeating_ailments_${id}_ailNum`, `repeating_ailments_${id}_ailNumNextTurn`, `repeating_ailments_${id}_ailDecayPause`], '');
            getAttrs([...fieldnames], v => {
                const output = {};
                idarray.forEach(id => {
                    output[`repeating_ailments_${id}_ailNum`] = 0;
					output[`repeating_ailments_${id}_ailNumNextTurn`] = 0;
					output[`repeating_ailments_${id}_ailDecayPause`] = 0;
                });
                setAttrs(output);
				callback();
            });
        });
	});
}

/*Action: Reset uses */
on('clicked:resetUses', function() {
	getAttrs(["tool1Reusable", "tool1Uses_max", "tool2Reusable", "tool2Uses_max", "tool3Reusable", "tool3Uses_max", "tool4Reusable", "tool4Uses_max", "weapon1Uses_max", "weapon1UseType", "weapon2Uses_max", "weapon2UseType", "weapon3Uses_max", "weapon3UseType", "weapon4Uses_max", "weapon4UseType", "egoUses_max", "egoUseType"], function(values) {
	
	let output = {};

	if(values.tool1Reusable == "Reusable"){
	output["tool1Uses"] = values.tool1Uses_max;
	}
	if(values.tool2Reusable == "Reusable"){
	output["tool2Uses"] = values.tool2Uses_max;
	}
	if(values.tool3Reusable == "Reusable"){
	output["tool3Uses"] = values.tool3Uses_max;
	}
	if(values.tool4Reusable == "Reusable"){
	output["tool4Uses"] = values.tool4Uses_max;
	}

	if(values.weapon1UseType == "Reload"){
	output["weapon1Uses"] = values.weapon1Uses_max;
	}
	if(values.weapon2UseType == "Reload"){
	output["weapon2Uses"] = values.weapon2Uses_max;
	}
	if(values.weapon3UseType == "Reload"){
	output["weapon3Uses"] = values.weapon3Uses_max;
	}
	if(values.weapon4UseType == "Reload"){
	output["weapon4Uses"] = values.weapon4Uses_max;
	}

	if(values.egoUseType == "Reload"){
	output["egoUses"] = values.egoUses_max;
	}



	setAttrs(output);

	});
});

/* Action: Reset health */
on('clicked:resetHealth', function() {
getSectionIDs(`repeating_global`, idarray => {
    let id = `repeating_global_${idarray[0]}`;

	getAttrs(["HP_max", "StagRes_max", "SP_max", "Light_max", "distortCounter_max", "egoCondition", `${id}_staggerDurationMax`], function(values) {
	let egocon = values.egoCondition;
	let egonew = "0";
 	let hpnew = parseInt(values.HP_max);
	let stagrnew = parseInt(values.StagRes_max);
	let spnew = parseInt(values.SP_max);
	let lightnew = parseInt(values.Light_max);
	let counternew = parseInt(values.distortCounter_max);
	let staggerdurationmax = parseInt(values[`${id}_staggerDurationMax`])

	if(egocon == "AlwaysActive"){
		egonew = "true";
	}

	setAttrs({"messageOverride":"true"});
	setAttrs({"HP": hpnew, "StagRes": stagrnew, "SP":spnew, "Light":lightnew, "egoActiveState":egonew, "StaggerState":"0", "StaggerDuration":staggerdurationmax, "PanicState":"0", "SealState":"0", "ImmobileState":"0", "DefeatState":"0", "distortCounter":counternew, "THP_Sources":"", "TST_Sources":""});
 	});
	});
});

/* Action: Reset stats */
on('clicked:resetStats', async function() {
	let queryResults = await sendQuery(["userConfirmation",
		getTranslationByKeyCustom("Are you certain you want to reset the stats of your character? This will also reset any derived values (Health, Stagger Res, etc.)", "query-reset-stats"), {
			[getTranslationByKeyCustom("No","query-no")]:"false",
			[getTranslationByKeyCustom("Yes","query-yes")]:"true"
		}
	]);

	if (queryResults.userConfirmation == "true") {
		setAttrs({"instinct":"0", "wisdom":"0", "justice":"0", "charm":"0", "insight":"0", "temperance":"0"});
	}
});

/* Action: Reset Observation level */
on('clicked:resetObservation', function() {
	setAttrs({"obsDesc":"true", "obsSummary":"true", "obsCounter":"true", "obsWorkAmount":"true", "obsEffect":"0", "obsBehavior":"0", "obsTaboon":"0", "obsWorkResults":"0", "obsWorkPref":"0", "obsAppearance":"0", "obsAtmosphere":"0", "obsStory":"0"});
});

/* Action: Reset global settings to default */
on('clicked:resetGlobal', function() {
	getSectionIDs(`repeating_global`, idarray => {
	let id = `repeating_global_${idarray[0]}`;

	/* Translation prep */
	let langRulename = getTranslationByKeyCustom("Original Rulebook (Default)", "editor-rulename-placeholder") ;

	setAttrs({[`${id}_ruleName`]:langRulename, [`${id}_healthBase`]:"30", [`${id}_healthStat`]:"Instinct", [`${id}_healthStatMod`]:"6", [`${id}_healthRankMod`]:"6", [`${id}_staggerBase`]:"20", [`${id}_staggerStat`]:"Charm", [`${id}_staggerStatMod`]:"4", [`${id}_staggerRankMod`]:"4", [`${id}_sanityBase`]:"15", [`${id}_sanityStat`]:"Wisdom", [`${id}_sanityStatMod`]:"3", [`${id}_sanityRankMod`]:"0", [`${id}_lightBase`]:"3", [`${id}_lightRankMod`]:"1", [`${id}_distortLightBase`]:"5", [`${id}_distortLightRankMod`]:"1", [`${id}_expCalc`]:"8", [`${id}_actionBase`]:"1", [`${id}_actionRankMod`]:"0", [`${id}_reactionBase`]:"2", [`${id}_reactionRankMod`]:"0", [`${id}_actionTradeReaction`]:"0", [`${id}_lightRegenBase`]:"3", [`${id}_lightRegenRankMod`]:"1", [`${id}_lightRegenStatMod`]:"0", [`${id}_lightRegenStaggerSelf`]:"0", [`${id}_lightRegenStaggerEnemy`]:"0", [`${id}_lightRegenDefeatEnemy`]:"0", [`${id}_lightRegenRoundEnd`]:"0", [`${id}_combatEndLightBase`]:"1", [`${id}_combatEndLightRankMod`]:"0", [`${id}_recoverHPBase`]:"8", [`${id}_recoverHPStatMod`]:"2", [`${id}_recoverHPRankMod`]:"2", [`${id}_recoverSPBase`]:"3", [`${id}_recoverSPStatMod`]:"1", [`${id}_recoverSPRankMod`]:"0", [`${id}_recoverStaggerMode`]:"x", [`${id}_recoverStaggerVal`]:"0.5", [`${id}_recoverLightBase`]:"1", [`${id}_recoverLightRankMod`]:"0",	[`${id}_attStat`]:"Instinct", [`${id}_defStat`]:"Temperance", [`${id}_evdStat`]:"Insight", [`${id}_evdAilment`]:"EnduranceDisarm", [`${id}_multiPenalty`]:"-2", [`${id}_multiStyle`]:"n", [`${id}_staggerRecoverPercent`]:"100", [`${id}_staggerRecoverBase`]:"0", [`${id}_staggerDurationMax`]:"1", [`${id}_staggerSanity`]:"5", [`${id}_settingBar1`]:"HP", [`${id}_settingBar2`]:"StagRes", [`${id}_settingBar3`]:"SP", [`${id}_burnDecayMode`]:"x", [`${id}_burnDecayVal`]:"0.5", [`${id}_burnNextTurnSetting`]:"false", [`${id}_bleedDecayMode`]:"x", [`${id}_bleedDecayVal`]:"0.5", [`${id}_bleedNextTurnSetting`]:"false", [`${id}_smokeDecayMode`]:"+", [`${id}_smokeDecayVal`]:"-1", [`${id}_smokeNextTurnSetting`]:"false", [`${id}_smokeCalculationMode`]:"/", [`${id}_smokeCalculationVal`]:"2", [`${id}_chargeDecayMode`]:"+", [`${id}_chargeDecayVal`]:"0", [`${id}_chargeNextTurnSetting`]:"false", "settingLimbusStyle":"0"});
    });
});

/* Action: Export global settings from button */
on('clicked:exportGlobal', function() {
	dataExportGlobal();
});

function dataExportGlobal() {
    getSectionIDs(`repeating_global`, idarray => {
	let id = `repeating_global_${idarray[0]}_`;
	let attrkey = [`${id}ruleName`, `${id}healthBase`, `${id}healthStat`, `${id}healthStatMod`, `${id}healthRankMod`, `${id}staggerBase`, `${id}staggerStat`, `${id}staggerStatMod`, `${id}staggerRankMod`, `${id}sanityBase`, `${id}sanityStat`, `${id}sanityStatMod`, `${id}sanityRankMod`, `${id}lightBase`, `${id}lightRankMod`, `${id}distortLightBase`, `${id}distortLightRankMod`, `${id}actionBase`, `${id}actionRankMod`, `${id}reactionBase`, `${id}reactionRankMod`, `${id}actionTradeReaction`, `${id}lightRegenBase`, `${id}lightRegenRankMod`, `${id}lightRegenStatMod`, `${id}lightRegenStaggerSelf`, `${id}lightRegenStaggerEnemy`, `${id}lightRegenDefeatEnemy`, `${id}lightRegenRoundEnd`, `${id}combatEndLightBase`, `${id}combatEndLightRankMod`, `${id}recoverHPBase`, `${id}recoverHPStatMod`, `${id}recoverHPRankMod`, `${id}recoverSPBase`, `${id}recoverSPStatMod`, `${id}recoverSPRankMod`, `${id}recoverStaggerMode`, `${id}recoverStaggerVal`, `${id}recoverLightBase`, `${id}recoverLightRankMod`, `${id}attStat`, `${id}defStat`, `${id}evdStat`, `${id}evdAilment`, `${id}multiPenalty`, `${id}multiStyle`, `${id}staggerRecoverPercent`, `${id}staggerRecoverBase`, `${id}staggerDurationMax`, `${id}staggerSanity`, `${id}settingBar1`, `${id}settingBar2`, `${id}settingBar3`, `${id}burnDecayMode`, `${id}burnDecayVal`, `${id}burnNextTurnSetting`, `${id}bleedDecayMode`, `${id}bleedDecayVal`, `${id}bleedNextTurnSetting`, `${id}smokeDecayMode`, `${id}smokeDecayVal`, `${id}smokeNextTurnSetting`, `${id}smokeCalculationMode`, `${id}smokeCalculationVal`, `${id}chargeDecayMode`, `${id}chargeDecayVal`, `${id}chargeNextTurnSetting`, `settingLimbusStyle`];
	let exportkey = attrkeyGlobal;
	let textbase = "";

	getAttrs(attrkey, function(values) {

		for(let i = 0; i< attrkey.length ;i++){
		tempval = values[attrkey[i]];

		if(tempval == undefined){
		tempval = "";
		}

   	 	textbase += "[`" + exportkey[i] + "`,`" + tempval + "`]";

		if(i < (attrkey.length - 1)){
		textbase += ", ";
		}

		}


	textbase = textbase.replace(/	/g, ''); /* Remove whitespace */
	

	setAttrs({"gameEditor": textbase });


		});
	});

}

/* Action: Import global settings */
   on('clicked:importGlobal', function() {

      getSectionIDs(`repeating_global`, idarray => {
           let id = `repeating_global_${idarray[0]}_`;

		dataImport("gameEditor", id, "global_");

		});

});

/* Action: Sync global settings */
on('clicked:syncGlobal', function() {

getSectionIDs(`repeating_global`, idarray => {
	let id = `repeating_global_${idarray[0]}_`;

	getAttrs(["syncLockGame", "syncStateGame", "gameEditor", `${id}gameSettingSource`], function(values) {
	let syncCheck = values.syncLockGame;
	let syncState = values.syncStateGame;

	let current = values.gameEditor;
	let source = values[`${id}gameSettingSource`];

	/* Translation prep */
	let langSync = "Sync";
	let langGameSettings = "Game Settings";
	let langSyncSuccess = " sync successful.";
	let langSyncFail =  " is locked.\n Unlock before syncing.";
	let langSyncNoChange = "No change. Current data is synced.\n(Press Import if display does not match.)";
	let langSyncEmpty = "No change. Source data is empty.";

	if(getTranslationByKey("sync-button") != false){
	langSync = getTranslationByKey("sync-button");
	langGameSettings = getTranslationByKey("editor-gamesettings");
	langSyncSuccess = getTranslationByKey("pop-sync-success");
	langSyncFail = getTranslationByKey("pop-sync-fail");
	langSyncNoChange = getTranslationByKey("pop-sync-synced");
	langSyncEmpty = getTranslationByKey("pop-sync-empty");

	}

	let syncHeader = langSync;
	let syncBody = "";
	let syncToggle = "0"; 
	const output = {};


	if(source != null && source != ""){
	if(source != current && syncCheck != "true"){

	setAttrs({"gameEditor":source});

	dataImport(`${id}gameSettingSource`, id, "global_");

	syncState = "0";
	syncBody = langGameSettings + langSyncSuccess;
	syncToggle = "true"; 

		}
	else if(source != current && syncCheck == "true"){
	syncBody = langGameSettings + langSyncFail;
	syncToggle = "true"; 

		}
	else if(source == current) {
	syncBody = langSyncNoChange;
	syncToggle = "true"; 

		}
	}
	else {
	syncHeader = langSync;
	syncBody = langSyncEmpty;
	syncToggle = "true"; 
	}

	output[`popup_messageHeader`] = syncHeader;
	output[`popup_messageBody`] = syncBody;
	output[`popup_display`] = syncToggle;
	output[`syncStateGame`] = syncState;

	setAttrs(output);

	});
	});
});


/* Action: Reset damage helper values */
on('clicked:resetDamageHelper', function() {
	setAttrs({"baseDamage":"0", "flatDamageHP":"0", "flatDamageST":"0", "damageHelperType":"None"});
});


/* Action: Reset roll helper values */
on('clicked:resetHelpers', function() {
	getAttrs(["Paralysis", "Fortune"], function(values) {

	let newadvNum = values.Fortune;
	let newdisadvNum = values.Paralysis;

	setAttrs({"baseSpeed":"0", "Difficulty":"0", "advNum":newadvNum, "disadvNum":newdisadvNum, "advState":"0", "baseLuckNum":"0", "skillSelect":"0"});

 	});
});


/* Auto: EGO condition update */
on("change:egoCondition", function() {

	getAttrs(["egoCondition", "HP", "HP_max", "StaggerState"], function(values) {
	let condition = values.egoCondition;
	let currenthp = parseInt(values.HP);
	let halfhp = parseInt((values.HP_max) / 2);
	let stagger = values.StaggerState;
	setAttrs({"egoActiveState":"0"});

	if(condition == "AlwaysActive"){
	setAttrs({"egoActiveState":"true"});

	}
	else if(condition == "OnStagger" && stagger != "0"){
	setAttrs({"egoActiveState":"true"});
	}
	else if(condition == "HalfHealth" && currenthp <= halfhp){
	setAttrs({"egoActiveState":"true"});
	}

	});
});

/* Checking for tool select changes */
on("change:tool1Name change:tool2Name change:tool3Name change:tool4Name change:tool1Uses change:tool2Uses change:tool3Uses change:tool4Uses change:special1Name change:special2Name ", function(){

	setAttrs({"toolSelect":""});

});

/* Checking for weapon range changes */
on("change:weapon1Range", function(){ 
	getAttrs(["weapon1Range"], function(values){
	if(values.weapon1Range == "Ranged"){setAttrs({"weapon1UseType":"Reload"}); }
	else { setAttrs({"weapon1UseType":"Limitless"}); }
	}); });

on("change:weapon2Range", function(){ 
	getAttrs(["weapon2Range"], function(values){
	if(values.weapon2Range == "Ranged"){setAttrs({"weapon2UseType":"Reload"}); }
	else { setAttrs({"weapon2UseType":"Limitless"}); }
	}); });

on("change:weapon3Range", function(){ 
	getAttrs(["weapon3Range"], function(values){
	if(values.weapon3Range == "Ranged"){setAttrs({"weapon3UseType":"Reload"}); }
	else { setAttrs({"weapon3UseType":"Limitless"}); }
	}); });

on("change:weapon4Range", function(){ 
	getAttrs(["weapon4Range"], function(values){
	if(values.weapon4Range == "Ranged"){setAttrs({"weapon4UseType":"Reload"}); }
	else { setAttrs({"weapon4UseType":"Limitless"}); }
	}); });

/* Auto: Update Skill Selection */
on("change:skillSelect", function() {

	/* Get IDs/names */
	getAttrs(["skillSelect"], function(values){
    let buttonid = values.skillSelect;
	let skillcat = buttonid.split('S')[0];

	let name = buttonid + "Name";
	let type = buttonid + "Type";
	let rank = buttonid + "Rank";
	let effect = buttonid + "Effect";
	let desc = buttonid + "Description";
	let light = buttonid + "Light";

	let diceA = buttonid + "Dice1";
	let diceB = buttonid + "Dice2";
	let diceC = buttonid + "Dice3";
	let noskill = "0";

	/* Get attributes */
	if(buttonid != "0"){
        getAttrs([`${name}`, `${type}`, `${rank}`, `${effect}`, `${desc}`, `${light}`, `${diceA}`, `${diceB}`, `${diceC}`, "Light"], function(values) {

	let skillname = values[name];
	let skillrank = values[rank];
	let skilltype = values[type];
	let skilleffect = values[effect];
	let skilldesc = values[desc];
	let skilllight = values[light];

	let skilldiceA = values[diceA];
	let skilldiceB = values[diceB];
	let skilldiceC = values[diceC];

	let currentLight = values.Light;

	if(currentLight < skilllight){
	noskill = "true";

	setAttrs({"selectName":skillname, "selectRank":"0", "selectType":"0", "selectEffect":skilleffect, "selectDescription":skilldesc, "selectLight":skilllight, "selectDice1":"0", "selectDice2":"0", "selectDice3":"0", "selectDefDice1":"0", "selectDefDice2":"0", "selectDefDice3":"0", "selectAtkDice1":"0", "selectAtkDice2":"0", "selectAtkDice3":"0", "selectEvdDice1":"0", "selectEvdDice2":"0", "selectEvdDice3":"0", "selectCancel":noskill});
	}
	else{
	if(skilltype == "Attack" || skilltype == "Mass"){
	setAttrs({"selectAtkDice1":skilldiceA, "selectAtkDice2":skilldiceB, "selectAtkDice3":skilldiceC, "selectDefDice1":"0", "selectDefDice2":"0", "selectDefDice3":"0", "selectEvdDice1":"0", "selectEvdDice2":"0", "selectEvdDice3":"0"});
		}
	else if(skilltype == "Defend"){
	setAttrs({"selectDefDice1":skilldiceA, "selectDefDice2":skilldiceB, "selectDefDice3":skilldiceC, "selectAtkDice1":"0", "selectAtkDice2":"0", "selectAtkDice3":"0", "selectEvdDice1":"0", "selectEvdDice2":"0", "selectEvdDice3":"0"});
		}
	else if(skilltype == "Evade"){
	setAttrs({"selectEvdDice1":skilldiceA, "selectEvdDice2":skilldiceB, "selectEvdDice3":skilldiceC, "selectDefDice1":"0", "selectDefDice2":"0", "selectDefDice3":"0", "selectAtkDice1":"0", "selectAtkDice2":"0", "selectAtkDice3":"0"});
		}
	else {
	setAttrs({"selectEvdDice1":"0", "selectEvdDice2":"0", "selectEvdDice3":"0", "selectDefDice1":"0", "selectDefDice2":"0", "selectDefDice3":"0", "selectAtkDice1":"0", "selectAtkDice2":"0", "selectAtkDice3":"0"});

		}

	setAttrs({"selectName":skillname, "selectRank":skillrank, "selectType":skilltype, "selectEffect":skilleffect, "selectDescription":skilldesc, "selectLight":skilllight, "selectDice1":skilldiceA, "selectDice2":skilldiceB, "selectDice3":skilldiceC, "selectCancel":noskill});
	}
		});
	}
else {
	setAttrs({"selectName":" ", "selectRank":"0", "selectType":"0", "selectEffect":" ", "selectDescription":" ", "selectLight":"0", "selectDice1":"0", "selectDice2":"0", "selectDice3":"0", "selectDefDice1":"0", "selectDefDice2":"0", "selectDefDice3":"0", "selectAtkDice1":"0", "selectAtkDice2":"0", "selectAtkDice3":"0", "selectEvdDice1":"0", "selectEvdDice2":"0", "selectEvdDice3":"0", "selectCancel":noskill});
	}

});

});


/* Action: Update ailments */
on('clicked:updateAilments', function() {
	Update();
});
/* Executed either a standard update or a generic token update if the setting is enabled */
let updateDelay = 1000;
let initialTokenId_selected = "";
function Update() {
	getAttrs(['settingGenericTokenMode', 'tokenId_selected', 'configUpdateDelay'], async function(values) {
		if (values.settingGenericTokenMode == "true") {
			getSectionIDs(`repeating_tokens`, tokenidarray => {
				initialTokenId_selected = values.tokenId_selected;
				updateDelay = parseInt(values.configUpdateDelay);
				delayUpdateAilments(tokenidarray);
			});
		} else {
			updateAilments();
		}
	});
}
/* When using multiple tokens, due to all the on:change functions used by the sheet, a delay is 
    needed to ensure all fields have been properly updated before proceeding to the next token */
function delayUpdateAilments(tokenidarray) {
	setTimeout(function() {
		let tokenId = tokenidarray[0];
		changeActiveToken(tokenId, () => {
			updateAilments([], () => {
				/* Repeat loop while unupdated tokenIds remain */
				if (tokenidarray.length > 1) {
					delayUpdateAilments(tokenidarray.slice(1));
				} else {
					setTimeout(function() {
						setAttrs({"tokenId_selected": initialTokenId_selected});
						initialTokenId_selected = "";
					}, updateDelay);
				}
			});
		});
	}, updateDelay); // For my PC 500ms seems fine, but leaving it at 1000ms to hopefully make it run properly for lower spec PCs
}

function updateAilments(ailmentOverride=[], callback=()=>{}) {
	
	getSectionIDs(`repeating_global`, idarray => {
		let id = `repeating_global_${idarray[0]}`;

		let attributeList = [];
		if (ailmentOverride.length == 0) { ailmentOverride = ailmentNames; }
		ailmentOverride.forEach(ailment => {
			attributeList.push(`${ailment}`, `${ailment}NextTurn`, `${ailment}DecayPause`);
		});

	getAttrs(["settingMuteMessage", "settingWhisperRolls", "settingWhisperTarget", "settingBurnImmune", "nextRoundSpeed",
		"StaggerState", "StaggerDuration", `${id}_staggerDurationMax`, "SealState", "ImmobileState", "burnResist", "burnResist_ego", "distortState", "egoActiveState", "egoType", "HP", "StagRes_max", "settingLimbusStyle",
		`${id}_staggerRecoverPercent`, `${id}_staggerRecoverBase`, `${id}_burnDecayMode`, `${id}_burnDecayVal`, `${id}_smokeDecayMode`, `${id}_smokeDecayVal`, `${id}_chargeDecayMode`, `${id}_chargeDecayVal`,
		...attributeList, "THP_Sources"], function(values) {

 	let burnnew = 0;
	let bleednew = parseInt(values.Bleed);
	let smokenew = 0;
	let chargenew = 0;
	let stagnew = "0";

	let nomessage = values.settingMuteMessage;
	let burnimmune = values.settingBurnImmune;
	let iconstyle = values.settingLimbusStyle;
	let stagcheck = values.StaggerState;
	let stagduration = parseInt(values.StaggerDuration);
	let stagdurationmax = parseInt(values[`${id}_staggerDurationMax`]);
	let sealcheck = values.SealState;
	let immobilecheck = values.ImmobileState;
	let nextRoundSpeed = parseInt(values.nextRoundSpeed);

	let burnresist = values.burnResist;
	let distortstate = values.distortState;
	let egostate = values.egoActiveState;
	let egotype = values.egoType;

	if(egostate == "true" && egotype == "Outfit" && distortstate != "true"){
	burnresist = values.burnResist_ego;
	}
	else if(distortstate == "true"){
	burnresist = parseInt(values.burnResist) + parseInt(values.burnResist_ego);
	}

	let THP_Sources = {};
	if (values.THP_Sources != "" && values.THP_Sources != "{}") {
		THP_Sources = JSON.parse(values.THP_Sources);
	}
	
	let output = {};
	let autoScriptOverrideList = {};

	/* Whisper roll */
	let whisperrolls = values.settingWhisperRolls;
	let whispertarget = values.settingWhisperTarget;
	let whisper = "";
	if(whisperrolls == "true"){
	whisper = "/w " + whispertarget;
	}

	/* Burn processing */
	if(ailmentOverride.includes("Burn")) {
		let burncurrent = parseInt(values.Burn);
		let burndecay = parseFloat(values[`${id}_burnDecayVal`]);
		
		if (burncurrent > 0) {
	
			/* Decay */
			if (parseInt(values.BurnDecayPause) == 0) {
				if(burndecay == "n"){
				burndecay = parseInt(burncurrent);
				}
				else if(burndecay == "-n"){
				burndecay = parseInt(0 - burncurrent);
				}
		
				if(values[`${id}_burnDecayMode`] == "+"){
				burnnew += parseInt(burncurrent) + parseInt(burndecay);
				}
				else if(values[`${id}_burnDecayMode`] == "x"){
				burnnew += parseInt(parseInt(burncurrent) * parseFloat(burndecay));
				}
				else if(values[`${id}_burnDecayMode`] == "="){
				burnnew += parseInt(burndecay);
				}
			}

			/* Damage */
			let burndamage = parseInt(values.Burn - burnresist);
	
			if(burndamage <= 0){
			burndamage = 0;
			}
	
			let burnresult = parseInt(values.HP - burndamage);
	
			if(burnimmune == "true"){
				burnresult = parseInt(values.HP);
				burndamage = 0;
			}

			/* Temporary HP */
			let THPUsed = {}
			let THPmessage = "";
			if (burndamage > 0 && length(THP_Sources) > 0) {
				let returnTHP = applyTempBarDamageAilment(THP_Sources, "THP", burndamage, burnresult);
				burnresult = returnTHP.newBar;
				burndamage = returnTHP.damage;
				THPUsed = returnTHP.THPUsed;
			}
			for (const sourceName in THPUsed) {
				let countUpdate = `(${parseInt(THPUsed[sourceName][0] + THPUsed[sourceName][1])} -> ${THPUsed[sourceName][0]})`;
				THPmessage += styleText(`\n**(${sourceName}: ${THPUsed[sourceName][1]} ${countUpdate})**`, "opacity: 50%;");
			}

			/* Chat message */
			if(nomessage != "true" && burnimmune != "true"){
	
			/* Translation prep */
			let langBurn = getTranslationByKeyCustom(" was burned for ", "message-burn");
			let langDamage= getTranslationByKeyCustom(" damage.", "message-damage");
			let langResist= getTranslationByKeyCustom("Resistance: ", "message-resist");
			let langResistCombined = "";
	
			let iconnew = getIcon("ailments", "Burn", values.settingLimbusStyle, "markdown");
	
			if(burnresist != "0"){
				langResistCombined = styleText(`**(${langResist}${burnresist})**`, "opacity: 50%;");
			}
	
			let burnmessage = `${langBurn} **${burndamage}** ${langDamage}. ${langResistCombined} ${THPmessage}`;
	
			output = {...output, "HP": burnresult, "Burn": burnnew};
			autoScriptOverrideList.Burn = [burnnew, burncurrent];
	
			startRoll((whisper + `&{template:message} {{icon=${iconnew}}} {{name=@{character_name}}} {{message=${burnmessage}}}`), (results) => {
				finishRoll(results.rollId);
			});
			}
		}
	}

	/* Smoke processing */
	if(ailmentOverride.includes("Smoke")) {
		let smokecurrent = parseInt(values.Smoke);
		let smokedecay = parseFloat(values[`${id}_smokeDecayVal`]);

		if (smokecurrent > 0){
	
			if (parseInt(values.SmokeDecayPause) == 0) {
				if(smokedecay == "n"){
				smokedecay = parseInt(smokecurrent);
				}
				else if(smokedecay == "-n"){
				smokedecay = parseInt(0 - smokecurrent);
				}
	
				if(values[`${id}_smokeDecayMode`] == "+"){
				smokenew += parseInt(smokecurrent) + parseInt(smokedecay);
				}
				else if(values[`${id}_smokeDecayMode`] == "x"){
				smokenew += parseInt(parseInt(smokecurrent) * parseFloat(smokedecay));
				}
				else if(values[`${id}_smokeDecayMode`] == "="){
				smokenew += parseInt(smokedecay);
				}
			}
			autoScriptOverrideList.Smoke = [smokenew, smokecurrent];
			output.Smoke = smokenew;
		}
	}

	/* Charge processing */
	if(ailmentOverride.includes("Charge")) {
		let chargecurrent = parseInt(values.Charge);
		let chargedecay = parseFloat(values[`${id}_chargeDecayVal`]);

		if (chargecurrent > 0){
			
			if (parseInt(values.ChargeDecayPause) == 0) {
				if(chargedecay == "n"){
				chargedecay = parseInt(chargecurrent);
				}
				else if(chargedecay == "-n"){
				chargedecay = parseInt(0 - chargecurrent);
				}

				if(values[`${id}_chargeDecayMode`] == "+"){
				chargenew += parseInt(chargecurrent) + parseInt(chargedecay);
				}
				else if(values[`${id}_chargeDecayMode`] == "x"){
				chargenew += parseInt(parseInt(chargecurrent) * parseFloat(chargedecay));
				}
				else if(values[`${id}_chargeDecayMode`] == "="){
				chargenew += parseInt(chargedecay);
				}
			}
			autoScriptOverrideList.Charge = [chargenew, chargecurrent];
			output.Charge = chargenew;
		}
	}

	/* If decay pause is active, keep current count and decrease the pause count by 1 */
	ailmentOverride.forEach(ailment => {
		if (parseInt(values[`${ailment}DecayPause`]) > 0 && ailment != "Bleed") {
			output[`${ailment}`] = parseInt(values[`${ailment}`]);
			output[`${ailment}DecayPause`] = parseInt(values[`${ailment}DecayPause`]) - 1;
			autoScriptOverrideList[`${ailment}`] = [output[`${ailment}`], output[`${ailment}`]];
		}
	});


	/* Round end Update processing */
	/* Do not process if only specific ailments are being updated */
	if (ailmentOverride == ailmentNames) {

		output = {
			...output, "thisRoundSpeed":nextRoundSpeed, "nextRoundSpeed":0, "isFirstRound":"false",
			"Bleed":bleednew
		}

		/* Add NextTurn count */
		ailmentOverride.forEach(ailment => {
			if (output[`${ailment}`]) { output[`${ailment}`] += parseInt(values[`${ailment}NextTurn`]); }
			else { output[`${ailment}`] = parseInt(values[`${ailment}NextTurn`]); }
			output[`${ailment}NextTurn`] = 0;
		});
	
		/* Stagger processing */
		if(stagcheck == "Staggered"){
			if(stagduration == 0) {
				stagnew = parseInt((values.StagRes_max) * parseFloat(parseInt(values[`${id}_staggerRecoverPercent`])/100) + parseInt(values[`${id}_staggerRecoverBase`]));
				output = {...output, "StaggerState":"0", "StaggerDuration":stagdurationmax, "StagRes":stagnew};
			} else {
				output = {...output, "StaggerDuration":stagduration-1};
			}
		}
	
		/* Seal processing */
		if(sealcheck != "0"){
			output.SealState = "0";
		}
	
		/* Immobile processing */
		if(immobilecheck != "0"){
			output.ImmobileState = "0";
		}
	
		/* Custom Ailments */
		updateCustomAilments(["RoundEnd"], "standard", "true", function(returnValues) {
		Object.assign(autoScriptOverrideList, returnValues.overrideList);
		output = {...output, ...returnValues.output};
	
		updateCustomAilments(["OnAction", "WhenHit"], "decay", "true", function(returnValues) {
		Object.assign(autoScriptOverrideList, returnValues.overrideList);
		output = {...output, ...returnValues.output};
	
		/* AutoScripts */
		resetConditionals();
		AutoScriptMain("", "Round start", "true", "true", autoScriptOverrideList, ()=>{}, getTranslationByKeyCustom("Round start", "autoeffect-trigger-roundstart"));

		setAttrs(output, {}, () => {
			callback();
		});
		});
		});
	} else {
		setAttrs(output, {}, () => {
			callback();
		});
	}
	});
	});
}

function updateAdvantages(changeval){
	getAttrs(["Paralysis", "Fortune", "advState", "advNum", "disadvNum"], function(values) {

	let newparalysis = Math.max(values.Paralysis - parseInt(changeval), 0);
	let newfortune = Math.max(values.Fortune - parseInt(changeval), 0);
	let newadvnum = Math.max(values.advNum - parseInt(changeval), 0);
	let newdisadvnum = Math.max(values.disadvNum - parseInt(changeval), 0);
	let oldadvsum = parseInt(values.advNum) - parseInt(values.disadvNum);

	let comparePos = newadvnum;
	let compareNeg = newdisadvnum;

	const output = {};

	if(values.Fortune > 0 || values.advNum != "0"){
		if(values.Fortune > 0) {
			output["Fortune"] = newfortune;
			comparePos = newfortune;
			compareNeg = newparalysis;
		} else {
			output["advNum"] = newadvnum;
		}
	}
	if(values.Paralysis > 0 || values.disadvNum != "0"){
		if(values.Paralysis > 0) {
			output["Paralysis"] = newparalysis;
			comparePos = newfortune;
			compareNeg = newparalysis;
		} else {
			output["disadvNum"] = newdisadvnum;
		}
	}

	if(comparePos == compareNeg){
		output["advState"] = "0";
	}
	else if(comparePos > compareNeg){
		output["advState"] = "Advantage";
	}
	else if(comparePos < compareNeg){
		output["advState"] = "Disadvantage";
	}

	setAttrs(output);
	});
}

/* Has the following modes : */
/* standard - Triggers both decay and damage like normal */
/* decay - Triggers only decay */
/* damage - Triggers only damage */
function updateBleed(mode="standard", callback=()=>{}) {
getSectionIDs(`repeating_global`, idarray => {
           let id = `repeating_global_${idarray[0]}`;

getAttrs(["Bleed", "BleedDecayPause", "bleedResist", "bleedResist_ego", "distortState", "egoActiveState", "egoType", "HP",
	"settingBleedImmune", "settingWhisperRolls", "settingWhisperTarget", "settingMuteMessage", "settingLimbusStyle", "character_name", `${id}_bleedDecayMode`, `${id}_bleedDecayVal`,
	"THP_Sources"], function(values) {

	let bleednew = "0";
	let bleedcurrent = values.Bleed;
	let bleeddecaypause = parseInt(values.BleedDecayPause);
	let bleeddecay = values[`${id}_bleedDecayVal`];
	let bleeddamage = 0;
	let bleedresult = parseInt(values.HP);

	let bleedimmune = values.settingBleedImmune;
	let bleedmessage = " ";
	let charname = values.character_name;
	let nomessage = values.settingMuteMessage;
	let hiddenroll = values.settingWhisperRolls;
	let bleedresist = values.bleedResist;

	let distortstate = values.distortState;
	let egostate = values.egoActiveState;
	let egotype = values.egoType;

	let output = {}

	if(egostate == "true" && egotype == "Outfit" && distortstate != "true"){
		bleedresist = values.bleedResist_ego;
	}
	else if(distortstate == "true"){
		bleedresist = parseInt(values.bleedResist) + parseInt(values.bleedResist_ego);
	}

	if (bleeddecaypause > 0) {
		mode = "damage";
		output.BleedDecayPause = bleeddecaypause - 1;
	}

	let THP_Sources = {};
	if (values.THP_Sources != "" && values.THP_Sources != "{}") {
		THP_Sources = JSON.parse(values.THP_Sources);
	}

	/* Whisper roll */
	let whisperrolls = values.settingWhisperRolls;
	let whispertarget = values.settingWhisperTarget;
	let whisper = "";
	if(whisperrolls == "true"){
		whisper = "/w " + whispertarget;
	}

	/* Bleed processing */
	if (parseInt(values.Bleed) > 0) {

		/* Decay */
		if (mode == "standard" || mode == "decay") {
			if(bleeddecay == "n"){
			bleeddecay = parseInt(bleedcurrent);
			}
			else if(bleeddecay == "-n"){
			bleeddecay = parseInt(0 - bleedcurrent);
			}
	
			if(values[`${id}_bleedDecayMode`] == "+"){
			bleednew = parseInt(bleedcurrent) + parseInt(bleeddecay);
			}
			else if(values[`${id}_bleedDecayMode`] == "x"){
			bleednew = parseInt(parseInt(bleedcurrent) * parseFloat(bleeddecay));
			}
			else if(values[`${id}_bleedDecayMode`] == "="){
			bleednew = parseInt(bleeddecay);
			}
		}
		else {
			bleednew = parseInt(bleedcurrent)
		}

		/* Damage */
		if (mode == "standard" || mode == "damage" || bleedimmune != "true") {
			bleeddamage = Math.max(parseInt(values.Bleed - bleedresist), 0);
			bleedresult -= bleeddamage;
		}

		/* Temporary HP */
		let THPUsed = {}
		let THPmessage = "";
		if (bleeddamage > 0 && length(THP_Sources) > 0) {
			let returnTHP = applyTempBarDamageAilment(THP_Sources, "THP", bleeddamage, bleedresult);
			bleedresult = returnTHP.newBar;
			bleeddamage = returnTHP.damage;
			THPUsed = returnTHP.THPUsed;
		}
		for (const sourceName in THPUsed) {
			let countUpdate = `(${parseInt(THPUsed[sourceName][0] + THPUsed[sourceName][1])} -> ${THPUsed[sourceName][0]})`;
			THPmessage += styleText(`\n**(${sourceName}: ${THPUsed[sourceName][1]} ${countUpdate})**`, "opacity: 50%;");
		}

		/* Chat message */
		if(nomessage != "true" && bleedimmune != "true"){

			/* Translation prep */
			let langBleed = getTranslationByKeyCustom(" bled for ", "message-bleed");
			let langDamage= getTranslationByKeyCustom(" damage.", "message-damage");
			let langResist= getTranslationByKeyCustom("Resistance: ", "message-resist");
			let langResistCombined = "";

			if(bleedresist != "0") {
				langResistCombined = styleText(`**(${langResist}${bleedresist})**`, "opacity: 50%;");
			}

			let iconnew = getIcon("ailments", "Bleed", values.settingLimbusStyle, "markdown");

			bleedmessage = `${langBleed} **${bleeddamage}** ${langDamage}. ${langResistCombined} ${THPmessage}`;

			/*--- Send roll --*/
			startRoll((whisper + `&{template:message} {{icon=${iconnew}}} {{name=@{character_name}}} {{message=${bleedmessage} }}`), (results) => {
				finishRoll(results.rollId, { });
			});
		}

		/* Apply damage */
		if (bleedimmune != "true") {
			output = {...output, "HP":bleedresult, "Bleed":bleednew};
		}

		if (callback != "()=>{}") {
			callback({"output": output, "overrideList": { Bleed: [bleednew, bleedcurrent] }});
		} else {
			setAttrs({output});
		}
	} else {
		callback({});
	}
	});
	});
}

/* Action: Status ailment increment + Pause value reveal toggle + Trigger ailment */
onJQ('clicked:ailmentClicker clicked:repeating_ailments:clickercustom', (info) => {
	let keyPressed = (info.altKey) ? "alt" : (info.ctrlKey) ? "ctrl" : false;

	/* Get currect attribute */
	let ailmentType = (info.sourceAttribute) ? "custom" : "standard";
	let ailmentAttr = (info.htmlAttributes.class.includes("reveal-DecayPause")) ? "DecayPause" : "Num";
	let ailmentName = "";

	if (ailmentType == "custom") {
		ailmentName = info.sourceAttribute.split('_')[2];
		ailmentAttr = `repeating_ailments_${ailmentName}_ail${ailmentAttr}`;
	} else {
		ailmentName = info.htmlAttributes.id.split('_')[1];
		ailmentAttr = (ailmentAttr == "Num") ? ailmentName : ailmentName + ailmentAttr;
	}

	/* If not pressing any keys, increment ailment count by 1 */
	if (!keyPressed) {
		getAttrs([ailmentAttr], function(values) {
			setAttrs({[ailmentAttr]: parseInt(values[ailmentAttr]) + 1});
		});
	}
	
	/* If pressing alt, reveal the ailments DecayPause field */
	else if (keyPressed == "alt") {
		let pauseInputSelector = (ailmentType == "custom")
			? `[data-reprowid*=${ailmentName}] [name*=attr_ailDecayPause]`
			: `[name*=attr_${ailmentName}DecayPause]`;
		
		let ailmentButtonSelecter = (ailmentType == "custom")
			? `[data-reprowid*=${ailmentName}] [name*=act_clickercustom]`
			: `button[id*=ailment_${ailmentName}]`;

		$20(ailmentButtonSelecter).toggleClass("reveal-DecayPause");
		$20(pauseInputSelector).toggleClass("reveal-DecayPause");
	}

	/* If pressing ctrl, trigger the ailment */
	else if (keyPressed == "ctrl") {
		if (ailmentType == "custom") {
			updateCustomAilment(ailmentName, "standard", "false");
		} else {
			updateAilments([ailmentName]);
		}
	}
});

/* Action: Combat Roll */
on('clicked:rollCombat', (info) => {
	rollCombat(info);
});
function rollCombat(info) {
	/* Preparing values */
	/* Get IDs/names */
	let buttonid = info.htmlAttributes.id.split('_')[1];
	let rawcheck = info.htmlAttributes.id.split('_')[2];

	let name = buttonid + "Name";
	let type = buttonid + "Type";
	let effect = buttonid + "Effect";
	let range = buttonid + "Range";
	let uses = (buttonid.includes("weapon")) ? `${buttonid}Uses` : "";
	let usesmax = (buttonid.includes("weapon")) ? `${buttonid}Uses_max` : "";
	let usetype = (buttonid.includes("weapon")) ? `${buttonid}UseType` : "";

	if(buttonid == "egoWeapon" || buttonid == "egoDef" || buttonid == "egoEvd"){
	uses = "egoUses";
	usesmax = "egoUses_max";
	usetype = "egoUseType";
	}

	let diceA = buttonid + "Dice1";
	let diceB = buttonid + "Dice2";
	let diceC = buttonid + "Dice3";

	let headercolor = "#888";
	let headertext = "#fff";

	let basetype = "";

	let newicon = getIcon("icons", "question", "false", "url");

	/* Action type formatting */
	if(buttonid == "def" && rawcheck != "distort"){
		basetype = "Defend";
		headercolor = "#7397d1";
		newicon = getIcon("icons", "defend", "false", "url");
	}
	else if(buttonid == "egoDef" || (buttonid == "def" && rawcheck == "distort")) {
		basetype = "Defend";
		headercolor = "#000";
		headertext = "#6d9eeb";
		newicon = getIcon("icons", "egoDef", "false", "url");
	}
	else if(buttonid == "evd" && rawcheck != "distort"){
		basetype = "Evade";
		headercolor = "#dbb748";
		newicon = getIcon("icons", "evade", "false", "url");
	}
	else if(buttonid == "egoEvd" || (buttonid == "evd" && rawcheck == "distort")){
		basetype = "Evade";
		headercolor = "#000";
		headertext = "#f1c232";
		newicon = getIcon("icons", "egoEvd", "false", "url");
	}
	else if(buttonid == "act"){
		basetype = "Action";
		headercolor = "#8e7cc3";
		newicon = getIcon("icons", "Portable", "false", "url");
	}
	else if(buttonid == "egoWeapon" || rawcheck == "distort"){
		basetype = "Attack";
		headercolor = "#000";
		headertext = "#cc4125";
	}
	else {
		basetype = "Attack";
		headercolor = "#c25944";
	}

	if(buttonid == "egoWeapon" || buttonid == "egoDef" || buttonid == "egoEvd"){
		effect = "egoEffect";
		name = "egoName";
	}
	else if(buttonid == "def" || buttonid == "evd"){
		effect = "outfitEffect";
		name = "outfitName";
	}

	/* Get attributes */
	getSectionIDs(`repeating_global`, idarray => {
    let id = `repeating_global_${idarray[0]}`;

	/* Get skillSelect and toolSelect first as they're used to gather further values */
	getAttrs(["skillSelect", "toolselect"], function(values) {
	let skillselect = values.skillSelect;
	let toolselect = values.toolselect;

    getAttrs(["egoActiveState", "settingSimpleDisplay", "settingHideBaseEffect", "settingTargeting", "settingWhisperRolls", "settingWhisperTarget", "settingMultihitFull",
	`${id}_multiPenalty`, `${id}_multiStyle`, "targetName", "targetId", "targetTokenId", "character_name", "advState", "difficulty", "Light",
	"difficulty", "Bleed", "Endurance", "Disarm", "Strength", "Feeble", "evdPositive", "evdNegative", "advNum", "disadvNum", "Fortune", "Paralysis", "attPower", "defPower", "evdPower",
	"selectName", "selectLight", "selectType", "selectDice1", "selectDice2", "selectDice3", "selectEffect",
	"distortWeaponDice1", "distortWeaponDice2", "distortWeaponDice3", "distortDefDice1", "distortDefDice2", "distortDefDice3", "distortEvdDice1", "distortEvdDice2", "distortEvdDice3", "distortEffect", "distortEffect2", "settingMultihitUses", "settingHideUses",
	`${name}`, `${type}`, `${range}`, `${effect}`, `${diceA}`, `${diceB}`, `${diceC}`, `${uses}`, `${usesmax}`, `${usetype}`,
	`${buttonid}AutoScript`, "outfitAutoScript", "egoAutoScript",
	`${skillselect}AutoScript`, `${toolselect}Name`, `${toolselect}Description`, `${toolselect}Effect`, `${toolselect}Uses`, `${toolselect}Uses_max`, `${toolselect}Reusable`, `${toolselect}AutoScript`], function(values) {

	let output = {}

	let currentlight = parseInt(values.Light);
	let newlight = parseInt(values.Light);
	let charname = values.character_name;
	let targetname = values.targetName || "";
	let targetid = values.targetId || "";
	let targettokenid = values.targetTokenId || "";
	let simpledisplay = values.settingSimpleDisplay;
	let hidebaseffect = values.settingHideBaseEffect;
	let targeting = values.settingTargeting;
	let whisperrolls = values.settingWhisperRolls;
	let whispertarget = values.settingWhisperTarget;

	let currentuses = parseInt(values[`${uses}`]);
	let newuses = parseInt(values[`${uses}`]);
	let maxuses = values[`${usesmax}`];
	let limitbehavior = values[`${usetype}`];
	let weaponuse = "";

	if(limitbehavior != "Limitless" && limitbehavior != null && values.settingHideUses != "true"){
		weaponuse = `(${currentuses}/${maxuses})`;
	}

	let multihitfull = values.settingMultihitFull;
	let multipenalty = parseInt(values[`${id}_multiPenalty`]);
	let multistyle = values[`${id}_multiStyle`];

	let distortstate = values.distortState;

	let difficulty = parseInt(values.difficulty);
	let lightmessage = "";

	let advstate = values.advState || "0";
	let advcounter = values.advNum || values.Fortune || 0;
	let disadvcounter = values.disadvNum || values.Paralysis || 0;

	/* Base dice */
	let baseset = values;
	let basename = values[name];
	let baseeffect = values[effect];

	let basedice1 = values[diceA];
	let basedice2 = values[diceB];
	let basedice3 = values[diceC];

	let weapontype = values[type];
	let weaponrange = values[range];

	let basetypemessage = basetype;
	let weaponmessage = "";
	let attackmessage = "";

	/* Weapon icon variations */
	if (basetype == "Attack" && weapontype != "None") {
		if (buttonid == "egoWeapon" || rawcheck == "distort") {
			newicon = getIcon("icons", `ego${weapontype}`, "false", "url");
		} else {
			if (weapontype == "Slash") {
				newicon = getIcon("icons", weapontype, "false", "url");
			} else {
				newicon = getIcon("icons", weapontype.toLowerCase(), "false", "url");
			}
		}
	}

	/* Outfit name */ 
	if((buttonid == "def" || buttonid == "evd") && basename == ""){
		basename = getTranslationByKeyCustom("Outfit", "outfit-name");
	}

	/* Translation prep */
	let langFrom = getTranslationByKeyCustom("From", "message-from");
	let langTarget = getTranslationByKeyCustom("Target", "message-target");
	let langRoll = getTranslationByKeyCustom("Roll", "message-roll");
	let langSkill = getTranslationByKeyCustom("Skill", "message-skill");
	let langEffectBase = getTranslationByKeyCustom("Base effect", "message-effectbase");
	let langEffectSkill = getTranslationByKeyCustom("Skill effect", "message-effectskill");
	let langAdv = getTranslationByKeyCustom("Adv.", "message-adv");
	let langDisadv = getTranslationByKeyCustom("Disadv.", "message-disadv");
	let skilleffect = getTranslationByKeyCustom("(No Skill)", "message-noskill");
	let langDistortEffect = getTranslationByKeyCustom("Distortion Effect", "distort-effectText");
	let langMass = getTranslationByKeyCustom("Mass Attack", "skill-type-Mass");

	if(basetype == "Attack" && buttonid != "egoWeapon"){
	weapontype = getTranslationByKey("weapon-type-" + weapontype) || "";
	weaponrange = getTranslationByKey("weapon-type-" + weaponrange) || "";
	}

	/* Tool */
	let toolDescription = "";
	let toolEffectDescription = "";
	let toolinfo = "";
	let toolname = "";
	let tooldesc = "";
	let tooleffect = "";

	let langUse = "Use Tool";
	let langEffectTool = "Tool Effects";

	if (toolselect != "" && toolselect != null && toolselect != "0") {
		toolname = values[`${toolselect}Name`];
		tooldesc = values[`${toolselect}Description`];
		tooleffect = values[`${toolselect}Effect`];
		let tooluses = values[`${toolselect}Uses`];
		let toolusesmax = values[`${toolselect}Uses_max`];
		let toolreuse = values[`${toolselect}Reusable`];
		let toolnewuses = tooluses;

		if (getTranslationByKey("palette-action-tool") != false) {
			langUse = getTranslationByKey("palette-action-tool");
			langEffectTool = getTranslationByKey("tool-effect").replace(".","");
		}

		if(toolreuse == "Reusable"){
			toolnewuses = parseInt(tooluses) - 1;
			if(parseInt(newuses) < 0){ 
				toolnewuses = "0";
			}
			output[`${toolselect}Uses`] = toolnewuses;
		}
		else {
			output[`${toolselect}Uses`] = "0";
		}
	}

	/* Skill */
	let skillname = values.selectName;
	let skilltype = values.selectType;
	let skillcost = values.selectLight;
	let skilldice1 = "0";
	let skilldice2 = "0";
	let skilldice3 = "0";
	let skillmass = "";
	let skillinfo = "";

	if(currentlight >= skillcost && rawcheck != "raw"){

		if(skilltype == "Mass" && basetype == "Attack"){
		skilltype = "Attack";
		skillmass = " | " + langMass;

			if(buttonid == "egoWeapon" || rawcheck == "distort") {
				newicon = getIcon("icons", "egoWide", "false", "url");	
			} else {
				newicon = getIcon("icons", "Wide", "false", "url");	
			}
			}
		if(basetype == skilltype){
		skilldice1 = values.selectDice1;
		skilldice2 = values.selectDice2;
		skilldice3 = values.selectDice3;

		newlight = currentlight - skillcost;
		lightmessage = " <span style='color: #fee2b0'>(" + langSkill + ")</span>";

			skillinfo= "<br><b>" + langSkill + ": </b>" + skillname;
		skilleffect = values.selectEffect;
		}
	}

	/* Bleed processing */
	let autoScriptOverrideList = {};
	updateBleed("standard", function(returnValues) {
	Object.assign(autoScriptOverrideList, returnValues.overrideList);
	output = {...output, ...returnValues.output};
		
	/* Custom Ailments processing */
	updateCustomAilments(["OnAction"], "standard", "false", function(returnValues) {
	Object.assign(autoScriptOverrideList, returnValues.overrideList);
	output = {...output, ...returnValues.output};

	/* AutoScripts */
	let AutoScript = "";
	let triggerType = "None";

	/* Get AutoScript from taken action */
	switch (buttonid) {
		case "def": case "evd": AutoScript = values.outfitAutoScript; break;
		case "egoWeapon": case "egoDef": case "egoEvd": AutoScript = values.egoAutoScript; break;
		default: AutoScript = values[`${buttonid}AutoScript`]; break;
	}

	/* Get trigger type if any */
	switch (basetype) {
		case "Attack": triggerType = "Offensive"; break;
		case "Defend": triggerType = "Block"; break;
		case "Evade": triggerType = "Evade"; break;
	}

	/* Get tool AutoAcript if any */
	if (toolselect != "0") {
		AutoScript += "(Reset)" + values[`${toolselect}AutoScript`];
	}

	/* Get skill AutoAcript if any */
	if (skillselect && skillselect != "0" && basetype == skilltype) {
		AutoScript += "(Reset)" + values[`${skillselect}AutoScript`];
	}
	
	/* Clean AutoScript. Remove nested and undefined */
	AutoScript = AutoScript.replaceAll(/\[([#][^]+?[#])\]/g, "");
	AutoScript = AutoScript.replaceAll("undefined", "");
	
	resetConditionals();
	AutoScriptMain(AutoScript, triggerType, "true", "false", autoScriptOverrideList, function(returnValues) {
	
	let autoScriptMessage = returnValues.message || "";
	let chatButtonList = returnValues.buttonList || {}

	let autoeffectdice1 = returnValues.DiceCount || 0;
	let autoeffectdice2 = returnValues.DiceMax || 0;
	let autoeffectdice3 = returnValues.DicePower || 0;
	let autoeffectadv = returnValues.DiceAdv || 0;
	let autoEffectLight = returnValues.Light || 0;
	
	/* Power */
	let activepower = "0";
	switch (basetype) {
		case "Attack": activepower = parseInt(values.attPower) + parseInt(values.Strength) - parseInt(values.Feeble);
					   attackmessage = weapontype + " | " + weaponrange + weaponuse + skillmass + "<br>"; break;
		case "Defend": activepower = parseInt(values.defPower) + parseInt(values.Endurance) - parseInt(values.Disarm); break;
		case "Evade": activepower = parseInt(values.evdPower) + parseInt(values.evdPositive) - parseInt(values.evdNegative); break;
	}

	/* Distortion modifiers */
	let distortdice1 = "0";
	let distortdice2 = "0";
	let distortdice3 = "0";
	let distorteffect = "";

	if (rawcheck == "distort") {
		switch (buttonid) {
			case "def": case "evd":
				distortdice1 = values[`distort${capitalize(buttonid)}Dice1`];
				distortdice2 = values[`distort${capitalize(buttonid)}Dice2`];
				distortdice3 = values[`distort${capitalize(buttonid)}Dice3`];
				distorteffect = values[`distortEffect2`]; break;
			default:
				distortdice1 = values[`distortWeaponDice1`];
				distortdice2 = values[`distortWeaponDice2`];
				distortdice3 = values[`distortWeaponDice3`];
				distorteffect = values[`distortEffect`];
		}
	}

	/* Dice formatting */
	combinedice1 = Math.max(parseInt(basedice1) + parseInt(distortdice1) + parseInt(skilldice1) + parseInt(autoeffectdice1), 0);
	combinedice2 = Math.max(parseInt(basedice2) + parseInt(distortdice2) + parseInt(skilldice2) + parseInt(autoeffectdice2), 0);
	combinedice3 = parseInt(basedice3) + parseInt(distortdice3) + parseInt(skilldice3) + parseInt(activepower) + parseInt(autoeffectdice3);

	if(values.settingMultihitUses == "true" && limitbehavior != "Limitless" && limitbehavior != null){
		if(combinedice1 > currentuses){
		combinedice1 = newuses;
		newuses = "0";
		}
		else if(combinedice1 <= currentuses){
			newuses = Math.max(newuses - combinedice1, 0);
		}
	}
	else if(values.settingMultihitUses != "true" && limitbehavior != "Limitless" && limitbehavior != null) {
		newuses = Math.max(newuses - 1, 0);
	}

	/* Multi-hit roll prep */
	let multihitdebuff = "";
	if(combinedice1 > 1 && multihitfull != "true"){
		if(multistyle == "Flat"){
		multihitdebuff = multipenalty;	
		}
		else {
		multihitdebuff = parseInt((multipenalty)*(combinedice1 - 1));
		}
	}

	let rollformat = "";
	let baseformat = "1d" + combinedice2 + "+" + combinedice3 + "+(" + parseInt(difficulty) + ")" + multihitdebuff;

	/* Raw base dice override */
	if(rawcheck == "raw"){
		combinedice1 = basedice1;
		conbinedice2 = basedice2;
		combinedice3 = basedice3;
	}

	/* Advantage processing */
	let advmod = "";
	let advquantity = "";
	let advformat = "{(" + baseformat + "), (" + baseformat + ")}";
	let acounter = "0";
	let dcounter = combinedice1;
	let rollformatmessage = combinedice1 + "d" + combinedice2 + "+" + combinedice3 + "+(" + parseInt(difficulty) + ")" + multihitdebuff + lightmessage;

	if (autoeffectadv != 0) {
		let sumadv = Math.min(advcounter, dcounter) - Math.min(disadvcounter, dcounter) + Math.min(autoeffectadv, dcounter);

		if (sumadv == 0) {
			advstate = "0";
		} else if (sumadv > 0) {
			advcounter = sumadv;
			advstate = "Advantage";
		} else {
			disadvcounter = -sumadv;
			advstate = "Disadvantage";
		}
	}

	switch (advstate) {
		case "Advantage":
			advmod = "kh1";
			acounter = advcounter;
			rollformatmessage = rollformatmessage + " <span style='color: #85a874;'>(" + langAdv;
			break;
		case "Disadvantage": 
			advmod = "dh1";
			acounter = disadvcounter;
			rollformatmessage = rollformatmessage + " <span style='color: #cc4125;'>(" + langDisadv;
			break;
	}
	
	if(advstate != "0" && acounter == "0"){
		acounter = dcounter;
		rollformatmessage += ") </span>";
	}
	else if(acounter > dcounter && advstate != "0"){
		acounter = dcounter;
		rollformatmessage += " x" + acounter + ")</span>";
	}
	else if(acounter <= dcounter && advstate != "0"){
		rollformatmessage += " x" + acounter + ")</span>";
	}

	/* Multi-hit formatting */
	let diceCount = 0;
	if(combinedice1 > 1){
		if(acounter != "0") {
			for(let i = 0; i< acounter ;i++) {
				rollformat += ` {{roll${diceCount+1}=[[${advformat}${advmod}]]}}`;
				dcounter--
				diceCount++
			}
		}
		if(dcounter > 0){
			for(let i = 0; i< dcounter ;i++) {
				rollformat += ` {{roll${diceCount+1}=[[${baseformat}]]}}`;
				diceCount++
			}
		}
	}
	else {
		rollformat = (advstate != "0") ? `{{roll1=[[${advformat}${advmod}]]}}` : `{{roll1=[[${baseformat}]]}}`;
	}

	let distortformat = "";
	if(rawcheck == "distort"){
	distortformat = "<br><div style='width: 100%; background-color: #111; height: 80px; float: left; text-align: center; color:" + headertext + "'><b>" + langDistortEffect + "</b><br><div style='overflow: auto; border-top: 1px #555 solid; height: 70px;'>" + distorteffect + "</div></div>";
	}

	let baseEffectDescription = "<br><div class='descriptionContainer'><b>" + langEffectBase + ":</b><br><div class='effectDescription'>" + baseeffect + "</div></div>";
	let skillEffectDescription = "<div class='descriptionContainer'><b>" + langEffectSkill + ":</b><br><div class='effectDescription'>" + skilleffect + "</div></div>"
	if (baseeffect == "") { baseEffectDescription = ""; }
	if (skilleffect == "(No Skill)" || skilleffect == "") { skillEffectDescription = ""; }

	if(toolselect != "" && toolselect != null && toolselect != "0") {
		toolDescription = "<div style='text-align: center; padding-top: 3px; padding-bottom: 3px;'><div style='text-align: left; padding: 5px;'>" + tooldesc + "</div></div>";
		toolEffectDescription = "<br><b>" + langEffectTool + ":</b><div class='toolEffect' style='max-height: 60px; width: 96.5%; border: 1px #555 solid; overflow: auto; float: left; padding: 3px;'>" + tooleffect + "</div>";
		if (tooleffect == "") { toolEffectDescription = ""; toolDescription = toolDescription.replaceAll(" padding-bottom: 3px;","").replaceAll(" padding: 5px;"," padding-top: 5px;"); }

		toolinfo = "<br><b>" + langUse + "</b>: " +  toolname + "<br>";
		
		skillEffectDescription += toolEffectDescription;
		skillinfo += toolinfo;
	}

	if (hidebaseffect == "true") { baseEffectDescription = ""; skillEffectDescription = ""; }

	let header = "<div style='background-color: #222; overflow: hidden; height: 30px; border: 2px #000 solid; color: " + headertext + "'><div style='float: left'><img src='" + newicon + "' style='width: 30px; height: 30px; border-right: 2px #000 solid; margin-right: 5px; background-color:" + headercolor + "'></div><div style='width: 55%; overflow: hidden; height: 20px; padding-top: 5px; float: left;'><b>" + basename + "</b></div></div>";

	let body = "<b>" + langFrom + ": </b>"+ charname + "<br>"
	if (targetname != "") { body += "<b>" + langTarget + ": </b>"+ targetname + "<br>"; }
	body += "<b>" + langRoll + ": </b>" + rollformatmessage + skillinfo + "<div style='text-align: center'>" + attackmessage + "</div>" + baseEffectDescription + skillEffectDescription + distortformat;

	let info = header + body + autoScriptMessage;

	if(simpledisplay == "true"){
	info = header;
	}

	setAttrs({...output, "dummy":info, "Light":newlight + autoEffectLight, "advState":advstate ,"skillSelect":"0", [`${uses}`]:newuses}, () => {

	let whisper = "";
	if(whisperrolls == "true"){
	whisper = "/w " + whispertarget;
	}

	/*--- send roll end --*/
	startRoll((whisper + `&{template:baseRoll} ${rollformat} {{advantage=@{advState}}} {{infodump=@{dummy}}}`), (results) => {

		let total = 0;
		let rollList = {}
		for (let i = 1; i <= 10; i++) {
			let rollKey = "roll" + i;
			if (results.results.hasOwnProperty(rollKey)) {
				rollList[rollKey] = Math.max(parseInt(results.results[rollKey].result), 0);
			}
		}
		
		finishRoll(results.rollId);

		/* Store defensive reaction rolls */
		if (basetype == "Defend" && targeting == "true") {
			setAttrs({lastDefenceRoll: Math.max(parseInt(rollList["roll1"]),0)})
		} else {
			setAttrs({lastDefenceRoll: 0})
		}

		/* Handle Apply damage action button for attacks */
		let damageButtonList = {}
		let damageAutoScript = "";
		let buttonTarget = (targetname != "") ? targetname : "selected";

		if (basetype == "Attack") {
			/* If an "Apply damage" button already exists, add its AutoScript to the action button of the first attack */
			if (chatButtonList[buttonTarget] && chatButtonList[buttonTarget]["Apply damage"]) {
				damageAutoScript = chatButtonList[buttonTarget]["Apply damage"].data.buttonAutoScript;
				delete chatButtonList[buttonTarget]["Apply damage"]
			}

			/* Remove any (Add N HP/ST/SP) from damageAutoScript, leaving only (Add N Light) and any non-Add effects */
			/* This functionality is already handeled by the flatBarOverrides */
			damageAutoScript = damageAutoScript.replaceAll(/(\(Add -?\d+ \w{2}\))/g, "");
		
			let damage_data = {
				BaseDamage: returnValues.BaseDamage || 0,
				BaseDamageHP: returnValues.BaseDamageHP || 0,
				BaseDamageST: returnValues.BaseDamageST || 0,
				FlatDamageHP: returnValues.FlatDamageHP || 0,
				FlatDamageST: returnValues.FlatDamageST || 0,
				FlatDamageSP: returnValues.FlatDamageSP || 0,
				FlatDamageLight: returnValues.FlatDamageLight || 0,
				damageTypeOverride: weapontype || "---"
			}

			for (const rollKey in rollList) {
				damage_data.BaseDamage = Math.max(parseInt(rollList[rollKey]) + parseInt(damage_data.BaseDamage),0);

				let rollNumber = ` (#${rollKey.replace("roll","")})`;
				if (length(rollList) == 1) {
					rollNumber = "";
				}

				let buttonName = "Apply damage"+rollNumber
				let buttonIcon = getIcon("icons","damage","false","url");
				let buttonColor = "red";
				let buttonData = {...damage_data, buttonAutoScript:"", targetTokenId:targettokenid}
				if (rollKey == "roll1") { buttonData.buttonAutoScript = damageAutoScript; }

				generateChatButton(damageButtonList, buttonTarget, buttonName, buttonIcon, buttonColor, buttonData, "chatButtonDamage", "half");
			}
		}

		for (const target of Object.keys(damageButtonList)) {
			if (chatButtonList[target]) {
				damageButtonList[target] = {...damageButtonList[target], ...chatButtonList[target]}
				delete chatButtonList[target]
			}
		}
		createChatButtons({...damageButtonList, ...chatButtonList}, {reactions:targettokenid});
    });
	/*--- send roll end ---*/

	/* Cleanup */
	updateAdvantages(combinedice1);
	});
	});
    });
	});
	});
	});
	});
}


/* Executes one or more rolls and posts the results to the chat */
function executeRolls(rollArray, callback=()=>{}) {
	getAttrs(["settingWhisperRolls", "settingWhisperTarget"], function(values) {

	let whisperrolls = values.settingWhisperRolls;
	let whispertarget = values.settingWhisperTarget;
	let whisper = (whisperrolls == "true") ? "/w " + whispertarget : "";
	
	let message = "";
	let dicerolls = "";
	let rollindex = 0;
	let returnValues = {}
	let output = {}

	let exampleRoll = [
		{ // Multi-hit attack with a different weapon for the second attack
			type: "Attack",
			format: [
				{count: 1, max: 12, power: 2, adv: "Advantage", storable: true}, // Count no longer rolls multiple seperate dice, and instead combine them into one roll (similar to stat rolls)
				{count: 1, max: 11, power: 3}
			],
			AutoScript: "(Gain 1 Tremor) (Inflict 2 Burn, Clash Win)", // If multiple dice are rolled, AutoEffect messages display next to their associated roll
			icon: false, // Uses default icon and color (Attack symbol over a red dice)
			origin: false, // Source of the dice. Displays in a grayed out italic text between the header and description
			store: { // Allows storing of dice. If the format is an array, only dice with storable = true can be stored
				immediate: false, // Dice is rolled and can be stored afterwards. If false, the dice is not rolled and stored immediately
				duration: 1, // Dice is stored for 1 round. Can be set to "Combat", "Recover" or "Refresh" to last until the next of these actions. If unset, lasts until the dice is used or manually removed
				uses: 2, // The dice can be used 2 times. If set to a non-integer value the dice has an unlimited amount of uses
				charId: "-abc", // Character id of the attacking character. If set, only this character can store dice from the attack. Can be another character's id
				tokenId: false, // As charId above, but also requires a specific token id. Swaps to the correct token if needed
			},
			header: false, // The title and/or icon of the roll. If unset, the dice instead displays in a vertical black bar on the far right side of the message
			description: false, // The description without any AutoEffect messages. Can contain HTML and inline rolls
			variable: false // The name of the variable the result is saved to
		},
		{ // Standard fortitude stat roll with disadvantage. Stat rolls either add the bad/normal/good element using HTML, or sets a challange value in the template which reveals the extra HTML
			type: "Fortitude",
			format: {count: 2, max: 6, power: 1, adv: "Disadvantage"},
			AutoScript: false,
			icon: false,
			origin: "Skill - Seize Them", // Dice added by a skill called "Seize Them"
			store: false,
			header: false,
			description: "Seize them both in heart and spirit",
			variable: false
		},
		{ // Poise roll. Would usually be together with the Clash Win effects after the attack
			type: "Custom",
			format: {count: 1, max: 10, power: 0, result: 7}, // If result is set, [[result]] is rolled instead of [[1d10+0]]. Useful when the result is calculated before the message is sent
			AutoScript: false,
			icon: {
				image: "https://...limbus/Poise.png", // Uses a custom icon over a dark dice
				color: "Dark"
			},
			origin: "Ailment Roll", // Dice created by a custom ailment with type = "Roll"
			store: false,
			header: {
				title: "Poise Roll",
				color: false, // If unset the header is transparent
				icon: {
					image: "https://...icons/Harm.png", // Would normally be unset. Included for example purposes
					color: "Purple"
				},
			},
			description: false,
			variable: "PoiseRoll" // Stores result for any further use. Could alternatively be an attribute name (repeating_ailments_-abc_ailRollResult)
		}
	]



	/* Adds a new roll to the chat message. Returns an insertRoll string that can be inserted anywhere in the HTML to display the roll */
	function newRoll(format, name) {
		let baseroll = format.result || `${format.count}d${format.max}+(${format.power})`;
		
		if (format.adv) {
			let advmod = (format.adv == "Advantage") ? "kh1" : (format.adv == "Disadvantage") ? "dh1" : "";
			baseroll = `{(${baseroll}), (${baseroll})}${advmod}`;
		}

		dicerolls += `{{${name}=[[${baseroll}]]}} `;
		return `$&#91;&#91;${rollindex++}.computed&#93;&#93;`;
	}




	rollArray = exampleRoll;
	
	for (let i = 0; i < rollArray.length; i++) {
		let roll = rollArray[i];
		let insertRoll = "";

		/* Add all rolls from the current action */
		if (Array.isArray(roll.format)) {
			for (let j = 0; j < roll.format.length; j++) {
				insertRoll += newRoll(roll.format[j], "roll"+i+j);
			}
		} else {
			insertRoll = newRoll(roll.format, "roll"+i);
		}
		



		/* Handle Combat rolls */
		if (combatRollNames.includes(roll.type)) {
			let icon = (roll.type == "Attack") ? "egoAtt"
					 : (roll.type == "Block") ? "egoDef"
					 : (roll.type == "Evade") ? "egoEvd" : "";

			message += `<div class="sheet-statRollResult">${insertRoll} <b>${roll.type}</b> <img src="${getIcon("icons",icon,"false","url")}"></div>`;
		}

		/* Handle Stat rolls */
		else if (statNamesFull.includes(roll.type)) {
			// Execute the roll. Check the result variable. Add extra message based on the value
			let statRoll = 7;
			let statResult = (statRoll < 7)  ? {icon: "bad", message: getTranslationByKeyCustom("Failure...", "message-failure")}
						   : (statRoll < 10) ? {icon: "normal", message: getTranslationByKeyCustom("Partial Success", "message-normal")}
						   : {icon: "good", message: getTranslationByKeyCustom("Success!", "message-success")}
			
			message += `<div class="sheet-statRollResult">${insertRoll} <b>${statResult.message}</b> <img src="${getIcon("icons",statResult.icon,"false","url")}"></div>`;
		}

		/* Handle Speed and Luck rolls */
		else if (["Speed", "Luck"].includes(roll.type)) {
			let icon = (roll.type == "Speed") ? "Speed"
					 : (roll.type == "Luck") ? "fortunewhite" : "";

			message += `<div class="sheet-statRollResult">${insertRoll} <b>${roll.type}</b> <img src="${getIcon("icons",icon,"false","url")}"></div>`;
		}

		/* Handle Custom rolls */
		else if (roll.type == "Custom") {
   			message += `<div class="sheet-statRollResult"> [${roll.format.result}](#" name="${insertRoll}) <b>${roll.header.title}</b> <img src="${getIcon("ailments/limbus","Poise","false","url")}"></div>`;
		}

		else {
			console.log("Error: unknown roll type: " + roll.type)
		}


	}

	let header = "test header";
	let body = message;
	
	console.log(`&{template:customRoll} ${dicerolls} ${header} ${body}`)

	setAttrs({"dummy":header, "dummy2":body}, () => {

		/* Send the roll message */
		//   Header: Consists of a title, and icon, an optional image and any generated tabs
		//   Body: Displays each rolls and any associated headers/descriptions/etc. The rolls are inline. Each roll is hidden by default if tabs are used
		//   Chat buttons: Sent seperately
		startRoll((whisper + `&{template:customRoll} ${dicerolls} {{header=@{dummy}}} {{body=@{dummy2}}}`), (results) => {
			
			console.log(results)
			
			finishRoll(results.rollId, { //tipsy-n-right
				roll2: `" class="inlinerollresult showtip" style="color: #eee; text-decoration: none; " original-title="&lt;img src='/images/quantumrollwhite.png' class='inlineqroll'&gt; Rolling 1d11+(3) = (4?)+(3???) You can add anything here, including pictures &lt;img src='https://raw.githubusercontent.com/beautidemise/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/ailments/limbus/Poise.png' class='inlineqroll'&gt;, non-userscript classes, input elements etc. &lt;input type='date' style='width: 80%;' &gt;" class="`,
				key: "test222"
			} );
		});

		/*
		Uses #allprops. Consists of a container and a header with a name equal to the prop key. All other HTML elements are created from the prop value
		All rolls are inline, are are surrounded by a container with additional info for the roll used for styling
		The inline rolls can be written directly in the HTML code and parses with no issues
		If storing rolls is allowed, each roll container gains an action button to store that dice (has all the same data except store = false and diceFormat cannot be an array)
		*/

		if (callback != "()=>{}") {
			callback(returnValues);
		}

	});
	});
}

/* Action: Challenge Roll */
on('clicked:rollChallenge', (info) => {
	/* Get IDs/names */
	let buttonid = info.htmlAttributes.id.split('_')[1];
	rollChallenge(buttonid);
});
function rollChallenge(buttonid, rollDifficulty=0, collectAutoScripts="false") {
	
	/* Preparing values */
	let headercolor = "#888";
	let newicon = "/";
	let headertext = "#fff";
	let challenge = "{{challenge= }}";
	let basetype = "";

	/* Get attributes */
    getAttrs([`${buttonid}`, "advState", "difficulty", "justice", "settingSimpleDisplay", "settingWhisperRolls", "settingWhisperTarget", "character_name", "targetTokenId", "advNum", "disadvNum", "Fortune", "Paralysis"], function(values) {

	let charname = values.character_name;
	let targettokenid = values.targetTokenId || "";
	let stat = values[buttonid];
	let statn = capitalize(buttonid);
	let advstate = values.advState || "0";
	let advcounter = values.advNum || values.Fortune || 0;
	let disadvcounter = values.disadvNum || values.Paralysis || 0;
	let simpledisplay = values.settingSimpleDisplay;
	let whisperrolls = values.settingWhisperRolls;
	let whispertarget = values.settingWhisperTarget;
	let tracker = "";

	let difficulty = parseInt(values.difficulty) + parseInt(rollDifficulty);
	let spdjustice = values.justice;
	let lucknum = "0";

	/* AutoScripts */
	let autoScriptTriggers = ["None"];
	if (buttonid == "speed") { autoScriptTriggers.push("Combat start"); collectAutoScripts = "true"; }
	else if (buttonid != "luck") { autoScriptTriggers.push("Challenge"); collectAutoScripts = "true"; }

	if (collectAutoScripts == "true") { resetConditionals(); }
	AutoScriptMain("", autoScriptTriggers, collectAutoScripts, "false", {}, function(returnValues) {
	
	if (returnValues.DicePower) { stat += parseInt(returnValues.DicePower); }
	let autoEffectDiceCount = returnValues.DiceCount || 0;
	let autoEffectDiceMax = returnValues.DiceMax || 0;
	let autoEffectDiceAdv = returnValues.DiceAdv || 0;
	let autoEffectSpeedCombat = returnValues.SpeedCombat || 0;
	let autoScriptMessage = returnValues.message || "";
	let chatButtonList = returnValues.buttonList || {}
	
	let rollformat = Math.max(autoEffectDiceCount + 2, 0) + "d" + Math.max(autoEffectDiceMax + 6, 0) + "+" + parseInt(stat) + "+(" + parseInt(difficulty) + ")";

	/* Type Formatting */
	switch (statn) {
		case "Luck":
			newicon = getIcon("icons", "fortunewhite", "false", "url");
			headercolor = "#dbb748";
			rollformat = `2d6+(${parseInt(difficulty)})`;
			challenge = " ";
			break;
		case "Speed":
			newicon = getIcon("icons", "Speed", "false", "url");
			headercolor = "#cf8c44";
			tracker = "&{tracker}"
			rollformat = `1d6+(${parseInt(spdjustice) + parseInt(autoEffectSpeedCombat) + parseInt(difficulty)})`;
			challenge = " ";
			break;
		default: newicon = getIcon("stats", statn, "false", "url");
	}

	/* Translation prep */
	let langFrom = getTranslationByKeyCustom("From", "message-from");
	let langRoll = getTranslationByKeyCustom("Roll", "message-roll");
	let langAdv = getTranslationByKeyCustom("Adv.", "message-adv");
	let langDisadv = getTranslationByKeyCustom("Disadv.", "message-disadv");
	let langStat = getTranslationByKeyCustom(statn, "stats-" + buttonid);

	/* Advantage processing */
	let advmod = "";
	let rollformatmessage = rollformat;
	rollformat += tracker;

	if (autoEffectDiceAdv != 0) {
		let sumadv = Math.min(advcounter, 1) - Math.min(disadvcounter, 1) + Math.min(autoEffectDiceAdv, 1);

		if (sumadv == 0) {
			advstate = "0";
		} else if (sumadv > 0) {
			advstate = "Advantage";
		} else {
			advstate = "Disadvantage";
		}
	}

	switch (advstate) {
		case "Advantage": advmod = "kh1"; break;
		case "Disadvantage": advmod = "dh1"; break;
		default: advstate = " ";
	}
	if (advstate != " ") {
	rollformat = "{(" + rollformat + "), (" + rollformat + ")}" + advmod;
	rollformatmessage = rollformatmessage + " <span style='color: #85a874;'>(" + langAdv + ")</span>";
	}

	let header = "<div style='background-color: #222; overflow: hidden; height: 30px; border: 2px #000 solid; color: #fff'><div style='float: left'><img src='" + newicon + "' style='width: 30px; height: 30px; border-right: 2px #000 solid; margin-right: 5px; background-color:" + headercolor + "'></div><div style='width: 55%; overflow: hidden; height: 20px; padding-top: 5px; float: left;'><b>" + langStat + "</b></div></div>";

	let body = "<b>" + langFrom + ": </b>" + charname + "<br><b>" + langRoll + ": </b>" + rollformatmessage;

	let info = header + body + autoScriptMessage;

	if(simpledisplay == "true"){
		info = header;
	}

	let whisper = "";
	if(whisperrolls == "true"){
		whisper = "/w " + whispertarget;
	}


	setAttrs({"dummy":info, "advState":advstate, "skillSelect":"0"});

	/*--- send roll end --*/
	startRoll((whisper + `&{template:baseRoll} {{roll1=[[${rollformat}]]}} {{infodump=@{dummy}}} ${challenge}`), (results) => {
	    const total = results.results.roll1.result;

		switch (statn) {
			case "Luck": setAttrs({"baseLuckNum": total }); break;
			case "Speed": setAttrs({"baseSpeed": total, "isFirstRound": "true", "prevRoundInitAttempts": 1}); break;
		}
		finishRoll(results.rollId);
		
		/* Create action Buttons */
		createChatButtons(chatButtonList);
	});
	/*--- send roll end ---*/

	/* Cleanup */
	updateAdvantages("1");
	});
	});
}


/* Action: Damage helper Apply damage */
on('clicked:applyDamage', (info) => {
	getAttrs(["lastDefenceRoll"], function(values) {
		let defenceRoll = parseInt(values.lastDefenceRoll);
		damageHelper({}, defenceRoll);

		setAttrs({lastDefenceRoll: 0});
	});
});

function damageHelper(overrideList={}, defenceRoll=0) {

	let tokenId = "";
	if (overrideList.tokenId != undefined) {tokenId = overrideList.tokenId; }
	changeActiveToken(tokenId, () => {

	/* Retrieve global settings for Smoke settings */
	getSectionIDs(`repeating_global`, idarray => {
	let id = `repeating_global_${idarray[0]}`;

	/* Get custom ailment attributes */
	getSectionIDs(`repeating_ailments`, idarray => {
		const fieldnames = idarray.map(id => `repeating_ailments_${id}_`).reduce((rows,prefix) =>  [...rows, `${prefix}ailTrigger`, `${prefix}ailDamageTypeTrigger`,
		`${prefix}ailBeforeResistance`, `${prefix}ailPositiveType`, `${prefix}ailDecayWhenHit`, `${prefix}ailEffect`, `${prefix}ailEffectMode`, `${prefix}ailEffectVal`,
		`${prefix}ailCustomResistanceNum`, `${prefix}ailCustomResistanceNumEgo`, `${prefix}ailNum`, `${prefix}ailName`, `${prefix}ailIcon`], '');

	/* Get attribute values */
	getAttrs([...fieldnames, "character_name", "targetTokenId", "HP", "StagRes", "SP", "HP_max", "StagRes_max", "SP_max", "THP_Sources", "TST_Sources",
	"settingLimbusStyle", "settingWhisperRolls", "settingWhisperTarget", "settingSimpleDisplay", "settingAutoApplyDamage", "settingHideBarUpdate",
	"baseDamage", "flatDamageHP", "flatDamageST", "damageHelperType",
	"distortState", "egoActiveState", "egoType", "StaggerState", "damageResist", "damageResist_ego",
	"Fragile", "Protection", "StaggerProtection", "Smoke", `${id}_smokeCalculationMode`, `${id}_smokeCalculationVal`,
	"outfitImmune1", "outfitImmune2", "outfitImmune3", "outfitImmune4", "outfitImmune5", "outfitImmune6",
	"egoImmune1", "egoImmune2", "egoImmune3", "egoImmune4", "egoImmune5", "egoImmune6"], function(values) {

	const output = {};

	let settingLimbusStyle = values.settingLimbusStyle;
	let whisperrolls = values.settingWhisperRolls;
	let whispertarget = values.settingWhisperTarget;
	let simpledisplay = values.settingSimpleDisplay;
	let autoapplydamage = values.settingAutoApplyDamage;
	let hidebarupdate = values.settingHideBarUpdate;
	
	let characterName = values.character_name;
	let targetTokenId = values.targetTokenId || "";

	let maxHP = parseInt(values.HP_max);
	let maxST = parseInt(values.StagRes_max);
	let maxSP = parseInt(values.SP_max);
	let oldHP = newHP = parseInt(values.HP);
	let oldST = newST = parseInt(values.StagRes);
	let oldSP = newSP = parseInt(values.SP);

	let baseDamage = overrideList.BaseDamage || parseInt(values.baseDamage);
	let baseDamageHP = overrideList.BaseDamageHP || 0;
	let baseDamageST = overrideList.BaseDamageST || 0;
	let flatDamageHP = overrideList.FlatDamageHP || parseInt(values.flatDamageHP);
	let flatDamageST = overrideList.FlatDamageST || parseInt(values.flatDamageST);
	let flatDamageSP = overrideList.FlatDamageSP || 0;
	let damageType = overrideList.damageTypeOverride || values.damageHelperType;

	let hpResistance = 1.0;
	let stResistance = 1.0;
	let damageResistance = 0;

	let distortState = values.distortState;
	let egoType = values.egoType;
	let egoActiveState = values.egoActiveState;
	let staggerState = values.StaggerState;
	let outfitType = "";

	let autoScript = overrideList.buttonAutoScript || "";
	
	let THP_Sources = (values.THP_Sources != "" && values.THP_Sources != "{}") ? JSON.parse(values.THP_Sources) : {}
	let TST_Sources = (values.TST_Sources != "" && values.TST_Sources != "{}") ? JSON.parse(values.TST_Sources) : {}

	let ailCalculationList = {}; 


	/* Checks active character outfit type: ego or standard outfit */
	/* Applies damage resistance effect based on the type */
	if (egoActiveState == "true" && egoType == "Outfit") {
		outfitType = "ego";
		damageResistance = parseInt(values.damageResist_ego);
	} else {
		outfitType = "outfit";
		if (distortState != "true") { damageResistance = parseInt(values.damageResist); }
		else if ((distortState == "true")) { damageResistance = parseInt(values.damageResist_ego); }
		
	}

	/* Get resistance values based on outfit type. On stagger, resistances are fatal (2x) */
	if (staggerState == "Staggered") {
		hpResistance = 2.0; stResistance = 2.0;
	} else {
		switch (damageType) {
			case "Slash": hpResistance = parseFloat(values[`${outfitType}Immune1`]); stResistance = parseFloat(values[`${outfitType}Immune2`]); break;
			case "Pierce": hpResistance = parseFloat(values[`${outfitType}Immune3`]); stResistance = parseFloat(values[`${outfitType}Immune4`]); break;
			case "Blunt": hpResistance = parseFloat(values[`${outfitType}Immune5`]); stResistance = parseFloat(values[`${outfitType}Immune6`]); break;
		}
	}

	/* If one or both resistances are unset, give an error message and return */
	if (isNaN(hpResistance) || isNaN(stResistance)) {
		let alertOutfitType = (outfitType == "ego") ? "mystery" : "outfit";
		let alertIcon = getIcon("ailments", "Aggro", "true", "markdown");
		let langAlertMessage = getTranslationByKeyCustom(`${capitalize(alertOutfitType)} resistances not set for`, `message-${alertOutfitType}-missing-resistance`);
		let langDamage = getTranslationByKeyCustom("damage", "message-damage");
		let alertMessage = `${langAlertMessage} ${damageType} ${langDamage}`;
		
		startRoll((`/w ${characterName} &{template:errorMessage} {{icon=${alertIcon}}} {{message=${alertMessage}}}`), (results)  => {
            finishRoll(results.rollId, {} );
    	});
		return;
	}


	/* Damage calculations block beginning */

	/* Sum of all modifiers that apply before resistances */
	let sumBothBefore = -baseDamage;
	let sumHpBefore = -baseDamageHP;
	let sumStBefore = -baseDamageST;

	/* Sum of all modifiers that apply after resistances*/
	let sumBothAfter = 0;
	let sumHpAfter = -flatDamageHP;
	let sumStAfter = -flatDamageST;

	/* Percentage modifier to modifiers before resistance. Currently only used by the Smoke "%" mode */
	let percentageModHP = 1.0;

	/* Sum of all modifiers that do not take resistance into consideration */
	let sumSanity = -flatDamageSP;

	/* Get damage modifiers from status ailments */
	let hpFragile = parseInt(values.Fragile);
	let hpProtection = parseInt(values.Protection);
	let stProtection = parseInt(values.StaggerProtection);
	let smoke = parseInt(values.Smoke);
	let smokeCalcMode = values[`${id}_smokeCalculationMode`];
	let smokeCalcVal = values[`${id}_smokeCalculationVal`];

	/* Fragile applies a flat amount of damage */
	sumHpAfter -= hpFragile;

	/* Get damage modifiers from When Hit custom status ailments */
	let hpStRegen = 0;
	let stRegen = -flatDamageST;
	let hpRegen = -flatDamageHP;
	let spRegen = -flatDamageSP;

	idarray.forEach(id => {

		let ailType = "";
		let ailTrigger = values[`repeating_ailments_${id}_ailTrigger`] || "";
		let ailDamageTypeTrigger = values[`repeating_ailments_${id}_ailDamageTypeTrigger`] || "";
		let ailBeforeResistance = values[`repeating_ailments_${id}_ailBeforeResistance`] || "";
		let ailDecayWhenHit = values[`repeating_ailments_${id}_ailDecayWhenHit`] || "";
		let ailEffect = values[`repeating_ailments_${id}_ailEffect`] || "";
		let ailEffectMode = values[`repeating_ailments_${id}_ailEffectMode`] || "";
		let ailEffectVal = values[`repeating_ailments_${id}_ailEffectVal`] || 0;
		let ailCustomResistanceNum = parseInt(values[`repeating_ailments_${id}_ailCustomResistanceNum`]) || 0;
		let ailCustomResistanceNumEgo = parseInt(values[`repeating_ailments_${id}_ailCustomResistanceNumEgo`]) || 0;
		
		let ailName = values[`repeating_ailments_${id}_ailName`] || "";
		let ailIcon = values[`repeating_ailments_${id}_ailIcon`] || "";
		let count = parseInt(values[`repeating_ailments_${id}_ailNum`]) || 0;

		if ((/(-[0-9]*n)/).test(ailEffectVal)) {
			ailType = "Damage";
		} else {
			if (ailBeforeResistance == "beforeResistance") { ailType = "Reduction"; }
			else { ailType = values[`repeating_ailments_${id}_ailPositiveType`]; }
		}

		if (egoActiveState == "true" && egoType == "Outfit" && distortState != "true") {
			ailCustomResistanceNum = parseInt(ailCustomResistanceNumEgo);
		}
		else if (distortState == "true") {
			ailCustomResistanceNum += parseInt(ailCustomResistanceNumEgo);
		}
		
		let tempSumBoth = 0;
		let tempSumHp = 0;
		let tempSumSt = 0;
		
		if (ailTrigger == "WhenHit") {

			if ((ailDamageTypeTrigger == "Any" || ailDamageTypeTrigger == damageType) && (ailEffect != "None" && ailEffect != null && count != 0)) {

				/* Calculate base attribute change and its polarity */
				
				/* Ailment is n or -n multiplied by a number */
				if ((/([0-9]+n)/).test(ailEffectVal)) {
					ailEffectVal = ailEffectVal.replaceAll("n","");
					ailEffectVal = parseInt(count) * parseInt(ailEffectVal)
				}
				else if ((/(-[0-9]+n)/).test(ailEffectVal)) {
					ailEffectVal = (0 - parseInt(count)) * parseInt(ailEffectVal)
				}
				/* Ailment is n or -n */
				else if (ailEffectVal == "n") {
					ailEffectVal = parseInt(count);
				}
				else if (ailEffectVal == "-n") {
					ailEffectVal = (0 - parseInt(count)) + Math.min(count, ailCustomResistanceNum);
				}

				let apply_effect_mode = {
					"x": function (x, y, res) {
						if (y < 1) {
							return Math.floor(x * y) + Math.min(Math.floor(x-(x*y)), ailCustomResistanceNum);
						} else {
							return Math.floor(x * y);
						} 
					},
					"=": function (x, y, res) {
						if (y < x) {
							return x = y + Math.min((x-y), ailCustomResistanceNum);
						} else {
							return x = y;
						}
					}
				};

				
				/* Get effect mode. "x" and "=" apply directly to the relevant stat */
				if (ailEffectMode == "+") {
					switch (ailEffect) {
						case "HPStagRes": tempSumBoth += parseInt(ailEffectVal); break;
						case "HP": tempSumHp += parseInt(ailEffectVal); break;
						case "StagRes": tempSumSt += parseInt(ailEffectVal); break;
						case "SP": sumSanity += parseInt(ailEffectVal); break;
					}
				} else {
					switch (true) {
						case ailEffect == "HPStagRes": 
							newHP = apply_effect_mode[ailEffectMode](newHP, parseFloat(ailEffectVal), ailCustomResistanceNum); /* No break. Intentional fall through */
						case ailEffect == "StagRes":
							newST = apply_effect_mode[ailEffectMode](newST, parseFloat(ailEffectVal), ailCustomResistanceNum);
							ailEffectVal = newST - oldST; break;
						case ailEffect == "HP" : 
							newHP = apply_effect_mode[ailEffectMode](newHP, parseFloat(ailEffectVal), ailCustomResistanceNum);
							ailEffectVal = newHP - oldHP; break;
						case ailEffect == "SP":
							newSP = apply_effect_mode[ailEffectMode](newSP, parseFloat(ailEffectVal), ailCustomResistanceNum);
							ailEffectVal = newSP - oldSP; break;
					}
				}

				/* Select sum to apply modifier to based on damage being before or after resistance */
				if (ailBeforeResistance == "beforeResistance") {
					sumBothBefore += tempSumBoth; sumHpBefore += tempSumHp; sumStBefore += tempSumSt;
				} else {
					sumBothAfter += tempSumBoth; sumHpAfter += tempSumHp; sumStAfter += tempSumSt; 
				}

				/* Regen tracking  */
				if (ailType == "Regen") {
					switch (ailEffect) {
						case "HPStagRes": hpStRegen += tempSumBoth;
						case "StagRes": stRegen += tempSumSt;
						case "HP": hpRegen += tempSumHp;
						case "SP": spRegen += sumSanity;
					}
				}

				/* Temp sum cleanup */
				tempSumBoth = 0; tempSumHp = 0; tempSumSt = 0;

				/* Used to generate a damage calculation message later in this function */
				ailCalculationList[id] = {name: ailName, icon: ailIcon, effect: ailEffect, count: count, effectVal: ailEffectVal, type: ailType, beforeRes: ailBeforeResistance, customRes: ailCustomResistanceNum}
			}
		
			// Decay status ailment
			if (ailDecayWhenHit == "true") {
				updateCustomAilment(id, "decay", "false");
			}
		}
		
	});


	/* Calculate smoke damage */
	if (smoke != 0) {
		switch (smokeCalcMode) {
			case "/": sumHpAfter -= Math.floor(smoke / parseInt(smokeCalcVal)); break;
			case "%": percentageModHP += smoke * parseFloat(smokeCalcVal); break;
			case "=": sumHpAfter -= parseInt(smokeCalcVal); break;
		}
	}

	/* Final calculation */
	/*                          \---------------------------- Before Resistance -----------------------------/        \-------------------- After Resistance -------------------- / */
	newHP += Math.ceil(Math.min((hpResistance * percentageModHP * (sumBothBefore + sumHpBefore + defenceRoll)), 0)) + (sumBothAfter + sumHpAfter + hpProtection + damageResistance);
	newST += Math.ceil(Math.min((stResistance *                   (sumBothBefore + sumStBefore + defenceRoll)), 0)) + (sumBothAfter + sumStAfter + hpProtection + damageResistance);
	newSP += Math.ceil(sumSanity);

	/* Use temporary HP and ST */
	let HPDamage = oldHP - newHP;
	let STDamage = oldST - newST;
	let tempHPUsed = {}
	let tempSTUsed = {}
	
	if (newHP < oldHP) {
		if (length(THP_Sources) > 0) {
			for (const sourceName in THP_Sources) {
				let returnTHP = applyTempBarDamage(sourceName, THP_Sources[sourceName], "THP", HPDamage, newHP);
				if (returnTHP != undefined) {
					if (returnTHP.tempBarVal == 0) {
						delete THP_Sources[sourceName];
					} else {
						THP_Sources[sourceName][0] = returnTHP.tempBarVal;
					}
					newHP = returnTHP.newBar;
					HPDamage = returnTHP.damage;
					tempHPUsed[returnTHP.messageName] = [returnTHP.tempBarVal, returnTHP.messageVal, returnTHP.messageIcon]
				}
			}
			setAttrs({"THP_Sources":JSON.stringify(THP_Sources)});
		}
	}
	if (newST < oldST) {
		if (length(TST_Sources) > 0) {
			for (const sourceName in TST_Sources) {
				let returnTST = applyTempBarDamage(sourceName, TST_Sources[sourceName], "TST", STDamage, newST);
				if (returnTST != undefined) {
					if (returnTST.tempBarVal == 0) {
						delete TST_Sources[sourceName];
					} else {
						TST_Sources[sourceName][0] = returnTST.tempBarVal;
					}
					newST = returnTST.newBar;
					STDamage = returnTST.damage;
					tempSTUsed[returnTST.messageName] = [returnTST.tempBarVal, returnTST.messageVal, returnTST.messageIcon]
				}
			}
			setAttrs({"TST_Sources":JSON.stringify(TST_Sources)});
		}
	}

	/* Caps increase by regen amount */
	newHP = Math.min(newHP, oldHP + hpRegen + hpStRegen);
	newST = Math.min(newST, oldST + stRegen + hpStRegen);
	newSP = Math.min(newSP, oldSP + spRegen);

	/* Apply damage. Caps healing but not damage to the maximum value of the bar */
	if (newHP > maxHP && oldHP < newHP) { newHP = maxHP }
	if (newST > maxST && oldST < newST) { newST = maxST }
	if (newSP > maxSP && oldSP < newSP) { newSP = maxSP }
	output["HP"] = newHP; output["StagRes"] = newST; output["SP"] = newSP;
	if (autoapplydamage == "true") {
		setAttrs(output);
	}

	/* AutoScripts */
	let autoScriptTriggers = [];
	if (newHP < oldHP) { autoScriptTriggers.push("DamagedHP"); }
	if (newST < oldST) { autoScriptTriggers.push("DamagedST"); }
	if (newSP < oldSP) { autoScriptTriggers.push("DamagedSP"); }
	
	resetConditionals();
	AutoScriptMain(autoScript, autoScriptTriggers, "true", "false", {}, function(returnValues) {

	let autoScriptMessage = returnValues.message || "";
	let chatButtonList = returnValues.buttonList || {}
	
	/* console.log("HP base: " + sumBothBefore + ". HP after resistance: " + Math.ceil(Math.min((hpResistance * (sumBothBefore + sumHpBefore)) + hpProtection + damageResistance, 0)))
	console.log("ST base: " + sumBothBefore + ". ST after resistance: " + Math.ceil(Math.min((stResistance * (sumBothBefore + sumStBefore)) + stProtection + damageResistance, 0)))
	console.log("HP flat: " + sumHpAfter)
	console.log("ST flat: " + sumStAfter)
	console.log("HP: " + oldHP + " -> " + newHP);
	console.log("ST: " + oldST + " -> " + newST); */
	
	/* Damage calculations block end */

	/* Translation prep */
	let langBaseDamage = "Base damage";
	let langFlatDamageHP = "Flat HP DMG";
	let langFlatDamageST = "Flat ST DMG";
	let langFlatDamageSP = "Flat SP DMG";
	let langDamage = "damage";
	let langDealt = "dealt";
	let langIncreasedHPDamageBy = "increased HP damage by";
	let langSmoke = "Smoke";
	let langFragile = "Fragile";
	let langProtection = "Protection";
	let langStProtection = "Stagger Protection";
	let langDamageResistance = "Damage Resistance";
	let langDefence = "Block";

	if(getTranslationByKey("helper-text-basedamage") != false){
		langBaseDamage = getTranslationByKey("helper-text-basedamage");
		langFlatDamageHP= getTranslationByKey("helper-text-flatdamagehp");
		langFlatDamageST = getTranslationByKey("helper-text-flatdamagest");
		langFlatDamageSP = getTranslationByKey("helper-text-flatdamagesp");
		langDamage = getTranslationByKey("message-damage");
		langDealt = getTranslationByKey("message-dealt");
		langIncreasedHPDamageBy = getTranslationByKey("message-increased-HP-damage-by");
		langSmoke = getTranslationByKey("ailments-smoke");
		langFragile = getTranslationByKey("ailments-fragile");
		langProtection = getTranslationByKey("ailments-protection");
		langStProtection = getTranslationByKey("ailments-stgprotection");
		langDamageResistance = getTranslationByKey("oufit-damage-resistance");
		langDefence = getTranslationByKey("autoeffect-trigger-block");
	}

	/* Damage calculation chat message block begin */
	let damageCalculation = "";
	let hpDamageHead = ""; 	let hpDamageBody = "";
	let stDamageHead = ""; 	let stDamageBody = "";
	let spDamageHead = ""; 	let spDamageBody = "";
	let resHPIcon = "Res" + damageType;
	let resSTIcon = "Res" + damageType + "Stg";

	/* Calculation summaries (Message head) */
	hpDamageHead = generateDamageHelperHeader("HP", newHP, oldHP, "0", autoapplydamage, hidebarupdate);
	stDamageHead = generateDamageHelperHeader("ST", newST, oldST, staggerState, autoapplydamage, hidebarupdate);
	spDamageHead = generateDamageHelperHeader("SP", newSP, oldSP, "0", autoapplydamage, hidebarupdate);

	/* Simple display settings (Envelops entire body block)*/
	if (simpledisplay == "0") {

	/* Base damage and flat damage/regen */
	let sumBaseDamageHP = -(sumBothBefore + sumHpBefore);
	let sumBaseDamageST = -(sumBothBefore + sumStBefore);
	if (baseDamage != 0) { 
		hpDamageBody += `<div class="baseDamage"><b>${langBaseDamage}:</b> ${sumBaseDamageHP} x [${hpResistance}x]` + getIcon("def", resHPIcon) + "</div>";
		stDamageBody += `<div class="baseDamage"><b>${langBaseDamage}:</b> ${sumBaseDamageST} x [${stResistance}x]` + getIcon("def", resSTIcon) + "</div>";
	}
	if (flatDamageHP != 0) { hpDamageBody += `<div class="flatModifier">${langFlatDamageHP}: ${flatDamageHP}</div>`; }
	if (flatDamageST != 0) { stDamageBody += `<div class="flatModifier">${langFlatDamageST}: ${flatDamageST}</div>`; }
	if (flatDamageSP != 0) { spDamageBody += `<div class="flatModifier">${langFlatDamageSP}: ${flatDamageSP}</div>`; }

	/* Defence roll */
	if (defenceRoll != 0) {
		hpDamageBody += generateDamageHelperBodyEffect(langDefence, defenceRoll, "Defence", 0, getIcon("icons", "egoDef", "false"));
		stDamageBody += generateDamageHelperBodyEffect(langDefence, defenceRoll, "Defence", 0, getIcon("icons", "egoDef", "false"));
	}
	
	/* Fragile*/
	if (hpFragile != 0) { hpDamageBody += generateDamageHelperBodyEffect(langFragile, hpFragile, "Damage", 0, getIcon("ailments", "Fragile", settingLimbusStyle)); }

	/* Smoke */
	if ((smokeCalcMode != "/" && smoke != 0) || (smokeCalcMode == "/" && smoke >= smokeCalcVal)) {
		hpDamageBody += "<div>" + getIcon("ailments", "Smoke", settingLimbusStyle) + "<div>";
		switch (smokeCalcMode) {
			case "/": hpDamageBody += `<b>${langSmoke}</b> ${langDealt} ${Math.floor(smoke/parseInt(smokeCalcVal))} ${langDamage}</div></div>`; break;
			case "%": hpDamageBody += `<b>${langSmoke}</b> ${langIncreasedHPDamageBy} ${Math.floor(smoke * parseFloat(smokeCalcVal) * 100)}%</div></div>`; break;
			case "=": hpDamageBody += `<b>${langSmoke}</b> ${langDealt} ${smokeCalcVal} ${langDamage}</div></div>`; break;
		}
	}

	/* Custom status ailment damage/regen/resistance */
	for (var ailment in ailCalculationList) {
		let ailmentArray = ailCalculationList[ailment];
		
		if (ailmentArray["count"] != 0) {
			if (ailmentArray["effect"] == "HP" || ailmentArray["effect"] == "HPStagRes") { 
				hpDamageBody += generateDamageHelperBodyEffect(ailmentArray["name"], ailmentArray["effectVal"], ailmentArray["type"], ailmentArray["customRes"], getIcon("ailments", ailmentArray["icon"]), ailmentArray["beforeRes"], hpResistance, resHPIcon);
			}
			if (ailmentArray["effect"] == "StagRes" || ailmentArray["effect"] == "HPStagRes") {
				stDamageBody += generateDamageHelperBodyEffect(ailmentArray["name"], ailmentArray["effectVal"], ailmentArray["type"], ailmentArray["customRes"], getIcon("ailments", ailmentArray["icon"]), ailmentArray["beforeRes"], stResistance, resSTIcon);
			}
			if (ailmentArray["effect"] == "SP") {
				spDamageBody += generateDamageHelperBodyEffect(ailmentArray["name"], ailmentArray["effectVal"], ailmentArray["type"], ailmentArray["customRes"], getIcon("ailments", ailmentArray["icon"]));
			}
		}
	}

	/* Flat damage resistance status ailments and outfit damage resistance effect */
	if (hpProtection != 0) { hpDamageBody += generateDamageHelperBodyEffect(langProtection, hpProtection, "Reduction", 0, getIcon("ailments", "Protection", settingLimbusStyle)); }
	if (stProtection != 0) { stDamageBody += generateDamageHelperBodyEffect(langStProtection, stProtection, "Reduction", 0, getIcon("ailments", "StaggerProtection", settingLimbusStyle)); }
	
	if ((damageResistance != 0) && (Math.abs(sumBothBefore + sumHpBefore)) > 0) { hpDamageBody += generateDamageHelperBodyEffect(langDamageResistance, damageResistance, "Reduction", 0, getIcon("ailments", "DamageResist", settingLimbusStyle)); }
	if ((damageResistance != 0) && (Math.abs(sumBothBefore + sumStBefore)) > 0) { stDamageBody += generateDamageHelperBodyEffect(langDamageResistance, damageResistance, "Reduction", 0, getIcon("ailments", "DamageResist", settingLimbusStyle)); }

	/* Temporary HP and ST */
	if (length(tempHPUsed) > 0) {
		for (const [sourceName, sourceVals] of Object.entries(tempHPUsed)) {
			let effectName = sourceName;
			if (sourceName == "AutoEffects THP") {
				effectName = getTranslationByKeyCustom(`AutoEffects`, "autoeffect-title") + " " + getTranslationByKeyCustom("Temp HP", "bar-health-temp-shorter");
			}
			let countUpdate = `[${parseInt(sourceVals[0] + sourceVals[1])} -> ${sourceVals[0]}]`;
			hpDamageBody += generateDamageHelperBodyEffect(effectName, `${sourceVals[1]} ${countUpdate}`, "TempReduction", 0, sourceVals[2]);
		}
	}
	if (length(tempSTUsed) > 0) {
		for (const [sourceName, sourceVals] of Object.entries(tempSTUsed)) {
			let effectName = sourceName;
			if (sourceName == "AutoEffects TST") {
				effectName = getTranslationByKeyCustom(`AutoEffects`, "autoeffect-title") + " " + getTranslationByKeyCustom("Temp ST", "bar-stagres-temp-shorter");
			}
			let countUpdate = `[${parseInt(sourceVals[0] + sourceVals[1])} -> ${sourceVals[0]}]`;
			stDamageBody += generateDamageHelperBodyEffect(effectName, `${sourceVals[1]} ${countUpdate}`, "TempReduction", 0, sourceVals[2]);
		}
	}

	}

	/* Combine damage calculations into one message*/
	damageCalculation += `<div class="calculationContainer hpCalculationContainer">${hpDamageHead}${hpDamageBody}</div>`;
	damageCalculation += `<div class="calculationContainer stCalculationContainer">${stDamageHead}${stDamageBody}</div>`;
	damageCalculation += `<div class="calculationContainer spCalculationContainer">${spDamageHead}${spDamageBody}</div>`;
	damageCalculation += autoScriptMessage;
	
	/* Damage type icon */
	let damageIcon = "";
	let damageIconStyling = "style='height: 30px; width: 30px; border-right: 2px solid black;' </div>";
	switch (damageType) {
		case "Slash": damageIcon = "<img src='https://raw.githubusercontent.com/beautidemise/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/icons/Slash.png'" + damageIconStyling; break;
		case "Pierce": damageIcon = "<img src='https://raw.githubusercontent.com/beautidemise/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/icons/pierce.png'" + damageIconStyling; break;
		case "Blunt": damageIcon = "<img src='https://raw.githubusercontent.com/beautidemise/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/icons/blunt.png'" + damageIconStyling; break;
		case "None": damageIcon = "<img src='https://raw.githubusercontent.com/beautidemise/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/icons/question.png'" + damageIconStyling; break;
	}

	/* Whisper and roll */
	let whisper = "";
	if(whisperrolls == "true") {
		whisper = "/w " + whispertarget;
	}

	setAttrs({"dummy":damageCalculation, "dummyIcon":damageIcon, "damageHelperType":"None"});

	startRoll((whisper + `&{template:damagecalculation} {{icon=@{dummyIcon}}} {{name=@{character_name}}} {{title=${getTranslationByKeyCustom("Damage Calculation", "heading-damagecalculation")}}} {{damagecalculations=@{dummy} }}`), (results) => {
		finishRoll(results.rollId, {} );

		/* Create action Buttons */
		createChatButtons(chatButtonList);
	});
	/* Damage calculation chat message block end */
	});
	});
	});
	});
	});
}


/* Damage helper functions beginning */
function generateDamageHelperHeader(statName, newStat, oldStat, staggerState="0", autoapplydamage="true", hidebarupdate="false") {
	let langBar = "HP";
	let langDamage = "damage";
	let langSuffered = "received";
	let langSufferedNo = "Received no";
	let langRegened = "Regened";
	let langStaggered = "Regened";
	
	let updateDisplay = "";
	let displayContent = "";

	if(getTranslationByKey("message-damage") != false) {
		langDamage = getTranslationByKey("message-damage");
		langStaggered = getTranslationByKey("ailments-stagger-text");
		switch (statName) {
			case "HP": langBar = getTranslationByKey("bar-health-shortened"); break;
			case "ST": langBar = getTranslationByKey("bar-stagres-shortened"); break;
			case "SP": langBar = getTranslationByKey("bar-sanity-shortened"); break;
		}
	} else {
		langBar = statName;
	}
	if (staggerState == "Staggered") { updateDisplay = `<div class="updateStatDisplay"><b>${langStaggered}!</b></div>`; }
	else if (autoapplydamage != "true" || hidebarupdate == "true") { updateDisplay = `<div class="updateStatDisplay"><b>---</b></div>`; }
	else { updateDisplay = `<div class="updateStatDisplay"><b>${oldStat} -> ${newStat}</b></div>`; }

	if (newStat < oldStat) { langSuffered = getTranslationByKey("message-received");
		return `<div><div class="damageDisplay">${oldStat-newStat} ${langBar} ${langDamage} ${langSuffered}</div>${updateDisplay}</div>`; }
	else if (newStat > oldStat) { langRegened = getTranslationByKey("message-regened-capitalized");
		return `<div><div class="damageDisplay">${langRegened} ${newStat-oldStat} ${langBar}</div>${updateDisplay}</div>`; }
	else { langSufferedNo = getTranslationByKey("message-received-no");
		return `<div><div class="noDamage damageDisplay">${langSufferedNo} ${langBar} ${langDamage}</div>${updateDisplay}</div>` }
}

function generateDamageHelperBodyEffect(effectName, effectVal, effectType, ailmentRes, iconString, resMode = "", resVal = "", resIcon = "") {
	let langDamage = getTranslationByKeyCustom("damage", "message-damage");
	let langDealt = getTranslationByKeyCustom("dealt", "message-dealt");
	let langRegened = getTranslationByKeyCustom("regened", "message-regened");
	let langResist = getTranslationByKeyCustom("Resistance: ", "message-resist");
	let langReducedBaseDamageBy = getTranslationByKeyCustom("reduced base damage by", "message-reduced-basedamage-by");
	
	let langReduction = "";
	if (effectVal < 0) {
		langReduction = getTranslationByKeyCustom("increased damage by", "message-increased-damage-by");
	} else {
		langReduction = getTranslationByKeyCustom("reduced damage by", "message-reduced-damage-by");
	}


	let message = "<div>";
	switch (effectType) {
		case "Damage": message += `${iconString}<div><b>${effectName}</b> ${langDealt} ${Math.abs(effectVal)} ${langDamage}`; break;
		case "Regen": message += `${iconString}<div><b>${effectName}</b> ${langRegened} ${Math.abs(effectVal)} ${langDamage}`; break;
		case "Reduction": message += `${iconString}<div><b>${effectName}</b> ${langReduction} ${Math.abs(effectVal)}`; break;
		case "TempReduction": message += `${iconString}<div><b>${effectName}</b> ${langReduction} ${effectVal}`; break;
		case "Defence": message += `${iconString}<div><b>${effectName}</b> ${langReducedBaseDamageBy} ${Math.abs(effectVal)}`; break;
	}
	if (resMode == "beforeResistance") {
		message += ` x [${resVal}x] ` + getIcon("def", resIcon);
	}
	if (ailmentRes != 0) {
		message += ` ${styleText(` **(${effectName} ${langResist}${ailmentRes})**`, "opacity: 50%;")}`;
	}
	return message + "</div></div>";
}

function applyTempBarDamage(sourceName, sourceVals, targetBar, damage, newBar) {

	if (damage > 0) {
		let tempBarVal = parseInt(sourceVals[0]);
		let messageVal = Math.min(tempBarVal, damage);
		let messageName = sourceVals[2];
		let messageIcon = getIcon(sourceVals[3], sourceVals[4]);

		if (tempBarVal > damage) {
			tempBarVal -= damage;
			newBar += damage;
			damage = 0;
		} else {
			damage -= tempBarVal;
			newBar += tempBarVal;
			tempBarVal = 0;
		}

		if (sourceVals[1] != "None") {
			let newCount = Math.ceil(tempBarVal/sourceVals[1]);
			setAttrs({[sourceName]:newCount, [`${sourceName.replace("ailnum","ailTempBarOverride")}`]:tempBarVal});
		}
		return { tempBarVal:tempBarVal, newBar:newBar, damage:damage, messageName:messageName, messageVal:messageVal, messageIcon:messageIcon};
	}
}
/* Damage helper functions end */



/* Temporary HP and ST */
function applyTempBarDamageAilment(tempBar_Sources, target, damage, newBar) {

	let tempBarUsed = {};
	let returnTempBar = {};
	if (length(tempBar_Sources) > 0) {
		for (const sourceName in tempBar_Sources) {
			if (damage > 0) {
				returnTempBar = applyTempBarDamage(sourceName, tempBar_Sources[sourceName], target, damage, newBar);
				if (returnTempBar != undefined) {
					if (returnTempBar.tempBarVal == 0) {
						delete tempBar_Sources[sourceName];
					} else {
						tempBar_Sources[sourceName][0] = returnTempBar.tempBarVal;
					}
					newBar = returnTempBar.newBar;
					damage = returnTempBar.damage;
					tempBarUsed[returnTempBar.messageName] = [returnTempBar.tempBarVal, returnTempBar.messageVal, returnTempBar.messageIcon]
				}
			}
		}
		setAttrs({[`${target}_Sources`]:JSON.stringify(tempBar_Sources)});
	}
	if (returnTempBar.tempBarVal != undefined) {
		return { tempBarVal:returnTempBar.tempBarVal, newBar:newBar, damage:damage, [`${target}Used`]:tempBarUsed }
	}
}

on('change:repeating_ailments:ailNum', (info) => {

	let ailPrefix = info.sourceAttribute.replace("ailnum","");

	getAttrs([`${ailPrefix}ailNum`, `${ailPrefix}ailEffect`, `${ailPrefix}ailName`, `${ailPrefix}ailEffectVal`, `${ailPrefix}ailEffectMode`,
		`${ailPrefix}ailIcon`, `${ailPrefix}ailTempBarOverride`, "THP_Sources", "TST_Sources"], function(values) {

		let ailNum = values[`${ailPrefix}ailNum`];
		let ailTarget = values[`${ailPrefix}ailEffect`];
		let ailName = values[`${ailPrefix}ailName`];
		let ailEffectVal = Math.abs(parseFloat(values[`${ailPrefix}ailEffectVal`].replaceAll("n", "")));
		let ailEffectMode = values[`${ailPrefix}ailEffectMode`];
		let ailIcon = values[`${ailPrefix}ailIcon`];
		let ailTempBarOverride = values[`${ailPrefix}ailTempBarOverride`];
		let tempBarVal = 0;

		if (ailTarget == "THP" || ailTarget == "TST") {
			/* Calculate temp bar value */
			if(ailEffectMode == "+") {
				tempBarVal = parseInt(ailNum) * parseFloat(ailEffectVal);
			}
			else if(ailEffectMode == "=" && ailNum != 0) {
				tempBarVal = parseFloat(ailEffectVal);
				ailEffectVal = "None";
			} else {
				ailEffectVal = 0;
			}

			/* If a temp bar override value exists for the ailment, use that value instead */
			if (parseInt(ailTempBarOverride) > 0 && (info.newValue != undefined || (info.newValue == undefined && info.previousValue == undefined))) {
				tempBarVal = parseInt(ailTempBarOverride);
			}

			/* Update the temp source for the correct bar */
			let output = {}
			updateTempBar(values, ailTarget, info.sourceAttribute, tempBarVal, ailEffectVal, ailName, "ailments", ailIcon, false, output);
			setAttrs({...output, [`${ailPrefix}ailTempBarOverride`]:"0"});
		}
	});
})

function updateTempBar(values={}, target, name, tempBarVal, tempNum, effectName, iconFolder, iconName, stack, returnOutput={}) {

	let tempSource = values[`${target}_Sources`] || "";
	if (typeof values[`${target}_Sources`] == "string" && values[`${target}_Sources`] != "") {
		tempSource = JSON.parse(values[`${target}_Sources`]);
	}

		if (!(tempNum == 0 || tempBarVal == 0 || (isNaN(tempNum) && tempNum != "None"))) {
		if (tempSource[`${name}`] && stack) {
			tempSource[`${name}`] = [Math.max(tempSource[`${name}`][0] + tempBarVal, 0), tempNum, effectName, iconFolder, iconName];
			} else {
				tempSource[`${name}`] = [tempBarVal, tempNum, effectName, iconFolder, iconName];
			}
		} else {
			delete tempSource[`${name}`];
		}

	let output = {[`${target}_Sources`]: JSON.stringify(tempSource)}
	if (length(returnOutput) > 0) Object.assign(returnOutput, output);
	else setAttrs(output);
	return (tempSource[`${name}`]) ? tempSource[`${name}`][0] : 0;
}


/* Update: Tool uses */
on('change:tool1Reusable change:tool2Reusable change:tool3Reusable change:tool4Reusable', () => {

    getAttrs(["tool1Reusable", "tool1Uses", "tool1Uses_max", "tool2Reusable", "tool2Uses", "tool2Uses_max", "tool3Reusable", "tool3Uses", "tool3Uses_max", "tool4Reusable", "tool4Uses", "tool4Uses_max"], function(values) {
	output = {};	

	if(values.tool1Reusable != "Reusable"){
	output["tool1Uses"] = "1";
	}
	else if(values.tool1Reusable == "Reusable" && parseInt(values.tool1Uses) <= 1){
	output["tool1Uses"] = values.tool1Uses_max;
	}

	if(values.tool2Reusable != "Reusable"){
	output["tool2Uses"] = "1";
	}
	else if(values.tool2Reusable == "Reusable" && parseInt(values.tool2Uses) <= 1){
	output["tool2Uses"] = values.tool2Uses_max;
	}

	if(values.tool3Reusable != "Reusable"){
	output["tool3Uses"] = "1";
	}
	else if(values.tool3Reusable == "Reusable" && parseInt(values.tool3Uses) <= 1){
	output["tool3Uses"] = values.tool3Uses_max;
	}

	if(values.tool4Reusable != "Reusable"){
	output["tool4Uses"] = "1";
	}
	else if(values.tool4Reusable == "Reusable" && parseInt(values.tool4Uses) <= 1){
	output["tool4Uses"] = values.tool4Uses_max;
	}

	setAttrs(output);

	});
});

/* Action: Declare action */
on('clicked:declareAction', (info) => {

	let headercolor = "#888";
	let newicon = "/";
	let headertext = "#fff";

	let basetype = "Action";
	headercolor = "#8e7cc3";
	newicon = "/";

	/* Get skillSelect and toolSelect first as they're used to gather further values */
	getAttrs(["skillSelect", "toolselect"], function(values) {
		let skillselect = values.skillSelect;
		let toolselect = values.toolselect;

	/* Get attributes */
    getAttrs(["actionType", "settingSimpleDisplay", "settingHideBaseEffect", "settingWhisperRolls", "settingWhisperTarget", "targetName", "targetTokenId", "character_name", "Light", "skillSelect", "selectName", "selectLight", "selectType", "selectDice1", "selectDice2", "selectDice3", "selectEffect", "selectDescription", "distortState", "tool1Name", "tool1Reusable", "tool1Uses", "tool1Uses_max", "tool1Effect", "tool1Description", "tool2Name", "tool2Reusable", "tool2Uses", "tool2Uses_max", "tool2Effect", "tool2Description", "tool3Name", "tool3Reusable", "tool3Uses", "tool3Uses_max", "tool3Effect", "tool3Description", "tool4Name", "tool4Reusable", "tool4Uses", "tool4Uses_max", "tool4Effect", "tool4Description", "special1Name","special1Description",  "special1Range", "special1Duration", "special1Risk", "special2Name", "special2Description", "special2Range", "special2Duration", "special2Risk", "egoName", "egoType", "egoDescription", "egoUses", "egoUses_max", "egoUseType", "egoEffect", "egoRisk", "egoRange", "egoDuration", "settingHideUses", `${toolselect}AutoScript`, `${skillselect}AutoScript`, "Bleed"], function(values) {

	let charname = values.character_name;
	let targetname = values.targetName || "";
	let targettokenid = values.targetTokenId || "";
	let simpledisplay = values.settingSimpleDisplay;
	let hidebaseffect = values.settingHideBaseEffect;
	let whisperrolls = values.settingWhisperRolls;
	let whispertarget = values.settingWhisperTarget;
	let distortstate = values.distortState;
	let hideuse = values.settingHideUses;

	let actiontype = values.actionType;
	let actiontext = "";
	let currentlight = parseInt(values.Light);
	let newlight = parseInt(values.Light);

	let output = {};

	if(distortstate == "true"){
	headertext = "#8e7cc3";
	headercolor = "#000";

	}

	/* Type Formatting */
	if(actiontype == "tool"){
	newicon = "https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/icons/Portable.png";
	actiontext = "Use Tool";
	}
	else if(actiontype == "move"){
	newicon = "https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/icons/Speed.png";
	actiontext = "Move";
	}
	else if(actiontype == "protect"){
	newicon = "https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/icons/defend.png";
	actiontext = "Protect";

	}
	else if(actiontype == "other"){
	newicon = "https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/icons/question.png";
	actiontext = "Other";
	}

	if(toolselect == "egoTool"){
	newicon = "https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/icons/egoAct.png";
	headertext = "#8e7cc3";
	headercolor = "#000";
	}
	else if(toolselect == "egoSpecial"){
	newicon = "https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/icons/egoSpecial.png";	
	headertext = "#cf8c44";
	headercolor = "#000";
	}
	else if(toolselect == "special1" || toolselect == "special2"){
	newicon = "https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/icons/specialwhite.png";
	}

	/* Tool info */
	let toolname = "";
	let toolreuse = "0";
	let tooluses = "1";
	let toolusesmax = "1";
	let newuses = "0";
	let toolusestext = "";
	let tooldesc = "";
	let tooleffect = "";

	let specialriskNum = "0";
	let specialrangeNum = "0";
	let specialdurationNum = "0";

	let toolinfo = "";

	if(toolselect == "egoTool" || toolselect == "egoSpecial"){
	toolname = values.egoName;
	tooldesc = values.egoDescription;
	tooleffect = values.egoEffect;

	tooluses = values.egoUses;
	toolusesmax = values.egoUses_max;
	toolreuse = values.egoUseType;

		if(toolreuse != "Limitless" && toolreuse != null){
		toolusestext = " (" + tooluses + "/" + toolusesmax + ")";

		newuses = parseInt(tooluses) - 1;
			if(parseInt(newuses) < 0){ 
			newuses = "0";
			}

		output["egoUses"] = newuses;
		}

		if(toolselect == "egoSpecial"){
		specialriskNum = values.egoRisk;
		specialrangeNum = values.egoRange;
		specialdurationNum = values.egoDuration; 
		}

	}
	else if(toolselect == "special1" || toolselect == "special2"){
	toolname = values[`${toolselect}Name`];
	tooldesc = values[`${toolselect}Description`];

	specialriskNum = values[`${toolselect}Risk`];
	specialrangeNum = values[`${toolselect}Range`];
	specialdurationNum = values[`${toolselect}Duration`]; 

	}
	else if(toolselect == "" || toolselect == null){
	toolselect = "";
	}
	else {
	toolname = values[`${toolselect}Name`];
	tooldesc = values[`${toolselect}Description`];
	tooleffect = values[`${toolselect}Effect`];
	tooluses = values[`${toolselect}Uses`];
	toolusesmax = values[`${toolselect}Uses_max`];
	toolreuse = values[`${toolselect}Reusable`];

		if(toolreuse == "Reusable"){
		toolusestext = " (" + tooluses + "/" + toolusesmax + ")";

		newuses = parseInt(tooluses) - 1;
			if(parseInt(newuses) < 0){ 
			newuses = "0";
			}

		output[`${toolselect}Uses`] = newuses;
		}
		else {
		toolusestext = " (1/1)";
		output[`${toolselect}Uses`] = "0";
		}


	}

	if(values.settingHideUses == "true"){
	toolusestext = "";
	}

	/* Skill info */
	let skillname = values.selectName;
	let skilltype = values.selectType;
	let skillcost = values.selectLight;
	let skilldesc = values.selectDescription;
	let skilleffect = values.selectEffect;
	let skillinfo = "";
	let lightmessage = "";

	/* Bleed processing */
	let autoScriptOverrideList = {};
	updateBleed("standard", function(returnValues) {
	Object.assign(autoScriptOverrideList, returnValues.overrideList);
	output = {...output, ...returnValues.output};

	/* Custom Ailments processing */
	updateCustomAilments(["OnAction"], "standard", "false", function(returnValues) {
	Object.assign(autoScriptOverrideList, returnValues.overrideList);
	output = {...output, ...returnValues.output};

	/* AutoScripts */
	let AutoScript = "";

	/* Get tool AutoAcript if any */
	if (toolselect != "0") {
		AutoScript += "(Reset)" + values[`${toolselect}AutoScript`];
	}

	/* Get skill AutoAcript if any */
	if (skillselect && skillselect != "0" && skilltype == "Action") {
		AutoScript += "(Reset)" + values[`${skillselect}AutoScript`];
	}

	/* Clean AutoScript. Remove nested and undefined */
	if (AutoScript != "") {
		AutoScript = AutoScript.replaceAll(/\[([#][^]+?[#])\]/g, "");
		AutoScript = AutoScript.replaceAll("undefined", "");
	}

	resetConditionals();
	AutoScriptMain(AutoScript, "None", "true", "false", autoScriptOverrideList, function(returnValues) {

	let autoEffectLight = parseInt(returnValues.Light) || 0;
	let autoScriptMessage = returnValues.message || "";
	let chatButtonList = returnValues.buttonList || {}

	/* Translation prep */
	let langFrom = "From";
	let langTarget = "Target"
	let langUse = "Use Tool";
	let langSkill = "Skill";
	let langDesc = "Description";
	let langEffect = "Effect";

	let langRisk = "Risk";
	let langRange = "Range";
	let langDuration = "Duration";


	if(getTranslationByKey("message-from") != false){

	actiontext = getTranslationByKey("palette-action-" + actiontype);

	langFrom = getTranslationByKey("message-from");
	langTarget = getTranslationByKey("message-target");
	langUse = getTranslationByKey("palette-action-tool");
	langSkill = getTranslationByKey("message-skill");
	langDesc = getTranslationByKey("message-desc");
	langEffect = getTranslationByKey("message-effect");

	langRisk = getTranslationByKey("special-risk-text");
	langRange = getTranslationByKey("special-range-text");
	langDuration = getTranslationByKey("special-duration-text");

	specialrisk = getTranslationByKey("special-risk-" + specialriskNum);
	specialrange = getTranslationByKey("special-range-" + specialrangeNum);
	specialduration = getTranslationByKey("special-duration-" + specialdurationNum);

	}

	if(toolselect == "special1" || toolselect == "special2"){
	tooleffect = tooldesc;
	tooldesc = "<b>Risk</b>: " + specialrisk + "<br><b>Range</b>: " + specialrange + "<br><b>Duration</b>: " + specialduration;
	}
	else if(toolselect == "egoSpecial"){
	tooldesc = "<b>Risk</b>: " + specialrisk + "<br><b>Range</b>: " + specialrange + "<br><b>Duration</b>: " + specialduration + "<br>" + tooldesc;

	}

	let toolDescription = "<div style='text-align: center; padding-top: 3px; padding-bottom: 3px;'><div style='text-align: left; padding: 5px;'>" + tooldesc + "</div></div>";
	let toolEffectDescription = "<div class='toolEffect' style='max-height: 60px; width: 96.5%; border: 1px #555 solid; overflow: auto; float: left; padding: 3px;'>" + tooleffect + "</div>";
	if (tooldesc == "") { toolDescription = ""; }
	if (tooleffect == "") { toolEffectDescription = ""; toolDescription = toolDescription.replaceAll(" padding-bottom: 3px;","").replaceAll(" padding: 5px;"," padding-top: 5px;"); }

	if(toolselect != "" && toolselect != null && toolselect != "0") {
		toolinfo = "<b>" + langUse + "</b>: " +  toolname + toolusestext + "<br>" + toolDescription + toolEffectDescription;
	}

	if(currentlight >= skillcost && skilltype == "Action") {
		newlight = currentlight - skillcost;
		lightmessage = " <span style='color: #fee2b0'>(" + langSkill + ")</span>";

		skillinfo= "<b>" + langSkill + ": </b>" + skillname;
		let skillDescription = "<br><div class='descriptionContainer'><b>" + langDesc + ":</b><br><div class='effectDescription'>" + skilldesc + "</div></div>";
		let skillEffectDescription = "<div class='descriptionContainer'><b>" + langEffect + ":</b><br><div class='effectDescription''>" + skilleffect + "</div></div>";

		if (skilldesc == "") { skillDescription = ""; }
		if (skilleffect == "") { skillEffectDescription = ""; }
		skillinfo = skillinfo + skillDescription + skillEffectDescription;
	}

	if (hidebaseffect == "true") { skillinfo= "<b>" + langSkill + ": </b>" + skillname; toolinfo = "<b>" + langUse + "</b>: " +  toolname + toolusestext + "<br>"; }

	let info = "<div style='background-color: #222; overflow: hidden; height: 30px; border: 2px #000 solid; color: " + headertext + ";'><div style='float: left'><img src='" + newicon + "' style='width: 30px; height: 30px; border-right: 2px #000 solid; margin-right: 5px; background-color:" + headercolor + "'></div><div style='width: 80%; overflow: hidden; height: 20px; padding-top: 5px; float: left;'><b>" + actiontext + lightmessage + "</b></div></div><b>" + langFrom + ": </b> " + charname + "<br>";
	if (targetname != "") { info += "<b>" + langTarget + ": </b>"+ targetname + "<br>"; }
	info += toolinfo + skillinfo + autoScriptMessage;

	setAttrs({"dummy":info});

	let whisper = "";
	if(whisperrolls == "true"){
	whisper = "/w " + whispertarget;
	}

	/*--- send roll end --*/
	startRoll((whisper + "&{template:baseRoll} {{infodump=@{dummy} }}"), (results) => {
        finishRoll(results.rollId,{});

		/* Create action Buttons */
		createChatButtons(chatButtonList);
    });
	/*--- send roll end ---*/

	output = {...output,
		"skillSelect": "",
		"toolSelect": "",
		"Light": newlight + autoEffectLight,
		"lastDefenceRoll": 0
	}

	setAttrs(output);

	});
	});
	});
	});
	});
});

/* Clicked: Resource display buttons */
on("clicked:expandResourceTrackers clicked:editResourceTrackers", function(info) {
	getAttrs(["expandResourceToggle", "editResourceToggle", "actionType",
	"Action", "Action_base", "Action_max", "Reaction", "Reaction_base", "Reaction_max", "Light_Regen", "Light_Regen_base", "Light_Regen_max",
	"Counter", "Counter_base", "Counter_max", "Block", "Block_base", "Block_max", "Evade", "Evade_base", "Evade_max"], function(values) {
		let button = info.triggerName.includes("edit") ? "edit" : "expand";
		let toggleAttr = button + "ResourceToggle";
		
		let output = {[toggleAttr]: values[toggleAttr] == "true" ? "0" : "true"}

		let [action, actionBase, actionMax] = [parseInt(values.Action), parseInt(values.Action_base), parseInt(values.Action_max)];
		let [reaction, reactionBase, reactionMax] = [parseInt(values.Reaction), parseInt(values.Reaction_base), parseInt(values.Reaction_max)];
		let [lightRegen, lightRegenBase, lightRegenMax] = [parseInt(values.Light_Regen), parseInt(values.Light_Regen_base), parseInt(values.Light_Regen_max)];
		let [counter, counterBase, counterMax] = [parseInt(values.Counter), parseInt(values.Counter_base), parseInt(values.Counter_max)];
		let [block, blockBase, blockMax] = [parseInt(values.Block), parseInt(values.Block_base), parseInt(values.Block_max)];
		let [evade, evadeBase, evadeMax] = [parseInt(values.Evade), parseInt(values.Evade_base), parseInt(values.Evade_max)];

		if (button == "expand") {
			if (output[toggleAttr] == "true") {
				output = {...output,
					"Reaction": Math.max(reaction - counter - block - evade, 0),
					"Reaction_max": Math.max(reactionMax - counterMax - blockMax - evadeMax, 0)
				}
			} else {
				output = {...output,
					"Reaction": Math.max(reaction + counter + block + evade, 0),
					"Reaction_max": Math.max(reactionMax + counterMax + blockMax + evadeMax, 0)
				}
				if (!["Action", "Reaction"].includes(values.actionType)) {
					output = {...output, "actionType": "Reaction"}
				}
			}
		} else if (button == "edit") {
			if (output[toggleAttr] != "true") {
				output = {...output,
					"Action": Math.max(Math.min(action, actionBase), 0), "Action_max": Math.max(actionBase, 0),
					"Reaction": Math.max(Math.min(reaction, reactionBase), 0), "Reaction_max": Math.max(reactionBase, 0),
					"Light_Regen": Math.max(Math.min(lightRegen, lightRegenBase), 0), "Light_Regen_max": Math.max(lightRegenBase, 0),
					"Counter": Math.max(Math.min(counter, counterBase), 0), "Counter_max": Math.max(counterBase, 0),
					"Block": Math.max(Math.min(block, blockBase), 0), "Block_max": Math.max(blockBase, 0),
					"Evade": Math.max(Math.min(evade, evadeBase), 0), "Evade_max": Math.max(evadeBase, 0)
				}
			}
		}
		setAttrs(output);
	});
});


/* Share: Outfit */
on("clicked:shareOutfit", function() {
	getAttrs(["outfitImmune1", "outfitImmune2", "outfitImmune3", "outfitImmune4", "outfitImmune5", "outfitImmune6", "outfitName", "outfitRank", "outfitEffect", "outfitDescription", "defDice1", "defDice2", "defDice3", "evdDice1", "evdDice2", "evdDice3", "settingWhisperRolls", "settingWhisperTarget"], function(values) {

	let name = values.outfitName;
	let rank = values.outfitRank;
	let desc = values.outfitDescription;
	let effect = values.outfitEffect;
	let diceD = values.defDice1 + "d" + values.defDice2 + "+" + values.defDice3;
	let diceE = values.evdDice1 + "d" + values.evdDice2 + "+" + values.evdDice3;


	let iconSlash = "<img src='https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/def/ResSlash.png' style='width: 25px; height: 25px;'>";
	let iconSlashSTG = "<img src='https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/def/ResSlashStg.png' style='width: 25px; height: 25px;'>";

	let iconPierce = "<img src='https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/def/ResPierce.png' style='width: 25px; height: 25px;'>";
	let iconPierceSTG = "<img src='https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/def/ResPierceStg.png' style='width: 25px; height: 25px;'>";

	let iconBlunt = "<img src='https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/def/ResBlunt.png' style='width: 25px; height: 25px;'>";
	let iconBluntSTG = "<img src='https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/def/ResBluntStg.png' style='width: 25px; height: 25px;'>";

	let immune = 
	"<div style='height:15px;'><div style='width: 70px; color: #c25944; float: left'>" + iconSlash + " x" + values.outfitImmune1 + "</div> <div style='width: 70px; color: #dbb748; float: left;'>" + iconSlashSTG + " x" + values.outfitImmune2 + "</div></div><br>" + 
	"<div style='height:15px;'><div style='width: 70px; color: #c25944; float: left'>" + iconPierce + " x" + values.outfitImmune3 + "</div> <div style='width: 70px; color: #dbb748; float: left;'>" + iconPierceSTG + " x" + values.outfitImmune4 + "</div></div><br>" +
	"<div style='height:15px;'><div style='width: 70px; color: #c25944; float: left'>" + iconBlunt + " x" + values.outfitImmune5 + "</div> <div style='width: 70px; color: #dbb748; float: left;'>" + iconBluntSTG + " x" + values.outfitImmune6 + "</div></div>";


	/* Translation prep */
	let langRank = getTranslationByKeyCustom("Rank", "rank");
	let langDef = getTranslationByKeyCustom("Def", "message-defend");
	let langEvd = getTranslationByKeyCustom("Evd", "message-evade");

	let iconnew = "<img src='https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/icons/defend.png' style='width: 30px; height: 30px;' >";

	header = "<div style='background-color: #7397d1; overflow: hidden; height: 30px;'><div style='float: left'>" + iconnew + "</div><div style='width: 55%; overflow: hidden; height: 20px; padding-top: 5px; float: left;'><b>" + name + "</b></div><div style='position: absolute; top: 5px; right: 5px;'> <b>" + langRank + ": </b>" + rank + "</div></div>";

	body = "<div style='text-align: center; padding-top: 3px; padding-bottom: 3px; border-bottom: 1px #555 solid;'><b>" + langDef + ": </b>" + diceD + " | <b>" + langEvd + ": </b>" + diceE + "</div><div style='width: 100%; height: 70px; overflow: hidden;'><div style='height: 70px; width: 49%; border-right: 1px #555 solid; overflow: auto; float: left;'>" + effect + "</div><div style='height: 70px; width: 49%; overflow: auto; float: left;'>" + immune + "</div></div><div style='height: 60px; width: 98%; border-top: 1px #555 solid; overflow: auto; float: left; padding: 3px;'>" + desc + "</div>";

	setAttrs({"dummy":header, "dummy2":body});

	let whisperrolls = values.settingWhisperRolls;
	let whispertarget = values.settingWhisperTarget;
	let whisper = "";
	if(whisperrolls == "true"){
		whisper = "/w " + whispertarget;
	}

	/* Send */
	startRoll((whisper + "&{template:shareB} {{header=@{dummy}}} {{body=@{dummy2}}}"), (results) => {
		finishRoll(results.rollId, {} );
	});
    });
});


on("clicked:testButton", function(values) {
	/*executeRolls([], (returnValues) => {
		console.log(" --- Finished test --- ")
		console.log("returnValues: ", returnValues)
	});*/

	let msgId = generateRowID();
	let msgNr = 0;
	
	changeIframe("app.roll20.net/editor/", "#sheet-testTab1", "charsheet", msgId, msgNr++);
	changeIframe("app.roll20.net/editor/", "#sheet-testTab2", "charsheet", msgId, msgNr++);
	//changeIframe("https://www.youtube.com/embed/dQw4w9WgXcQ?si=eSYcqdXVCkheSQGk", "", "charsheet");
});

function changeIframe(baseUrl="app.roll20.net/editor/", fragment="#", htmlAttr='" class="', id, nr) {
	getAttrs(["character_id", "campaign_id", "settingWhisperRolls", "settingWhisperTarget"], function(values) {
	let charId = values.character_id;
	let campId = values.campaign_id || "17431492";

	/* If the url or htmlAttr is "charsheet" the iframe of the character sheet should modified */
	if (baseUrl == "charsheet") {
		baseUrl = baseUrl.replace("charsheet", `app.roll20.net/editor/character/${campId}/${charId}/true?popout=false`);
	}
	if (htmlAttr == "charsheet") {
		htmlAttr = htmlAttr.replace("charsheet", `" target="iframe_${charId}" class="`);
	}

	/* Urls must begin with //// and not https:// to function correctly */
	if (baseUrl.startsWith("https://")) {
		baseUrl = baseUrl.replace("https://","");
	}
	if (!baseUrl.startsWith("////")) {
		baseUrl = "////" + baseUrl;
	}

	/* See https://developer.mozilla.org/en-US/docs/Web/URI/Fragment/Text_fragments for more details */
	
	/*
	let id1 = generateRowID();
	let id2 = generateRowID();

	let temp = `
	<h3>Table of Contents</h3>
	<ol>
	  <li><a href="#sheet${id1}">Jump to the first paragraph!</a></li>
	  <li><a href="#sheet${id2}">Jump to the second paragraph!</a></li>
	  <li><a href="////docs.google.com/document/d/1ok4-2vBbgH9jyBw05kGwsl0F96qrck4vmU9PO5kvoWU">Roll20 Sheet Guide</a></li>
	  <li>[Jump to the second paragraph](////app.roll20.net/editor/#initiativewindow"> 
	  <li>
		<a href="#sheet-nowhere">
		  This link goes nowhere, because the target doesn't exist.
		</a>
	  </li>
	</ol>

	<h3>My Fun Article</h3>
	<p id="sheet${id1}">
	  You can target <i>this paragraph</i> using a URL fragment. Click on the link
	  above to try out!
	</p>
	<p id="sheet${id2}">
	  This is <i>another paragraph</i>, also accessible from the links above. Isn't
	  that delightful?
	</p>
	<p id="sheet-autoScriptStyling">
		This is <i>another paragraph</i>, also accessible from the links above. Isn't
		that delightful?
	</p>`
	*/

	//setAttrs({"dummy":header, "dummy2":body});

	let whisperrolls = values.settingWhisperRolls;
	let whispertarget = values.settingWhisperTarget;
	let whisper = "";
	if(whisperrolls == "true"){
		whisper = "/w " + whispertarget;
	}

	// Make this into your char id. Now the sorting can be reused for all of your messages
	id = "-abcd"
	
	let frag = fragment.replace("#sheet-","");
	fragment = "#:~:text=" + frag;
	let test = `<div class="sheet-compact" id="sheet-${frag}">${frag}</div>`;
	
	htmlAttr =  `"><input type="radio" name="${id}testRadio" class="${nr == 0 ? "head" : "append"}" msg-id="${id}" none="`;

	htmlScript = `"><style none="`;
	htmlScriptend = `">
	/* Ordering CSS */
	@scope (#textchat .content) {
		:scope {
			display: flex;
			flex-direction: column;
			--order-high: 0; --order-mid: 0; --order-low: 0; --order-shift: 0;
			--append: 0;
		}
		
		:is(.news, .system, .hidden-message) { order: -1 !important; }

		.message {
			order: calc(var(--order-high)*100 + var(--order-mid)*10 + var(--order-low) + var(--order-shift));
			
			${range(1, 10).reduce((acc, i) => { // Low ordering (1s). Generated 10 selectors for 10n+i = i
				return acc + `&:nth-child(10n+${i}) {--order-low: ${i};}\n`
			}, "")}

			${range(1, 10).map(i => { // Mid ordering (10s). Generated 100 selectors for 100n+ij = i
				return range(0, 10).reduce((acc, j) => {
					return acc + `&:nth-child(100n+${i}${j})${(j < 9) ? ", " : ""}`
				}, "") + ` {--order-mid: ${i};}`
			}).join("\n")}

			${range(1, 10).reduce((acc, i) => { // High ordering (100s). Generated 10 selectors for n+i00-i99 = i
				return acc + `&:nth-child(n+${i}00):nth-child(-n+${i}99) {--order-high: ${i};}\n`
			}, "")}
		}
	}

	/* Sorting CSS */
	.message {
		border: calc(2px*var(--append)) solid red;
		&:has(.head) {
			background-color: cyan !important;
		}

		input[type="radio"]:checked {
			background-color: blue !important;
			width: 20px;
			height: 20px;
		}
		
		&:has([msg-id="${id}"]:is(.head, .append)) + &:has([msg-id="${id}"].append) {
			background-color: purple !important;
			--append: 1;
		}
		/* Make the system work when a character posts two heads in a row, then appends messages to both of them */
		/*  Could maybe add an extra id after the main id which is just used for the last sorting rule below */
		/*  If you add this, change the main id checks to match the beginning of the attribute */
		/* Also consider explanding the code to the next 15 or 20 messages, or maybe make this customizable through a confix setting? */
		&:has([msg-id="${id}"]:is(.head, .append)) + &:not(:has([msg-id="${id}"])) {
			${range(1, 10).reduce((acc, i) => { // Shifts forwards any .append messages amongst the next 10 messages. Marks them as appended
				return acc + `& +${` :not(:has([msg-id="${id}"].head)) +`.repeat(i-1)} .message:has([msg-id="${id}"].append) {--order-shift: -${i+1}; --append: 1;}\n`
			}, "")}
		}
	}
	</style none="`;

	// Generate the last styling rules using a loop. The current ones are just for testing
	//  For the sorting CSS, generate the main selector, & + and :has(...), and add N "* + " in the middle

	// Ordering:
	// Elements use four modifiers to set their order: --order-mid, --order-low and and --order-shift
	// The mods have the following values: high = 100, mid = 10 and shift = varies
	// New messages begin with a total value of 490, which decreases by 10 for every following message
	// Chains of related messages gain 1 value per message
	// To move an element N spaces backwards, decrease it's value by 10*N + 1
	// This code only sorts the last 40 messages

	let template = `&{template:testFeature} {{test=@{dummy}}} {{insert=[[0]]}}`;
	if (nr == 0) {
		template += ` {{buttonLabel=?!?!?!?}} {{baseUrl=${baseUrl}}} {{fragment=${fragment}}} {{script=[[0]]}} {{scriptend=[[0]]}}`;
	}

	setAttrs({"dummy":test});

	/* Send */
	startRoll((whisper + " " + template), (results) => {
		console.log(results)
		finishRoll(results.rollId, {insert: htmlAttr, script: htmlScript, scriptend: htmlScriptend} );
	});
	});
}


/* Share: Augment */
on("clicked:shareAugment", function() {
 getAttrs(["settingWhisperRolls", "settingWhisperTarget", "augmentName", "augmentType", "augmentDescription", "augmentEffect", "augmentRank"], function(values) {

	let headTag = "<div style='background-color: #85a874; overflow: hidden; height: 30px;'>";
	let iconnew = "<img src='/' style='width: 5px; height: 30px; opacity: 0%;'>";

	let augmentname = values.augmentName;
	let augmentdesc = values.augmentDescription;
	let augmenteffect = values.augmentEffect;
	let augmentrank = values.augmentRank;
	let augmenttype = values.augmentType;

	/* Translation prep */
	let langRank = "Rank";
	let langType = "Type";
	
	if(getTranslationByKey("rank") != false){

	langRank = getTranslationByKey("rank");
	langType = getTranslationByKey("message-type");

	augmenttype = getTranslationByKey("augment-type-" + augmenttype);

	}

	if(augmenttype == "FullProsthesis"){
	augmenttype = "Full Prosthesis";
	}
	else if(augmenttype == "Drugs"){
	augmenttype = "Drugs/Serums";
	}

	header = "<div style='background-color: #85a874; overflow: hidden; height: 30px;'><div style='float: left'><img src='/' style='width: 5px; height: 30px; opacity: 0%;'></div><div style='width: 55%; overflow: hidden; height: 20px; padding-top: 5px; float: left;'><b>" + augmentname + "</b></div><div style='position: absolute; top: 5px; right: 5px;'> <b>" + langRank + ": </b>" + augmentrank + "</div></div>";

	body = "<div style='text-align: center; padding-top: 3px; padding-bottom: 3px; border-bottom: 1px #555 solid;'><b>" + langType + ": </b>" + augmenttype + "</div><div style='width: 100%; height: 70px; overflow: hidden;'><div style='height: 70px; width: 49%; border-right: 1px #555 solid; overflow: auto; float: left;'>" + augmentdesc + "</div><div style='height: 70px; width: 49%; overflow: auto; float: left;'>" + augmenteffect + "</div></div>";

	setAttrs({"dummy":header, "dummy2":body});

	let whisperrolls = values.settingWhisperRolls;
	let whispertarget = values.settingWhisperTarget;
	let whisper = "";
	if(whisperrolls == "true"){
	whisper = "/w " + whispertarget;
	}

	/* Send */
	startRoll((whisper + "&{template:shareB} {{header=@{dummy} }} {{body=@{dummy2} }}"), (results) => {

            finishRoll(results.rollId, {} );
        });

    });

});

/*-- Share: Tools --*/
on("clicked:shareTool", function(info) {

	/* Get IDs/names */
        let buttonid = info.htmlAttributes.id.split('_')[1];

	let name = buttonid + "Name";
	let type = buttonid + "Type";
	let rank = buttonid + "Rank";
	let effect = buttonid + "Effect";
	let desc = buttonid + "Description";

	let portable = buttonid + "Portable";
	let reusable = buttonid + "Reusable";
	let uses = buttonid + "Uses";

	let header = "";
	let body = "";

	/* Get attributes */
        getAttrs([`${name}`, `${type}`, `${rank}`, `${effect}`, `${desc}`, `${portable}`, `${reusable}`, `${uses}`, "settingWhisperRolls", "settingWhisperTarget"], function(values) {

	let toolname = values[name];
	let toolrank = values[rank];
	let tooltype = values[type];
	let tooleffect = values[effect];
	let tooldesc = values[desc];
	let toolportable = values[portable];
	let toolreusable = values[reusable];
	let tooluses = values[uses];
	let toolinfo = "";

	/* Translation prep */
	let langRank = "Rank";
	let langPortable = "Portable";
	let langPortableNo = "Not portable";

	let langReusable = "Reusable";
	let langReusableNo = "Not reusable";

	
	if(getTranslationByKey("rank") != false){

	langRank = getTranslationByKey("rank");

	langPortable = getTranslationByKey("tool-portable");
	langPortableNo = getTranslationByKey("tool-portableNo");

	langReusable = getTranslationByKey("tool-reusable");
	langReusableNo = getTranslationByKey("tool-reusableNo");

	}

	/* Formatting */

	if(toolportable != "Portable"){
	toolportable = langPortableNo;
	}
	else { toolportable = "<b>" + langPortable + "</b>"; }
	
	if(toolreusable != "Reusable") {
	toolreusable = langReusableNo;
	}
	else{ toolreusable = "<b>" + langReusable + " (" + tooluses + ")</b>"; }

	if(toolreusable != " " && toolportable != " ") {
	toolinfo = toolportable + " | " + toolreusable; 
	}
	else { toolinfo = toolportable + toolreusable; }

	header = "<div style='background-color: #8e7cc3; overflow: hidden; height: 30px;'><div style='float: left'><img src='/' style='width: 5px; height: 30px; opacity: 0%;'></div><div style='width: 55%; overflow: hidden; height: 20px; padding-top: 5px; float: left;'><b>" + toolname + "</b></div><div style='position: absolute; top: 5px; right: 5px;'> <b>"+ langRank + ": </b>" + toolrank + "</div></div>";

	body = "<div style='text-align: center; padding-top: 3px; padding-bottom: 3px; border-bottom: 1px #555 solid;'>" + toolinfo + "</div><div style='width: 100%; height: 70px; overflow: hidden;'><div style='height: 70px; width: 49%; border-right: 1px #555 solid; overflow: auto; float: left;'>" + tooldesc + "</div><div style='height: 70px; width: 49%; overflow: auto; float: left;'>" + tooleffect + "</div></div>";

	setAttrs({"dummy":header, "dummy2":body});

	let whisperrolls = values.settingWhisperRolls;
	let whispertarget = values.settingWhisperTarget;
	let whisper = "";
	if(whisperrolls == "true"){
	whisper = "/w " + whispertarget;
	}

	/* Send */
	startRoll((whisper + "&{template:shareB} {{header=@{dummy} }} {{body=@{dummy2} }}"), (results) => {

            finishRoll(results.rollId, {} );
        });

    });

});


/*-- Share: Special items --*/
on("clicked:shareSpecial", function(info) {

	/* Get IDs/names */
        let buttonid = info.htmlAttributes.id.split('_')[1];

	let name = buttonid + "Name";
	let rank = buttonid + "Rank";
	let desc = buttonid + "Description";

	let risk = buttonid + "Risk";
	let duration = buttonid + "Duration";
	let range = buttonid + "Range";

	let header = "";
	let body = "";

	/* Get attributes */
        getAttrs([`${name}`, `${rank}`, `${desc}`, `${risk}`, `${range}`, `${duration}`, "settingWhisperRolls", "settingWhisperTarget"], function(values) {

	let specialname = values[name];
	let specialrank = values[rank];
	let specialdesc = values[desc];
	let specialriskNum = values[risk];
	let specialrangeNum = values[range];
	let specialdurationNum = values[duration];

	let specialrisk = "---";
	let specialrange = "---";
	let specialduration = "---";

	/* Formatting */

/* Switching Risk to string */
	switch (specialriskNum) {
		case "0": specialrisk = "Canard"; break;
		case "1": specialrisk = "Urban Myth"; break;
		case "2": specialrisk = "Urban Legend"; break;
		case "3": specialrisk = "Urban Plague"; break;
		case "4": specialrisk = "Urban Nightmare"; break;
		case "5": specialrisk = "Star of the City"; break;
		case "6": specialrisk = "Impuritas Civitatis"; break;
		default: specialrisk = "---";
	}

	/* Switching Range to string */
	switch (specialrangeNum) {
		case "0": specialrange = "One or two people"; break;
		case "1": specialrange = "Street"; break;
		case "2": specialrange = "Neighborhood"; break;
		case "3": specialrange = "Residence Area"; break;
		case "4": specialrange = "Nest"; break;
		case "5": specialrange = "Multiple Nests"; break;
		case "6": specialrange = "City"; break;
		default: specialrange = "---";
	}

	/* Switching Duration to string */
	switch (specialdurationNum) {
		case "0": specialduration = "A moment"; break;
		case "1": specialduration = "Seconds"; break;
		case "2": specialduration = "Minutes"; break;
		case "3": specialduration = "Hours"; break;
		case "4": specialduration = "Days"; break;
		case "5": specialduration = "Weeks"; break;
		case "6": specialduration = "Months"; break;
		default: specialduration = "---";
	}

	/* Translation prep */
	let langRank = "Rank";
	let langRisk = "Risk";
	let langRange = "Range";
	let langDuration = "Duration";
	
	if(getTranslationByKey("rank") != false){

	langRank = getTranslationByKey("rank");

	langRisk = getTranslationByKey("special-risk-text");
	langRange = getTranslationByKey("special-range-text");
	langDuration = getTranslationByKey("special-duration-text");

	specialrisk = getTranslationByKey("special-risk-" + specialriskNum);
	specialrange = getTranslationByKey("special-range-" + specialrangeNum);
	specialduration = getTranslationByKey("special-duration-" + specialdurationNum);

	}

	header = "<div style='background-color: #cf8c44; overflow: hidden; height: 30px;'><div style='float: left'><img src='https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/icons/specialwhite.png' style='width: 30px; height: 30px;'></div><div style='width: 55%; overflow: hidden; height: 20px; padding-top: 5px; float: left;'><b>" + specialname + "</b></div><div style='position: absolute; top: 5px; right: 5px;'> <b>" + langRank + ": </b>" + specialrank + "</div></div>";

	body = "<div style='text-align: center; padding-top: 3px; padding-bottom: 3px; border-bottom: 1px #555 solid;'><div style='text-align: left; padding: 5px;'><b>" + langRisk +": </b>" + specialrisk + "<br> <b>" + langRange + ": </b>" + specialrange + "<br> <b>" + langDuration + ": </b>" + specialduration + "</div></div><div style='height: 60px; width: 98%; border-top: 1px #555 solid; overflow: auto; float: left; padding: 3px;'>" + specialdesc + "</div>";

	setAttrs({"dummy":header, "dummy2":body});

	let whisperrolls = values.settingWhisperRolls;
	let whispertarget = values.settingWhisperTarget;
	let whisper = "";
	if(whisperrolls == "true"){
	whisper = "/w " + whispertarget;
	}

	/* Send */
	startRoll((whisper + "&{template:shareB} {{header=@{dummy} }} {{body=@{dummy2} }}"), (results) => {

            finishRoll(results.rollId, {} );
        });

    });

});

/*-- Share: Weapons --*/
on("clicked:shareWeapon", function(info) {

	/* Get IDs/names */
        let buttonid = info.htmlAttributes.id.split('_')[1];

	let name = buttonid + "Name";
	let type = buttonid + "Type";
	let rank = buttonid + "Rank";
	let effect = buttonid + "Effect";
	let desc = buttonid + "Description";
	let range = buttonid + "Range";

	let diceA = buttonid + "Dice1";
	let diceB = buttonid + "Dice2";
	let diceC = buttonid + "Dice3";

	let header = "";
	let body = "";

	/* Get attributes */
        getAttrs([`${name}`, `${type}`, `${rank}`, `${effect}`, `${desc}`, `${range}`, `${diceA}`, `${diceB}`, `${diceC}`, "settingWhisperRolls", "settingWhisperTarget"], function(values) {

	let weaponname = values[name];
	let weaponrank = values[rank];
	let weapontype = values[type];
	let weaponeffect = values[effect];
	let weapondesc = values[desc];
	let weaponrange = values[range];
	let weapondice = values[diceA] + "d" + values[diceB] + "+" + values[diceC];

	/* Formatting */
	iconnew = "<img src='https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/icons/question.png' style='width: 30px; height: 30px;'>";

	if(weapontype == "Slash"){
	iconnew = "<img src='https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/icons/Slash.png' style='width: 30px; height: 30px;'>";
	}
	else if(weapontype == "Pierce"){
	iconnew = "<img src='https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/icons/pierce.png' style='width: 30px; height: 30px;'>";
	}
	else if(weapontype == "Blunt"){
	iconnew = "<img src='https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/icons/blunt.png' style='width: 30px; height: 30px;'>";
	}

	/* Translation prep */
	let langRank = "Rank";
	let langDiceType = "Att";

	if(getTranslationByKey("rank") != false){

	langRank = getTranslationByKey("rank");
	langDiceType = getTranslationByKey("message-attack");

	weapontype = getTranslationByKey("weapon-type-" + weapontype);
	weaponrange = getTranslationByKey("weapon-type-" + weaponrange);

	}

	header = "<div style='background-color: #c25944; overflow: hidden; height: 30px;'><div style='float: left'>" + iconnew + "</div><div style='width: 55%; overflow: hidden; height: 20px; padding-top: 5px; float: left;'><b>" + weaponname + "</b></div><div style='position: absolute; top: 5px; right: 5px;'> <b>" + langRank + ": </b>" + weaponrank + "</div></div>";

	body = "<div style='text-align: center; padding-top: 3px; padding-bottom: 3px; border-bottom: 1px #555 solid;'><b>" + langDiceType + ": </b>" + weapondice + " | " + weapontype + " | " + weaponrange + "</div><div style='width: 100%; height: 70px; overflow: hidden;'><div style='height: 70px; width: 49%; border-right: 1px #555 solid; overflow: auto; float: left;'>" + weapondesc + "</div><div style='height: 70px; width: 49%; overflow: auto; float: left;'>" + weaponeffect + "</div></div>";

	setAttrs({"dummy":header, "dummy2":body});

	let whisperrolls = values.settingWhisperRolls;
	let whispertarget = values.settingWhisperTarget;
	let whisper = "";
	if(whisperrolls == "true"){
	whisper = "/w " + whispertarget;
	}

	/* Send */
	startRoll((whisper + "&{template:shareB} {{header=@{dummy} }} {{body=@{dummy2} }}"), (results) => {

            finishRoll(results.rollId, {} );
        });

    });

});

/*-- Share: Distortion --*/
on("clicked:shareDistort", function(info) {

	/* Get attributes */
        getAttrs(["distort_name", "distort_summary", "distortDescription", "distortEffect", "distortDescription2", "distortEffect2", "distortWeaponDice1", "distortWeaponDice2", "distortWeaponDice3", "distortDefDice1", "distortDefDice2", "distortDefDice3", "distortEvdDice1", "distortCounter", "distortEvdDice2", "distortEvdDice3", "distortCounter", "distortCounter_max", "obsDesc", "obsEffect", "obsBehavior", "obsTaboon", "obsCounter", "obsWorkAmount", "obsWorkResults", "obsWorkPref", "obsSummary", "obsAppearance", "obsAtmosphere", "obsStory", "settingWhisperRolls", "settingWhisperTarget", "distortWorkBase", "distortResultGood", "distortResultNormal", "distortResultBad", "distortWorkInstinct", "distortWorkWisdom", "distortWorkJustice", "distortWorkCharm", "distortWorkInsight", "distortWorkTemperance", "distort_behavior", "distort_taboo", "distort_atmosphere", "distort_appearance", "distort_story"], function(values) {
	let name = values.distort_name;
	let rank = values.charRankBase;
	let attEffect = values.distortEffect;
	let attDesc = values.distortDescription;
	let defEffect = values.distortEffect2;
	let defDesc = values.distortDescription2;

	let iconnew = "https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/icons/Distort.png";
	let typecolor = "#fff";

	/* Translation prep */
	let langMod = "Mod";
	let langWorkPref = "Preferences";
	let langWorkResult = "Results";
	let langWorkAmount = "Work Amount";
	let langTaboon = "Taboos/Boons";
	let langBehavior = "Behavior";
	let langStory = "Story";
	
	if(getTranslationByKey("message-mod") != false){
	langMod = getTranslationByKey("message-mod");
	langWorkPref = getTranslationByKey("distort-obs-workpreference");
	langWorkResult = getTranslationByKey("distort-loweringresults");
	langWorkAmount = getTranslationByKey("distort-obs-work");
	langTaboon = getTranslationByKey("distort-obs-taboon");
	langBehavior = getTranslationByKey("distort-behavior");
	langStory = getTranslationByKey("distort-story");

	}


	/* Formatting */
	let diceA = values.distortWeaponDice1 + "d" + values.distortWeaponDice2 + "+" + values.distortWeaponDice3;
	let diceD = values.distortDefDice1 + "d" + values.distortDefDice2 + "+" + values.distortDefDice3;
	let diceE = values.distortEvdDice1 + "d" + values.distortEvdDice2 + "+" + values.distortEvdDice3;
	let counter = values.distortCounter + "/" + values.distortCounter_max;

	let distortSummary = "";
	if(values.obsSummary == "true"){
	distortSummary = "<div style='padding: 3px; border-bottom: 1px #555 solid; max-height: 60px; overflow: auto;'>" + values.distort_summary + "</div>";}

	let distortAppearance = "";
	if(values.obsAppearance == "true"){
	distortAppearance = "<div style='padding: 3px; border-bottom: 1px #555 solid; max-height: 50px; overflow: auto;'>" + values.distort_appearance + "</div>";
	}

	let distortAtmosphere = "";
	if(values.obsAtmosphere == "true"){
	distortAtmosphere = "<div style='padding: 3px; border-bottom: 1px #555 solid; max-height: 50px; overflow: auto;'>" + values.distort_atmosphere + "</div>";
	}

	let distortStory = "";
	if(values.obsStory == "true"){
	distortStory = "<div style='background-color:#111; padding: 5px;'><b>" + langStory + "</b></div><div style='padding: 3px; border-bottom: 1px #555 solid; max-height: 80px; overflow: auto;'>" + values.distort_story + "</div>";}

	/* Work result formatting */
	let goodIcon = "opacity: 30%";
	let normalIcon = "opacity: 30%";
	let badIcon = "opacity: 30%";

	if(values.distortResultGood == "Good"){
	goodIcon = "opacity: 100%";
	}
	if(values.distortResultNormal == "Normal"){
	normalIcon = "opacity: 100%";
	}
	if(values.distortResultBad == "Bad"){
	badIcon = "opacity: 100%";
	}

	let distortWorkResult = "<div style='text-align: center; width: 39%; float:left; opacity: 30%;'><b>"+ langWorkResult +"</b><br> ?</div>";
	if(values.obsWorkResults == "true"){
	distortWorkResult = "<div style='text-align: center; width: 39%; float:left;'><b>"+ langWorkResult +"</b><br> <img src='https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/icons/good.png' style='height: 25px; width: 25px; " + goodIcon + ";'> <img src='https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/icons/normal.png' style='height: 25px; width: 25px; " + normalIcon + ";'> <img src='https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/icons/bad.png' style='height: 25px; width: 25px; " + badIcon + ";'></div>";
	}

	/* Work preference formatting */

	let distortWorkPref = "<div style='text-align: center; width: 30%; float: left; opacity: 30%;'><b>"+ langWorkPref +"</b><br><b style='color: #cc4125;'>?</b> | <b style='color: #d9d9d9;'>?</b> | <b style='color: #46bdc6;'>?</b><br><b style='color: #9c66c6;'>?</b> | <b style='color: #ffe599;'>?</b> | <b style='color: #ac609d;'>?</b></div>";
	if(values.obsWorkPref == "true"){
	distortWorkPref = "<div style='text-align: center; width: 30%; float: left;'><b>"+ langWorkPref +"</b><br><b style='color: #cc4125;'>" + values.distortWorkInstinct + "</b> | <b style='color: #d9d9d9;'>"+ values.distortWorkWisdom +"</b> | <b style='color: #46bdc6;'>" + values.distortWorkJustice + "</b><br><b style='color: #9c66c6;'>" + values.distortWorkCharm + "</b> | <b style='color: #ffe599;'>"+ values.distortWorkInsight +"</b> | <b style='color: #ac609d;'>" + values.distortWorkTemperance + "</b></div>";
	}

	let distortWorkAmount = "<div style='text-align: center; width: 30%; float: left; opacity: 30%;'><b>" + langWorkAmount + "</b><br><span style='font-size: 25px;'>?</span></div>";
	if(values.obsWorkAmount == "true"){
	distortWorkAmount = "<div style='text-align: center; width: 30%; float: left;'><b>" + langWorkAmount + "</b><br><span style='font-size: 25px;'>"+ values.distortWorkBase + "</span></div>";
	}


	let workSection = "";
	if(values.obsWorkAmount == "true" || values.obsWorkPref == "true" || values.obsWorkResults == "true"){
	workSection = "<div style='width: 100%; background-color: #222; overflow: auto; height: 55px;'>" + distortWorkAmount + distortWorkPref + distortWorkResult + "</div>";}

	/* Behavior/Taboo formatting */

	let distortBehavior = "";
	let distortTaboo = "";
	let flexwidth1 = "49%";
	let flexwidth2 = "50%";

	if(values.obsBehavior != "true" || values.obsTaboon != "true"){
	flexwidth1 = "100%";
	flexwidth2 = "100%";

	}

	if(values.obsBehavior == "true"){
	distortBehavior = "<div style='width: " + flexwidth1 + "; float: left;'><b>" + langBehavior + ": </b><br><div style='height: 60px; overflow: auto;'>" + values.distort_behavior + "</div></div>";

	}
	if(values.obsTaboon == "true"){
	distortTaboo = "<div style='width: "+ flexwidth2 + "; float: left;'><b>" + langTaboon + ": </b><br><div style='height: 60px; overflow: auto;'>" + values.distort_taboo + "</div></div>";
	}
	
	let behaviorSection = "<div style='width: 100%; max-height: 80px; overflow: hidden; background-color: #222;'>"+ distortBehavior + distortTaboo  + "</div>";

	if(values.obsTaboon != "true" && values.obsBehavior != "true"){
	behaviorSection = "";
	}
	/* Behavior section end */

	let distortCounter = "";
	if(values.obsCounter == "true"){
	distortCounter = "<div style='position: absolute; top: 5px; right: 5px; font-size: 20px; color: #cc4125;'> <b>" + counter + "</b></div>";
	}

	let distortDesc = "";
	if(values.obsDesc == "true"){
	distortDesc = "<div style='width: 100%; max-height: 50px; overflow: hidden; background-color: #111;'><div style='height: 50px; width: 49%; border-right: 1px #555 solid; overflow: auto; color: #cc4125; float: left;'><b>" + attDesc + "</b></div><div style='height: 50px; width: 50%; overflow: auto; float: left; color: #6d9eeb;'><b>" + defDesc + "</b></div></div>";
	}

	let distortEffect = "";
	if(values.obsEffect == "true"){
	distortEffect = "<div style='width: 100%; height: 60px; overflow: hidden; background-color: #111; border-top: 1px #555 solid; border-bottom: 1px #555 solid;'><div style='height: 60px; width: 49%; color: #cc4125; border-right: 1px #555 solid; overflow: auto; float: left;'>" + attEffect + "</div><div style='height: 60px; width: 50%; color: #6d9eeb; overflow: auto; float: left;'>" + defEffect + "</div></div> <div style='text-align: center; padding-top: 5px; padding-bottom: 5px; color: #fff; background-color: #000;'><b>" + langMod + ": </b> <span style=' color: #cc4125'>" + diceA + "</span> | <span style='color: #6d9eeb;'>" + diceD + "</span> | <span style='color: #dbb748'>" + diceE + "</span></div>";

	}



	header = "<div style='background-color: #000; color: " + typecolor + "; overflow: hidden; height: 30px;'><div style='float: left'><img src='" + iconnew + "' style='width: 30px; height: 30px; opacity: 50%;'></div><div style='width: 55%; overflow: hidden; height: 20px; padding-top: 5px; float: left;'><b>" + name + "</b></div>" + distortCounter + "</div>";

	body = workSection + behaviorSection + distortSummary + distortAppearance + distortAtmosphere + distortStory + distortDesc + distortEffect + " ";

	setAttrs({"dummy":header, "dummy2":body});

	let whisperrolls = values.settingWhisperRolls;
	let whispertarget = values.settingWhisperTarget;
	let whisper = "";
	if(whisperrolls == "true"){
	whisper = "/w " + whispertarget;
	}

	/* Send */
	startRoll((whisper + "&{template:shareB} {{header=@{dummy} }} {{body=@{dummy2} }}"), (results) => {

            finishRoll(results.rollId, {} );
        });

    });

});

/*-- Share: Ego --*/
on("clicked:shareEgo", function(info) {

	/* Get attributes */
        getAttrs(["egoName", "egoRank", "egoIdeology", "egoCondition", "egoType", "egoDescription", "egoEffect", "egoWeaponType", "egoWeaponRange", "egoWeaponDice1", "egoWeaponDice2", "egoWeaponDice3", "egoDefDice1", "egoDefDice2", "egoDefDice3", "egoEvdDice1", "egoEvdDice2", "egoEvdDice3", "egoImmune1", "egoImmune2", "egoImmune3", "egoImmune4", "egoImmune5", "egoImmune6", "egoRisk", "egoRange", "egoDuration", "settingWhisperRolls", "settingWhisperTarget"], function(values) {
	let name = values.egoName;
	let rank = values.egoRank;
	let conditionBase = values.egoCondition;
	let condition = conditionBase;
	let type = values.egoType;
	let effect = values.egoEffect;
	let desc = values.egoDescription;
	let ideology = values.egoIdeology;

	let specialriskNum = values.egoRisk;
	let specialrangeNum = values.egoRange;
	let specialdurationNum = values.egoDuration;

	let iconnew = "https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/icons/question.png";
	let typecolor = "#fff";
	let bottomdata = "";

	/* Condition formatting */
	switch (condition) {
		case "AlwaysActive": condition = "Always active"; break;
		case "HalfHealth": condition = "50% health"; break;
		case "OnStagger": condition = "On stagger"; break;
		case "EnemyDefeat": condition = "Enemy defeat"; break;
		case "AllyDefeat": condition = "Ally defeat"; break;
		default: condition = "---";
	}

	/* Translation prep */
	let langRank = "Rank";
	let langDiceTypeAtt = "Att";
	let langDiceTypeDef = "Def";
	let langDiceTypeEvd = "Evd";
	let langType = "Type";
	let langEgoType = type;

	let langRisk = "Risk";
	let langRange = "Range";
	let langDuration = "Duration";
	
	if(getTranslationByKey("rank") != false){

	langRank = getTranslationByKey("rank");
	langType = getTranslationByKey("message-type");
	langDiceTypeAtt = getTranslationByKey("message-attack");
	langDiceTypeDef = getTranslationByKey("message-defend");
	langDiceTypeEvd = getTranslationByKey("message-evade");

	langEgoType = getTranslationByKey("ego-type-" + type);
	condition = getTranslationByKey("ego-active-" + conditionBase);

	langRisk = getTranslationByKey("special-risk-text");
	langRange = getTranslationByKey("special-range-text");
	langDuration = getTranslationByKey("special-duration-text");

	specialrisk = getTranslationByKey("special-risk-" + specialriskNum);
	specialrange = getTranslationByKey("special-range-" + specialrangeNum);
	specialduration = getTranslationByKey("special-duration-" + specialdurationNum);

	}


	/* Formatting */
	if(type == "Weapon"){
	let diceA = values.egoWeaponDice1 + "d" + values.egoWeaponDice2 + "+" + values.egoWeaponDice3;
	let weapontype = values.egoWeaponType;
	let weaponrange = values.egoWeaponRange;

	typecolor = "#cc4125";

	if(weapontype == "Slash"){
	iconnew = "https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/icons/egoSlash.png";
		}
	else if(weapontype == "Pierce"){
	iconnew = "https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/icons/egoPierce.png";
		}
	else if(weapontype == "Blunt"){
	iconnew = "https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/icons/egoBlunt.png";
		}

	if(getTranslationByKey("weapon-type-" + weapontype) != false){
	weapontype = getTranslationByKey("weapon-type-" + weapontype);
	weaponrange = getTranslationByKey("weapon-type-" + weaponrange);
	}

	bottomdata = "<div style='text-align: center; padding-top: 5px; padding-bottom: 5px; color:" + typecolor + "; background-color: #000;'><b>" + langDiceTypeAtt + ": </b>" + diceA + " | " + weapontype + " | " + weaponrange + "</div>";
	

	}
	else if(type == "Outfit"){
	typecolor = "#6d9eeb";
	iconnew = "https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/icons/egoDef.png";

	let diceD = values.egoDefDice1 + "d" + values.egoDefDice2 + "+" + values.egoDefDice3;
	let diceE = values.egoEvdDice1 + "d" + values.egoEvdDice2 + "+" + values.egoEvdDice3;

let iconSlash = "<img src='https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/def/ResSlash.png' style='width: 25px; height: 25px;'>";
	let iconSlashSTG = "<img src='https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/def/ResSlashStg.png' style='width: 25px; height: 25px;'>";

	let iconPierce = "<img src='https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/def/ResPierce.png' style='width: 25px; height: 25px;'>";
	let iconPierceSTG = "<img src='https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/def/ResPierceStg.png' style='width: 25px; height: 25px;'>";

	let iconBlunt = "<img src='https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/def/ResBlunt.png' style='width: 25px; height: 25px;'>";
	let iconBluntSTG = "<img src='https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/def/ResBluntStg.png' style='width: 25px; height: 25px;'>";

	let immune = 
	"<div style='height:15px;'><div style='width: 70px; color: #c25944; float: left'>" + iconSlash + " x" + values.egoImmune1 + "</div> <div style='width: 70px; color: #dbb748; float: left;'>" + iconSlashSTG + " x" + values.egoImmune2 + "</div></div><br>" + 
	"<div style='height:15px;'><div style='width: 70px; color: #c25944; float: left'>" + iconPierce + " x" + values.egoImmune3 + "</div> <div style='width: 70px; color: #dbb748; float: left;'>" + iconPierceSTG + " x" + values.egoImmune4 + "</div></div><br>" +
	"<div style='height:15px;'><div style='width: 70px; color: #c25944; float: left'>" + iconBlunt + " x" + values.egoImmune5 + "</div> <div style='width: 70px; color: #dbb748; float: left;'>" + iconBluntSTG + " x" + values.egoImmune6 + "</div></div>";

	bottomdata = "<div style='background-color: #000; height: 70px;'><div style='text-align: center; padding-top: 15px; padding-bottom: 15px; color:" + typecolor + "; width: 49%; float: left;'><b>" + langDiceTypeDef + ": </b> " + diceD + "<br><span style='color: #dbb748'><b>" + langDiceTypeEvd + ": </b>" + diceE + "</span></div><div style='height: 70px; width:49%; float: left; overflow: auto;'>" + immune +"</div></div>";

	}
	else if(type == "Tool"){
	typecolor = "#8e7cc3";
iconnew = "https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/icons/egoAct.png";
	}
	else if(type == "Special"){
	typecolor = "#cf8c44";
iconnew = "https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/icons/egoSpecial.png";

	bottomdata = "<div style='text-align: center; padding-top: 5px; padding-bottom: 5px; color:" + typecolor + "; background-color: #000;'><div style='text-align: left; padding: 5px;'><b>" + langRisk + ": </b>" + specialrisk + "<br> <b>" + langRange + ": </b>" + specialrange + "<br> <b>" + langDuration + ": </b>" + specialduration + "</div></div>";


	}
	else if(type == "0"){
	type = "---";
	}

	header = "<div style='background-color: #000; color: " + typecolor + "; overflow: hidden; height: 30px;'><div style='float: left'><img src='" + iconnew + "' style='width: 30px; height: 30px;'></div><div style='width: 55%; overflow: hidden; height: 20px; padding-top: 5px; float: left;'><b>" + name + "</b></div><div style='position: absolute; top: 5px; right: 5px;'> <b>"+ langRank + ": </b>" + rank + "</div></div>";

	body = "<div style='text-align: center; padding-top: 3px; padding-bottom: 3px; border-bottom: 1px #555 solid;'><b>" + langType + ": </b>" + langEgoType + " | " + condition + "</div><div style='padding: 3px; border-bottom: 1px #555 solid; max-height: 30px; overflow: auto;'>" + ideology + "</div><div style='width: 100%; height: 70px; overflow: hidden;'><div style='height: 70px; width: 49%; border-right: 1px #555 solid; overflow: auto; float: left;'>" + desc + "</div><div style='height: 70px; width: 49%; overflow: auto; float: left;'>" + effect + "</div></div>" + bottomdata;

	setAttrs({"dummy":header, "dummy2":body});

	let whisperrolls = values.settingWhisperRolls;
	let whispertarget = values.settingWhisperTarget;
	let whisper = "";
	if(whisperrolls == "true"){
	whisper = "/w " + whispertarget;
	}

	/* Send */
	startRoll((whisper + "&{template:shareB} {{header=@{dummy} }} {{body=@{dummy2} }}"), (results) => {

            finishRoll(results.rollId, {} );
        });

    });

});

/*-- Share: Skills --*/
on("clicked:shareSkill", function(info) {

	/* Get IDs/names */
        let buttonid = info.htmlAttributes.id.split('_')[1];
	let skillcat = buttonid.split('S')[0];

	let name = buttonid + "Name";
	let type = buttonid + "Type";
	let rank = buttonid + "Rank";
	let effect = buttonid + "Effect";
	let desc = buttonid + "Description";
	let light = buttonid + "Light";

	let diceA = buttonid + "Dice1";
	let diceB = buttonid + "Dice2";
	let diceC = buttonid + "Dice3";

	let header = "";
	let body = "";

	/* Get attributes */
        getAttrs([`${name}`, `${type}`, `${rank}`, `${effect}`, `${desc}`, `${light}`, `${diceA}`, `${diceB}`, `${diceC}`, "settingWhisperRolls", "settingWhisperTarget"], function(values) {

	let skillname = values[name];
	let skillrank = values[rank];
	let skilltype = values[type];
	let skilleffect = values[effect];
	let skilldesc = values[desc];
	let skilllight = values[light];
	let skilldice = values[diceA] + "d" + values[diceB] + "+" + values[diceC];
	let iconurl = "/";
	let iconbg = "#555";
	let headerbg = "#555";

	/* Formatting */

	if (skillcat == "ego"){
	iconbg = "#000";
	headerbg = "#000";

	if(skilltype == "Attack"){
	iconurl = "https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/icons/egoAtt.png";
		}
	else if(skilltype == "Defend"){
	iconurl = "https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/icons/egoDef.png";
		}
	else if(skilltype == "Evade"){
	iconurl = "https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/icons/egoEvd.png";
		}
	else if(skilltype == "Action"){
	iconurl = "https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/icons/egoAct.png";
		}
	else if(skilltype == "Mass"){
	iconurl = "https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/icons/egoWide.png";
		}
	}
	else{
	if(skilltype == "Attack"){
	iconurl = "https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/icons/Attack.png";
	iconbg = "#c25944";
		}
	else if(skilltype == "Defend"){
	iconurl = "https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/icons/defend.png";
	iconbg = "#7397d1";
		}
	else if(skilltype == "Evade"){
	iconurl = "https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/icons/evade.png";
	iconbg = "#dbb748";
		}
	else if(skilltype == "Action"){
	iconurl = "https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/icons/Portable.png";
	iconbg = "#8e7cc3";
		}
	else if(skilltype == "Mass"){
	iconurl = "https://raw.githubusercontent.com/punibird/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/icons/Wide.png";
	iconbg = "#c25944";
		}
	}

	/* Translation prep */
	let langRank = "Rank";
	let langMod = "Mod";
	let langCost = "Cost";
	
	if(getTranslationByKey("rank") != false){

	langRank = getTranslationByKey("rank");
	langMod = getTranslationByKey("message-mod");
	langCost = getTranslationByKey("message-cost");

	skilltype = getTranslationByKey("skill-type-" + skilltype);

	}

	let iconnew = "<img src='" + iconurl + "' style='width: 28px; height: 28px; border-radius: 100px; border: 1px #fff solid; background-color: " + iconbg + ";'>";

	header = "<div style='background-color: " + headerbg + "; overflow: hidden; height: 30px;'><div style='float: left'>" + iconnew + "</div><div style='width: 55%; overflow: hidden; height: 20px; padding-top: 5px; padding-left: 2px; float: left;'><b>" + skillname + "</b></div><div style='position: absolute; top: 5px; right: 5px;'> <b>" + langRank + ": </b>" + skillrank + "</div></div>";

	body = "<div style='text-align: center; padding-top: 3px; padding-bottom: 3px; border-bottom: 1px #555 solid;'><b>" + skilltype + "</b> | <b>" + langMod + ": </b>" + skilldice + " | <b>" + langCost + ": </b>" + skilllight + "</div><div style='width: 100%; height: 70px; overflow: hidden;'><div style='height: 70px; width: 49%; border-right: 1px #555 solid; overflow: auto; float: left;'>" + skilldesc + "</div><div style='height: 70px; width: 49%; overflow: auto; float: left;'>" + skilleffect + "</div></div>";

	setAttrs({"dummy":header, "dummy2":body});

	let whisperrolls = values.settingWhisperRolls;
	let whispertarget = values.settingWhisperTarget;
	let whisper = "";
	if(whisperrolls == "true"){
	whisper = "/w " + whispertarget;
	}

	/* Send */
	startRoll((whisper + "&{template:shareB} {{header=@{dummy} }} {{body=@{dummy2} }}"), (results) => {

            finishRoll(results.rollId, {} );
        });

    });

});

/* Toggle: Edit Mode */
on("clicked:editMode", function(){
	getAttrs(["settingEditMode"], function(values) {
		setAttrs({"settingEditMode": (values.settingEditMode == "true") ? "0" : "true"});
	});
});


/* Tab toggler */
const tablist = ["equipment","skills","details","export", "edit"];
tablist.forEach(tab => {
	on(`clicked:${tab}`, function() {
		setAttrs({sheetTab: tab});
	});
});



/*--- Editor functions ---*/
function openEditor(type, newTarget, newTargetName) {
	let editorAttrs = [`${newTarget}`, `${type}EditorTarget`, `${type}EditorInput`];

	getAttrs(editorAttrs, function(values) {
		let oldTarget = values[`${type}EditorTarget`];
		let newInput = values[`${newTarget}`];
		let oldInput = values[`${type}EditorInput`];
		
		let output = {
			[`${type}EditorTarget`]: newTarget,
			[`${type}EditorTargetOld`]: oldTarget,
			[`${type}EditorTargetName`]: newTargetName || newTarget,
			[`${type}Editor_display`]: "true"
		}

		if (type == "item" && newInput != "") {
			//newInput = JSON.parse(newInput);
			//output = {...output, ...newInput};
		} else {
			output[`${type}EditorInput`] = newInput;
		}
		
		if (oldTarget != "") {
			output[oldTarget] = oldInput;
		}

		setAttrs(output);
	});
}

function saveEditor(type, attrs={}, callback=()=>{}) {
	let options = (type == "item") ? {prefix: type, ignoreDefault: true} : {}


	// Since the itemSheetKeys.itemEditor includes repeating_ailments, events will also be registered for some stuff outside of the editor
	// You may want to exclude these values from the sync or add special handling to update ALL items when these events trigger

	/* After getting values, do
	for (const [key, value] of Object.entries(values)) {
		if (key.startsWith("repeating")) {
			let [type, repid, repkey] = key.split("_").shift();
			let repindex = idarray.indexOf(repid);
			formatedValues[`repeating_${type}`][repindex][repkey] = values[key]; // This may not work
			delete values[key];
		}
	}
	*/
	// For the parsing process, if key.startsWith("option"), parse as if "valid: (b) => is.Bool(b)" and "subattrs: value" if they're not defined already












	/* Helper functions uses to configure which attributes should be retrieved */
	/* Attrs are structured as {attrKey: defaultValue} pairs */
	/* Repeating attrs are structured as {repeating_section:attrAlias: {attrKey: defaultValue}} */
	const computeKeys = (callback=()=>{}) => { // - Deapprechiated. The new input parsing method should work better
		
		
		// - Now needs getAttrs(["itemEditorTarget"], function(values) {});
		
		
		
		if (length(attrs) > 0) {
			getSectionIDs("rollformats", rollformat_idarray => {
			getSectionIDs("ailments", ailments_idarray => {
			let idarrays = {"repeating_rollformats": rollformat_idarray, "repeating_ailments": ailments_idarray}
			
			let repFormat = {}
			let editorKeys = []

			for (const [key, value] of Object.entries(attrs)) {

				// Handle repeating attributes
				if (typeof(value) == "object") {
					let [repsection, repalias] = key.split(":");
					let idarray = idarrays[repsection];
					repFormat[key] = {}
					
					// Compute the attributes for each repitem (which each have an unique id)
					for (let i = 0; i < idarray.length; i++) {
						let id = idarray[i];
						repFormat[key][i] = {};
						
						for (let [repkey, repvalue] of Object.entries(value)) {
							repFormat[key][i][`${repsection}_${id}_${repkey}`] = repvalue;
							editorKeys.push(`${repsection}_${id}_${repkey}`);
						}
					}
				}

				// Handle an optional attribute prefix
				else if (options.prefix) {
					editorKeys.push(options.prefix + key);
				}

				// Handle normal attributes
				else {
					editorKeys.push(key);
				}
			}

			callback(editorKeys, repFormat);
			});
			});
		} else {
			callback([`${type}EditorInput`]);
		}
	}
	
	computeKeys((editorKeys, repFormat) => {
		getAttrs([`${type}EditorTarget`, ...editorKeys], function(values) {
			let editorTarget = values[`${type}EditorTarget`];
			let editorData = "";

			if (type == "item") {
				editorData = packageAttrData(values, {}, attrs, repFormat, "standard", options);
			} else {
				editorData = values[`${type}EditorInput`];
			}

			/* Save editor data */
			if (editorTarget != "") {
				let output = {[editorTarget]: editorData}

				if (type == "item") { output[`${type}EditorInput`] = editorData; } // For testing purposes. Displays the data in plaintext

				setAttrs(output);
				callback();
			}
		});
	});
}

function closeEditor(type) {
	setAttrs({
		[`${type}Editor_display`]: "0",
		[`${type}EditorTarget`]: "",
		[`${type}EditorTargetName`]: ""
	});
}
/*--- Editor functions end ---*/



/*--- Repeating inventory ---*/

/* An item consists of one or more itemNodes. The format for these nodes can be seen in itemNode.format */
/* The itemList consists of one or more items. For more details, see itemListHandler */
class itemNode {
	constructor(type, id, formats={}) {
		Object.defineProperties(this, {
			valid: {writable: true, value: {}}, // List of attribute value validators for the node
			attrs: {writable: true, value: {}},  // List of attribute name formats for the node
			enabled: {writable: true, value: false}, // If a subnode and it's properties are enabled for the item. Used primarily for toggling options
			id: {writable: true, value: id}, // The itemId of the item the node belongs to
		});

		// Configures the format of the node if one wasn't provided
		if (formats.base == undefined || formats.default == undefined) {
			if (type in itemNode.format.defaults) {
				formats.default = itemNode.format.defaults[type];
				formats.base = itemNode.format.base;
				this.enabled = true;
			}
		}
		if (!formats.valid) { formats.valid = itemNode.format.valid; }
		if (!formats.style) { formats.style = itemNode.format.style; }
		if (!formats.source) { formats.source = {
			editor: {
				prefix: "itemEdit",
			},
			sheet: {
				section: type.toLowerCase() + "s",
				id: this.id,
			}
		}}

		// All nodes in the default format should be enabled by default. All other nodes should be disabled
		if (formats.default != false) {
			this.enabled = true;
		}

		// Get any source-specific attribute name data ("editor" or "sheet")
		Object.defineProperties(this.attrs, {
			sheet: {writable: true, value: formats.source.sheet},
			editor: {writable: true, value: formats.source.editor},
			// Will later add export attribute name data here
		});

		
		// Constructs the node and any subnodes
		for (const [prop, value] of Object.entries(formats.base)) {

			// Get any subnodes of the node
			if (prop == "array" && Array.isArray(value)) {
				for (let i = 0; i < (formats.default?.array?.length || 1); i++) {
					let repFormat = {
						editor: {...formats.source.editor, prefix: ""},
						sheet: {...formats.source.sheet},
					}

					for (const source of Object.keys(formats.source)) {
						switch (formats.style.repeating?.[source]?.type) {
							case "index":
								repFormat[source].index = i; break;
							case "id":
								repFormat[source].section = formats.style.repeating.section;
								let sourceIDs = itemList.editor.IDs[repFormat[source].section]
								if (sourceIDs && sourceIDs.length > i) {
									repFormat[source].id = sourceIDs[i];
								} else {
									repFormat[source].id = generateRowID().toLowerCase();
								}
								break;
							case "props":
								throw new Error("Tried to access repeating prop values, but repeating props are currently not implemented");
								break; // Currently not implemented
							default:
								throw new Error("itemNode includes repeating data but has no repeating style format", this);
						}
					}
					
					this[i] = new itemNode(prop, id, {
						base: value[i] || value[0],
						default: formats.default?.array?.[i] || {},
						valid: formats.valid.array || {},
						style: formats.style.array || {},
						source: repFormat,
					});
				}
			}
			else if (typeof value == "object") {
				this[prop] = new itemNode(type, id, {
					base: value,
					default: formats.default[prop] || false,
					valid: formats.valid[prop] || {},
					style: formats.style[prop] || {},
					source: formats.source,
				});
			}


			// Get any properties of the node
			else {
				if (formats.default && prop in formats.default) {
					this[prop] = formats.default[prop];
				} else {
					this[prop] = value;
				}
			}


			// Get any property-specific attribute name data (ex. for options)
			if (formats.style?.[prop]?.option) {
				this.attrs[prop] = "option" + formats.style[prop].option;
			}
			else if (prop != "array") {
				let prefix = formats.style.prefix || "";
				let suffix = formats.style.suffix || "";
				let key = (prefix != "") ? capitalize(prop) : prop;
				this.attrs[prop] = prefix + key + suffix;
			}


			// Get any attribute value validatation data
			if (formats.valid?.[prop] && typeof formats.valid[prop] == "function") {
				this.valid[prop] = formats.valid[prop];
			} else {
				if (!(prop in formats.valid)) {
					console.warn(`itemNode - valid format: property "${prop}" is not in the format`, formats.valid);
				}
				this.valid[prop] = (b) => is.Bool(b);
			}
		}
		return this;
	}

	// Assign input attribute values from the sheet and/or editor to the item. See itemList.input() for more details
	input(values, options={}) {
		return this.access(values, {...options, lowerCase:true});
	}

	// Generates and outputs a list of attribute values for the sheet and editor. See itemList.output() for more details
	// Editor data is only generated for the item currently open in the item editor
	output(options={}) {
		return this.access(false, options);
	}

	// Generates and returns an array of keys for both the editor and sheet. See itemList.keys and itemList.event() for more details
	// If an event is provided the keys are returned in the event key format
	keys(event=false) {
		return Object.entries(this.access(false, {includeDisabled:true, lowerCase:true, event}))
			.reduce((acc, [source, values]) => { return {...acc, [source]: Object.keys(values)} }, {});
	}

	// Helper method for accessing all nodes and properties of an item
	// Used by input(), output(), import(), export() and keys()
	access(values, options={includeDisabled:false, lowerCase:false, event:false}) {
		let output = {editor: {}, sheet: {}}

		// Values generated by getAttrs() are all in lower-case, while values from item.output may be in mixed-case
		// For consistent prop-to-attr matching all attribute and property names are converted to lowercase
		if (values && length(values) > 0) {
			for (const source of Object.keys(values)) {
				values[source] = Object.entries(values[source]).reduce((acc, [key, value]) => { return {...acc, [key.toLowerCase()]: value} }, {});
			}
		}

		if (!values || length(values) > 0) {
			for (const [prop, value] of Object.entries(this)) {
				for (const source of Object.keys(itemNode.format.sections)) {

					// Only input and output editor data from the current editor target
					if (source == "editor" && this.id != itemList.editor.target && !options.event) { continue; }

					// Get the attribute name of the property in the current source
					let propAttr = this.attr(prop, source, options);

					// Handle inputting values
					if (values && length(values[source]) > 0 && propAttr in values[source]) {
						this.modify(prop, values[source][propAttr], {...options, source: "input"});
						delete values[source][propAttr];
					}

					// Handle outputting values
					else if ((this.enabled || options.includeDisabled)) {
						if (this.hasOption(prop)) {
							output[source][propAttr] = "" + this[prop].enabled;
						}
						else if (!(value instanceof itemNode)) {
							output[source][propAttr] = value;
						}
					}
				}
				
				// Recursively access any sub-nodes
				if (value instanceof itemNode) {
					Object.entries(value.access(values, options)).reduce((acc, [source, subnodeOutput]) => Object.assign(output[source], subnodeOutput), {});
				}
			}
			return output;
		}
	}

	// Returns the attribute name of a property in either the sheet or editor
	// If an event type is provided the attribute is returned in the event key format
	attr(prop, source, options={lowerCase:false, event:false}) {
		if (this.attrs[prop]) {
			let index = (this.attrs[source].index != undefined) ? this.attrs[source].index : "";
			let prefix = this.attrs[source].prefix || "";
			let suffix = this.attrs[source].suffix || "";
			let key = this.attrs[prop];

			if (prefix != "") key = capitalize(key);

			if (this.attrs[source].section) {
				if (options.event) {
					prefix = `${options.event}:repeating_${this.attrs[source].section}:${prefix}`;
				} else {
					prefix = `repeating_${this.attrs[source].section}_${this.attrs[source].id}_${prefix}`;
				}
			} else if (options.event) {
				prefix = `${options.event}:${prefix}`;
			}

			let propAttr = prefix + key + suffix + index;
			return (options.lowerCase) ? propAttr.toLowerCase() : propAttr;
		} else {
			return false;
		}
	}

	// Helper that checks if an itemNode property is associated with an option attribute
	hasOption(prop) {
		return this.attrs[prop]?.startsWith("option");
	}

	// Modifies an item property
	// If a validator format was provided at item creation only valid values are accepted
	// Adds any changes to itemList.outputValues. The changes are applied to the sheet/editor when the itemList access ends
	modify(prop, newValue, options={source:"input", modify:false}) {
		if (!isNaN(parseInt(prop))) return; // Ensures repeating nodes are not modified (have prop names "0", "1", etc.)

		console.log(`(${options.source}) ${prop} ${this[prop]} -> ${newValue}`);
		if (this[prop] != undefined) {
			
			if (prop in this.valid && !this.valid[prop](newValue)) {
				console.warn(`Attempted to set the value of ${prop} to invalid value ${newValue}`, this);
			} else {
				if (this[prop] != newValue) {
					console.log(`(${options.source}) Modifying ${prop} from "${this[prop]}" to "${newValue}"`);

					// Makes sure enabled is set to a boolean value and not ex. "false"
					if (this[prop] instanceof itemNode) {
						this[prop].enabled = is.True(newValue);
					} else if (prop == "enabled") {
						this[prop] = is.True(newValue);
					} else {
						this[prop] = newValue;
					}

					// Modify the associated attributes in the sheet/editor if applicable
					if (this.attrs[prop]) {
						if (!options.modify || options.modify == "sheet") {
							itemList.outputValues[this.attr(prop, "sheet")] = newValue;
						}
						if (this.id == itemList.editor.target && (!options.modify || options.modify == "editor")) {
							itemList.outputValues[this.attr(prop, "editor")] = newValue;
						}
					}
				}
			}
		} else {
			console.warn(`Attempted to set the value of ${prop} but the property does not exist`, this);
		}
	}

	// Adds a new repeating subnode to the item
	add(type) {
		if (type == "Rollformat") {
			this.rollformats.enabled = true;

			let newFormat = new itemNode(type, this.id, {
				base: itemNode.format.base.rollformats.array[0],
				default: false,
				valid: itemNode.format.valid.rollformats.array,
				style: itemNode.format.style.rollformats.array,
				source: {
					editor: {
						prefix: "",
						id: generateRowID().toLowerCase(),
						section: "rollformats",
					},
					sheet: {
						id: this.id,
						index: length(this.rollformats),
						section: this.type.toLowerCase() + "s",
					}
				}
			});

			this.rollformats[length(this.rollformats)] = newFormat;
			newFormat.enabled = true;
			itemList.outputValues.rollFormatAddToggle = "" + (this.rollformats.length >= 5);
		}
	}

	

	/* Code beyond this point is unfinished */

	// Deletes a repeating subnode of the item with a specific id
	delete(type, id) {
		if (type == "Rollformat") {
			
			function updateIndexes(node, oldIndex, newIndex) {
				if (node.attrs) {
					node.attrs.sheet.index = newIndex;
				}

				for (const subnode of Object.values(node)) {
					if (subnode instanceof itemNode) {
						updateIndexes(subnode, oldIndex, newIndex);
					}
				}
			}

			let deletedIndex = false;
			for (const [index, node] of Object.entries(this.rollformats)) {
				if (deletedIndex != false && index > deletedIndex) {
					updateIndexes(this.rollformats[index], index, index-1);
					this.rollformats[index-1] = this.rollformats[index];
					delete this.rollformats[index];
				}
				else if (node.attrs.editor.id == id) {
					delete this.rollformats[index];
					itemList.editor.IDs.rollformats.splice(index, 1);
					deletedIndex = index;
				}
			}

			itemList.outputValues.rollFormatAddToggle = "" + (this.rollformats.length < 5);
		}

		// Currently not implemented
		// Should decrease the index of all following repeating subnodes by 1
		// This includes both the property name and the index found in attrs.sheet 
	}

	// Info on how to implement "props" style attribute keys, which will be used in item export scripts
	//   If type == "props":
	//     When inputing values (values != false) get repeating.editor.check, find values where key includes check.key and where check.value(value) == true. Get their ids
	//       Then get repeating.editor.key and value, loop through the ids, find matches with id_key in values, get the key, then set this[key] = values[repeating_section_id_value] 
	//       Also save the ids to attr_editorRepeatingProps as {key: {prop1: id, prop2: id}}. When accessing itemList, it adds all props from editorRepeatingProps to editor.IDs
	//       Change of plans: have itemList.access set up editorRepeatingProps. Have it import check-key pairs, get the attrs, check which values have check.key and check.value(value) == true
	//         Get the ids, find attrs containing id_key, then save IDs.key = [values[key]: id, ...]
	//         This method should be able to handle any future repeating values you add to the editor
	//     When outputing values, loop over props and values, get itemList.editor.IDs[key], then output {repeating_rep.section_id_rep.key: prop, repeating_rep.section_id_rep.value: value}
	//       When exporting, ignore this and just export [alias, prop:value, prop:value, ...]. Their repeatingProps will have the correct ids for their sheet

	/* Unfinished code end */


	static format = {

		// The base format of all items. Modified with format.defaults[itemtype] before being added to the itemList
		base: {
			type: "Effect", rank: 0, name: "", description: "", effect: "",
			minimized: false,
			equip: {
				equipped: false,
				slots: {
					type: "Hand", use: 0,
				},
			},
			rollformats: {
				array: [{
					type: "None", mode: "Roll", damagetype: "None", count: 0, max: 0, power: 0, adv: false, autoscript: "",
					action: {type: "Action", cost: 1},
					reaction: {type: "Reaction", cost: 1},
					uses: {cost: 1},
					store: {
						count: 0, max: 0, power: 0, adv: false, autoscript: "",
					},
				}]
			},
			usable: {
				type: "None",
				action: {type: "Action", cost: 1},
				reaction: {type: "None", cost: 0},
				uses: {cost: 1},
			},
			linked: {
				id: false,
				equipTogether: true,
			},
			limited: {
				uses: {
					max: 3, current: 3, recharge: "None",
				},
				light: {
					cost: 0,
				},
			},
			resistances: {
				damage: {
					base: {
						slash: {mode: "None", hp: 1, st: 1},
						pierce: {mode: "None", hp: 1, st: 1},
						blunt: {mode: "None", hp: 1, st: 1},
					},
					flat: {
						slash: {mode: "None", hp: 0, st: 0},
						pierce: {mode: "None", hp: 0, st: 0},
						blunt: {mode: "None", hp: 0, st: 0},
					},
				},
				ailments: {
					default: {Burn: 0, Bleed: 0},
					custom: {},
				},
			},
			mystery: {
				activation: "None",
			},
			tags: {
				gives: {},
				requires: {},
			},
			style: {
				icon: {
					source: "",
				},
				color: "Black",
				accent: "None",
			},
			ui: {
				damagetype: false,
				range: false,
				special: false,
				half: false,
			},
			card: {},
			autoscript: "",
		},

		// Includes all default override values for items of a certain type. If a value is not specified here the value in the base format is used
		// All sub-nodes like "rollformats" are optional and begin off disabled by default
		// Including a subnode in an item's default values (even just writing "subnode: {}") enables that subnode 
		defaults: {
			Weapon: {
				type: "Weapon",
				equip: {slots: {type: "Hands", value: 1}},
				rollformats: {
					array: [
						{type: "Attack", damagetype: "Untyped", count: 1, max: 10, power: 0, action: {}, reaction: {type: "Counter"}},
					],
				},
				style: {color: "Red"},
				ui: {damagetype: true, range: true},
			},
			Outfit: {
				type: "Outfit",
				equip: {},
				rollformats: {
					array: [
						{type: "Block", count: 1, max: 10, power: 0, action: {}, reaction: {type: "Block"}},
						{type: "Evade", count: 1, max: 12, power: 0, action: {}, reaction: {type: "Evade"}, store: {power: -2}},
					],
				},
				resistances: {
					damage: {
						base: {
							slash: {mode: "Replace", hp: 1, st: 1},
							pierce: {mode: "Replace", hp: 1, st: 1},
							blunt: {mode: "Replace", hp: 1, st: 1},
						},
					},
					ailments: {
						default: {},
						custom: {},
					}
				},
				style: {color: "Blue"},
			},
			Augment: {
				type: "Augment",
				equip: {},
				resistances: {
					ailments: {
						default: {},
						custom: {},
					}
				},
				style: {color: "Green"},
			},
			Tool: {
				type: "Tool",
				equip: {slots: {type: "Hands", value: 1}},
				usable: {type: "Standalone", action: {}, uses: {}},
				limited: {uses: {max: 3, current: 3, recharge: "Refresh"}},
				style: {color: "Purple"},
				ui: {half: true},
			},
			Skill: {
				type: "Skill",
				equip: {},
				rollformats: {
					array: [
						{type: "None", mode: "Applied", count: 0, max: 0, power: 0,
							action: {type: "None", value: 0}, reaction: {type: "None", cost: 0}},
					],
				},
				limited: {light: {cost: 1}},
			},
			Special: {
				type: "Special",
				equip: {},
				style: {color: "Orange"},
				ui: {special: true}
			},
			Effect: {
				type: "Effect",
			}
		},

		// Includes functions for validating item input values
		valid: {
			type: (s) => is(s).In(Object.keys(itemNode.format.defaults)),
			rank: (i) => is.Int(i, {min: -1}),
			name: (s) => is.String(s, {newlines:false}),
			description: (s) => is.String(s),
			effect: (s) => is.String(s),
			minimized: (b) => is.Bool(b),
			equip: { // Always enabled
				equipped: (v) => is.Bool(v) || is(v).In(["Mainhand", "Offhand"]), // How do you handle this? It should be is.ID(this.linked) && is.Bool(b) || is(b).in(hand), but linked isn't in this, it's in this.parent.linked.id. You also need linked to be updated first
				slots: { // Enabled by optionEquipSlots
					type: (s) => is.String(s), // String value matching a type of equip slots (like "Hand"). This would have to reference an external list of equipSlot types
					use: (i) => is.Int(i),
				},
			},
			rollformats: { // Enabled by optionRollFormats. Can contains between 1 and 5 formats. This is handled in itemNode.add("Rollformat")
				array: {
					type: (s) => is(s).In(["None", ...combatRollNames, ...statNames, "Custom"]),
					mode: (s) => is(s).In(["Roll", "Applied"]),
					damagetype: (v) => is(v).In(["None", ...damageTypes, "Untyped"]) || is.Array(v, {min:1, max:3}), // false for non-attacks. One of "None", "Slash", "Pierce", "Blunt", "Untyped" or an object with 2+ damagetypes ("Hybrid")
					count: (i) => is.Int(i, (this.type == "Roll") ? {min: 1} : {}), // This probably still refers to this itemNode, right? If not use itemList[this... id...]... motherfucker
					max: (i) => is.Int(i, (this.type == "Roll") ? {min: 0} : {}),
					power: (i) => is.Int(i),
					adv: (v) => is.False(v) || is(v).In(["Advantage", "Disadvantage"]),
					action: { // Enabled by optionRollAction *with an index*
						type: (s) => is(s).In(["None", ...resourceNames]),
						cost: (i) => is.Int(i, {min: 0}),
					},
					reaction: { // Enabled by optionRollReaction *with an index*
						type: (s) => is(s).In(["None", ...resourceNames]),
						cost: (i) => is.Int(i, {min: 0}),
					},
					uses: { // Enabled by optionRollUses *with an index*
						cost: (i) => is.Int(i, {min: 0}),
					},
					store: { // Enabled by optionStoreRoll *with an index*
						count: (i) => is.Int(i),
						max: (i) => is.Int(i),
						power: (i) => is.Int(i),
						adv: (v) => is.False(v) || is(v).In(["Advantage", "Disadvantage"]),
						autoscript: (s) => is.String(s),
					},
					autoscript: (s) => is.String(s),
				},
			},
			usable: { // Enabled by optionUsable
				type: (s) => is(s).In(["None", "Standalone", "Applied", "Both"]),
				action: { // Enabled by optionUsableReaction
					type: (s) => is(s).In(["None", ...resourceNames]),
					cost: (i) => is.Int(i, {min: 0}),
				},
				reaction: { // Enabled by optionUsableReaction
					type: (s) => is(s).In(["None", ...resourceNames]),
					cost: (i) => is.Int(i, {min: 0}),
				},
				uses: {
					cost: (i) => is.Int(i, {min: 0}),
				},
			},
			linked: { // Enabled by optionLinked
				id: (v) => is.Bool(v) || is(v).In(itemList.IDs), // Need to make sure this works if the linked item is added after this item. Maybe add all the ids first and then add the itemNodes?
				equipTogether: (b) => is.Bool(b),
			},
			limited: { // Enabled by optionLimited
				uses: { // Enabled by optionUses
					current: (i) => is.Int(i, {min: 0}),
					max: (i) => is.Int(i, {min: 0}),
					recharge: (s) => is(s).In(["None", "Manual", "Refresh", "Recover", "Loaded", "Ammo", "Combat", "Round"]),
				},
				light: { // Enabled by optionLightCost
					cost: (i) => is.Int(i, {min: 0}),
				},
			},
			resistances: { // Enabled by optionResist
				damage: {
					base: { // Enabled by optionResistBaseDamage
						slash: {
							mode: (s) => is(s).In(["None", "Add", "Replace"]),
							hp: (i) => is.Int(i, (this.mode == "Replace") ? {min: 0} : {}),
							st: (i) => is.Int(i, (this.mode == "Replace") ? {min: 0} : {}),
						},
						pierce: {
							mode: (s) => is(s).In(["None", "Add", "Replace"]),
							hp: (i) => is.Int(i, (this.mode == "Replace") ? {min: 0} : {}),
							st: (i) => is.Int(i, (this.mode == "Replace") ? {min: 0} : {}),
						},
						blunt: {
							mode: (s) => is(s).In(["None", "Add", "Replace"]),
							hp: (i) => is.Int(i, (this.mode == "Replace") ? {min: 0} : {}),
							st: (i) => is.Int(i, (this.mode == "Replace") ? {min: 0} : {}),
						},
					},
					flat: { // Enabled by optionResistFlatDamage
						slash: {
							mode: (s) => is(s).In(["None", "Add", "Replace"]),
							hp: (i) => is.Int(i),
							st: (i) => is.Int(i),
						},
						pierce: {
							mode: (s) => is(s).In(["None", "Add", "Replace"]),
							hp: (i) => is.Int(i),
							st: (i) => is.Int(i),
						},
						blunt: {
							mode: (s) => is(s).In(["None", "Add", "Replace"]),
							hp: (i) => is.Int(i),
							st: (i) => is.Int(i),
						},
					},
				},
				ailments: { // Enabled by optionResistAilments
					default: {
						Burn: (i) => is.Int(i),
						Bleed: (i) => is.Int(i),
					},
					custom: {
						ailName: (i, v) => is.Values(v, "ailCustomResistanceNum").Int(i), // Needs some work. Should set key=ailName and value=ailCustomResistanceNum
						// "*": () => (this?.values?.ailName && is.Int(this?.values?.ailCustomResistanceNum)) ? {values.ailName, values.ailResistanceNum} : false,
						// Would here try format.valid("*") if format.valid(key) fails. If a validator returns an object o, loop over o keys and values and set this[key] = value
						// This wouldn't help with updating already existing values however... You could just say that if no validator exists anything goes? 
					},
				},
			},
			mystery: { // Enabled by optionMystery
				activation: (s) => is(s).In(["None", "AlwaysActive", "HalfHealth", "OnStagger", "EnemyDefeat", "AllyDefeat"]),
			},
			tags: { // Enabled by optionTags
				gives: {},
				requires: {}, // See custom resistances above. Needs a similar solution
			},
			style: { // Enabled by optionCustomStyle
				icon: { // Enabled by optionIcon
					source: (s) => is.String(s), // Is either a http image or a default icon name. Otherwise a question mark icon is displayed
				},
				color: (v) => is(v).In(["Red", "Blue", "Green", "Purple", "Orange", "Black"]),
				accent: (v) => is(v).In(["None", "Red", "Blue", "Green", "Purple", "Orange", "Black"]),
			},
			ui: { // Enabled by optionCustomUI
				damagetype: (b) => is.Bool(b), // The UI element has a custom event handler to update the damage type of the first roll format
				range: (b) => is.Bool(b), // The UI element has a custom event handler to toggle optionUses
				special: (b) => is.Bool(b),
				half: (b) => is.Bool(b), // Ignored when possessing 2+ roll formats, ui.special or damage resistances. This is handled by CSS
			},
			card: {}, // Enabled by optionCardCombat
			autoscript: (s) => is.String(s),
		},

		// Contains format data for all attribute names of an item. Used for inputing and outputing attribute data
		style: {
			equip: {
				slots: {option: "EquipSlots", prefix: "slot"},
			},
			rollformats: {
				option: "RollFormat",
				repeating: {
					section: "rollformats",
					editor: {type: "id"},
					sheet: {type: "index"},
					export: {alias: "rollFormats"},
				},
				array: {
					prefix: "roll",
					action: {option: "RollAction", prefix: "rollAction"},
					reaction: {option: "RollReaction", prefix: "rollReaction"},
					uses: {option: "RollUses", prefix: "rollUses"},
					store: {option: "StoreRoll", prefix: "store"},
				},
			},
			usable: {
				option: "Usable",
				action: {option: "UsableAction", prefix: "usableAction"},
				reaction: {option: "UsableReaction", prefix: "usableReaction"},
				uses: {option: "UsableUses", prefix: "usableUses"}
			},
			linked: {option: "Linked", prefix: "linked"},
			limited: {
				option: "Limited",
				uses: {option: "Uses", prefix: "uses"},
				light: {option: "LightCost", prefix: "light"},
			},
			resistances: {
				option: "Resist",
				damage: {
					base: {
						option: "ResistBaseDamage",
						slash: {prefix: "slashBase"},
						pierce: {prefix: "pierceBase"},
						blunt: {prefix: "bluntBase"},
					},
					flat: {
						option: "ResistFlatDamage",
						slash: {prefix: "slashFlat"},
						pierce: {prefix: "pierceFlat"},
						blunt: {prefix: "bluntFlat"},
					}
				},
				ailments: {
					option: "ResistAilments",
					default: {suffix: "Resist"},
					custom: {
						suffix: "Resist",
						repeating: {
							section: "ailments",
							editor: {
								type: "props",
								key: "ailName",
								value: "itemEditCustomResistanceNum",
							},
							sheet: false,
							export: {alias: "customResist"},
						}
					},
				},
			},
			mystery: {option: "Mystery", prefix: "mystery"},
			tags: {
				option: "Tags",
				gives: {prefix: "tag"},
				requires: {prefix: "tag"},
			},
			style: {
				option: "CustomStyle",
				icon: {option: "Icon", prefix: "icon"},
			},
			ui: {option: "CustomUI", suffix: "UI"},
			card: {option: "CardCombat", prefix: "card"},
		},

		// Data about repeating sections used by items
		sections: {
			sheet: ["weapons", "outfits", "augments", "tools", "skills", "special", "effects"],
			editor: ["rollformats", "ailments"],
		}
	}
}


/* The itemList handles all interactions with the repeating inventory system */
/* To be used the itemList must be "accessed" using itemList.access(mode). For more details see access(), beginAccess(), initialize() and endAccess() */
class itemListHandler {
	#accessStack;
	#charID;
	#event;
	
	constructor(itemList) {
		this.#accessStack = itemList?.accessStack || []
		this.#charID = false;
		this.#event = {keys: {}};
		this.itemList = {}
		this.outputValues = itemList?.outputValues || {}
		
		/* Handles interactions with the item editor */
		/* itemList.editor.open() and .close() are roughly equivalent to openEditor() and closeEditor() for AutoScripts */
		this.editor = {
			target: false,
			IDs: {},
			itemList: this,
		
			open(itemId) {
				if (this.target) { this.close(); }
				this.target = itemId;
				
				console.log("Editing item:", this.itemList[itemId]);
				Object.assign(this.itemList.outputValues, {
					...this.itemList[itemId].output({includeDisabled:true}).editor,
					itemEditorTarget: itemId,
					itemEditorTargetName: this.itemList[itemId].name,
					itemEditor_display: "true",
				});
			},
		
			close() {
				this.IDs.rollformats.forEach(repid => {
					removeRepeatingRow("repeating_rollformats_" + repid);
				});

				Object.assign(this.itemList.outputValues, {
					itemEditorTarget: "",
					itemEditorTargetOld: this.target,
					itemEditorTargetName: "",
					itemEditor_display: "0",
				});
				this.target = false;
				// Later need to also set itemEditCustomAilmentResistance to it's default value of 0
			},
		};
	}

	/* The itemList accepts two modes of access: "read" and "write" */
	/*   In read mode item data in the itemList can be read but not modified. Multiple accesses can read the itemList simultaneously */
	/*   In write mode the itemList read and modified. While in write mode other accesses wait until the current access finishes */
	access(mode, options={forceInit:false}, callback=()=>{}) {
		this.#accessStack.push({mode: mode, charID: getActiveCharacterId()});
		console.log("Added new access: ", [...this.#accessStack]);

		let newAccess = this.#accessStack.at(-1);
		newAccess.callback = callback;
		if (!callback.toString().includes(".endAccess")) {
			console.warn(`itemList: ${mode} access was not ended. Adding automatic endAccess`);
			newAccess.callback = () => {callback(); this.endAccess();}
		}

		if (this.#accessStack.length > 1 && mode == "write" || (mode == "read" && this.#accessStack.some(access => access.mode == "write"))) {
			console.log("New " + mode + " access will wait until a previous write access ends");
		} else {
			this.#beginAccess(newAccess, options);
		}
	}

	/* When first accessed the itemList is initialized with item data from the sheet */
	/* Afterwards the itemList preserves the item data in memory, removing the need to use getAttrs() and getSectionIds() */
	/* The itemList is re-initialized when a new character sheet is accessed, or when the webpage is reloaded */
	#beginAccess(access, options={}) {
		access.active = true;

		if (this.#charID == access.charID && !options.forceInit) {
			access.callback();
		} else if (length(this.outputValues) > 0) {
			setActiveCharacterId(this.#charID);
			setAttrs(this.outputValues, {}, () => {
				setActiveCharacterId(access.CharID);
				this.#initialize(access);
			});
		} else {
			this.#initialize(access);
		}
	}

	/* Once accessed, items in the sheet can be added, deleted, read or modified using standard JS object accessors */
	/* Input values are validated. Ex. itemList.rollformats[0].type = "Magic" would not work, as the value is not a valid rollformat type */
	/* For more details on the itemList format, see itemNode.format */
	#initialize(access) {
		this.#charID = access.charID;
		let self = this;

		getSectionIDs("ailments", function(ailmentIDs) {
			getSectionIDs("rollformats", function(rollformatIDs) {
				self.editor.IDs = {rollformats: rollformatIDs, ailments: ailmentIDs};
				let itemSections = itemNode.format.sections.sheet;

				function getItems(callback=()=>{}) {
					let section = itemSections.pop();
					getSectionIDs(section, function(itemIds) {
						itemIds.forEach(itemId => {
							self.#add(section.slice(0, -1), {id: itemId});
						});
						if (itemSections.length == 0) {
							callback()
						} else {
							getItems(callback);
						}
					})
				}

				getItems(() => {
					getAttrs([...self.keys, "itemEditorTarget"], function(values) {
						self.editor.target = values.itemEditorTarget || false;
						if (self.editor.target) self.editor.target.toLowerCase();
						delete values.itemEditorTarget;
						
						console.log([...self.keys, "itemEditorTarget"]);
						console.log(values);

						self.#input(values);
						access.callback();
					});
				});
			});
		});
	}

	/* All accesses should end in itemList.endAccess(). This is automatically added to the callback by access() */
	/* If another access remains in the access stack it's immediately granted access to the current itemList */
	/* Once all accesses have finished the repeating inventory and item editor are automatically updated to match the itemList */
	endAccess() {
		this.#accessStack.shift();
		console.log("Removed access: ", [...this.#accessStack]);
		
		let newAccess = this.#accessStack[0];
		if (newAccess) {
			if (!newAccess.active) {
				console.log("Beginning new " + newAccess.mode + " access from stack");
				this.#beginAccess(newAccess);
				
				if (newAccess.mode == "read") {
					for (let i = 1; i < this.#accessStack.length-1; i++) {
						newAccess = this.#accessStack[i];
						if (newAccess.charID == this.#charID && newAccess.mode == "read") {
							console.log("Allowing a concurrent read access from the stack");
							this.#beginAccess(newAccess);
						} else {
							break;
						}
					}
				}
			}
		} else {
			console.log("All accesses finished. Applying output values:", this.outputValues);
			setAttrs({"itemList": this.export(), ...this.outputValues});
			this.outputValues = {}
		}
	}

	// Helper functions used during the access process
	get #accessMode() {
		return this.#accessStack[0]?.mode;
	}
	set #accessMode(mode) {
		if (this.#accessStack.length > 0) {
			this.#accessStack[0].mode = mode;
		}
	}


	// Items in the itemList are accessed through an itemId
	// "itemList.IDs()" returns the itemId of all items in the itemList, ordered in the same order they're displayed in the sheet
	get IDs() {
		//  - Still need to order the indexes in the same order as they're displayed in the sheet. Requires some getSectionIDsOrdered shenanigans
		return Object.keys(this.itemList);
	}

	// "itemList.items" returns every item in the itemList in the order they're displayed in the sheet
	// "itemList[itemId]" or "itemList.item(index)" can be used to retrieve an item based on its id or index in the itemList
	get items() {
		return this.itemList;
	}
	item(index=0) {
		return this[this.IDs.at(index < this.IDs.length ? index : -1)];
	}

	// Most every property in the itemList is linked to an equivant attribute in the repeating inventory and/or item editor
	// "itemList.keys" returns an array of every attribute key of each item in the itemList
	get keys() {
		return this.IDs.flatMap(itemId => Object.values(this[itemId].keys())).flat();
	}

	// In addition to standard JS set accessor, the itemList can be modified using attribute values
	// "itemList.input(values)" is equivalent to and used in the exact same way as "setAttrs(values)"
	input(values, options={}) {
		if (this.#accessMode == "write") {
			let inputData = this.#sortItemData(values); // Seperate editor and sheet data if it isn't already sorted

			let inputIDs = {};
			for (const key of Object.keys(inputData.sheet)) {

				// If sheet values are provided for an itemId that doesn't exist, create a new item and assign the values to it
				let [section, repid, repkey] = key.split("_").slice(1);
				if (!this.IDs.includes(repid)) {
					this.add(section.slice(0, -1), repid);
				}

				if (!inputIDs[repid]) {
					this[repid].input(inputData, options);
					inputIDs[repid] = true;
				}
			}

			if (length(inputData.editor) > 0 && this.editor.target && !inputIDs[this.editor.target]) {
				this[this.editor.target].input(inputData, options);
			}

			// Returns any unused values
			return ((length(inputData.editor) + length(inputData.sheet)) == 0) || inputData;
		} else {
			this.#writeError("input");
		}
	}
	#input(inputData, options={}) { // Internal only input
		let oldAccess = this.#accessMode;
		this.#accessMode = "write";
		this.input(inputData, options);
		this.#accessMode = oldAccess;
	}

	// In addition to standard JS get accessor, values from the itemList can be output as attribute values
	// "itemList.output()" is equivalent to "getAttrs(attrs)", except values for both the sheet and item editor are returned
	// "itemList.output().source" with source = "sheet" or "editor" may be used to only retrieve one type of values
	output(options={}) {
		return Object.values(this.items).reduce((output, item) => {
			let itemOutput = item.output(options);
			Object.assign(output.editor, itemOutput.editor);
			Object.assign(output.sheet, itemOutput.sheet);
			return output;
		}, {editor: {}, sheet: {}});
	}

	// Item data used by input/output is sorted as {sheet: {values}, editor: {values}}
	// Any values (ex. from getAttrs()) that isn't sorted in this format is automatically sorted before use
	#sortItemData(rawData) {
		if (rawData.sheet && rawData.editor) {
			return rawData;
		} else {
			let sortedData = {sheet: rawData, editor: {}}
			for (const attr of Object.keys(rawData)) {
				if (!attr.startsWith("repeating") || itemNode.format.sections.editor.some(source => attr.startsWith(`repeating_${source}_`))) {
					if (this.editor.target) {
						sortedData.editor[attr] = sortedData.sheet[attr];
					}
					delete sortedData.sheet[attr];
				}
			}
			return sortedData;
		}
	}

	// Adds one or more new items to the itemList. Accepts an itemList object or an item type (ex. "Weapon". Case insensitive)
	// If an item type is provided a new item will be crated with that standard options and values of its type (see itemNode.format.defaults)
	// "itemList.add("Rollformat")" can alternatively be used to add a new rollformat in the editor
	add(inputData, options={id:false, defaults:undefined}) {
		if (this.#accessMode == "write") {
			console.log("Adding new item(s):", inputData);
			
			// Add items from another itemList
			if (typeof(inputData) == "object" && length(inputData) > 0) {
				if (inputData.itemList) { inputData = inputData.itemList; }

				// Adds one or more new items to the itemList
				for (const [id, data] of Object.entries(inputData)) {
					this.items[id] = new itemNode(data.type, id, {base: data, default:false});
					this.#addAccessors(id);
					Object.assign(this.outputValues, this.items[id].output().sheet);
				}
			}

			// Add item by type, or add a rollformat
			else if (is(capitalize(inputData)).In([...Object.keys(itemNode.format.defaults), "Rollformat"])) {
				let newid = options.id || generateRowID().toLowerCase();
				
				if (inputData == "Rollformat") {
					if (this.editor.target) {
						this.editor.IDs.rollformats.push(newid);
						this.items[this.editor.target].add("Rollformat");
						let rollFormatValues = this.items[this.editor.target].rollformats[this.editor.IDs.rollformats.length - 1].output();
						Object.assign(this.outputValues, rollFormatValues.editor, rollFormatValues.sheet);
					}
					this.outputValues.rollFormatAddToggle = "" + (this.editor.IDs.rollformats.length >= 5); // A maximum of five rollformats are accepted
				} else {
					this.items[newid] = new itemNode(capitalize(inputData), newid); // Adds a new item to the itemList
					this.#addAccessors(newid);
					Object.assign(this.outputValues, this.items[newid].output().sheet);
				}
			}
		} else {
			this.#writeError("add");
		}
		return this;
	}
	#add(inputData, options={}) { // Internal only add
		let oldAccess = this.#accessMode;
		this.#accessMode = "write";
		this.add(inputData, options);
		this.#accessMode = oldAccess;
	}

	// Deletes one or more items to the itemList
	// Accepts one itemId as a string, or two or more itemId as either an array, a number of object keys or as multiple arguments
	delete(itemId) {
		if (this.#accessMode == "write") {
			itemId = itemId.toLowerCase();

			console.log("Deleting item:", itemId);
			delete this.items[itemId]
			this.#deleteAccessors(itemId);

			// Check if any items link to the item
			// If yes, ask if those items should be unlinked or deleted. If possible, list the linked items in the query

			return this;
		} else {
			this.#writeError("delete");
		}
	}

	// The itemList has itemId accessors to simplyfy accessing the itemList. Instead of writing itemList.itemList[id], itemList[id] may be used
	// Must be added or deleted together with their associated itemId
	#addAccessors(itemId) {
		Object.defineProperty(this, itemId, {
			get() {
				return this.itemList[itemId]
			},
			set(value) {
				if (this.#accessMode == "write") {
					this.itemList[itemId] = value;
				} else {
					this.#writeError("set");
				}
			},
			configurable: true,
		});
	}
	#deleteAccessors(itemId) {
		delete this[itemId];
	}

	// Event listeners for items may use "itemList.event()" to create a string of event keys
	// "itemList.event(type, source)" returns a string of event keys of a specific type (ex. "change") for a specific source ("editor" or "sheet")
	// A predicate may also be provided to filter which event keys are returned (ex. itemList.event("change", "editor", key => key.includes("option"))
	// ".event('reorder')" and ".event(type, key)" may alternatively be used to return all reorder events or all events for a specific attribute key
	event(type, source, filter) {
		if (["editor", "sheet"].includes(source)) {
			if (!this.#event.keys[source]) {
				let eventKeys = new itemNode("Effect").keys(type)[source];
				if (source == "sheet") {
					eventKeys = eventKeys.reduce((rows, eventkey) => {
						return rows.concat(itemNode.format.sections.sheet.map(section => {
							return (section != "effects") ? eventkey.replace("effects", section) : eventkey;
						}));
					}, []);
				}
				this.#event.keys[source] = eventKeys;
			}
			return (filter) ? this.#event.keys[source].filter(filter).join(" ")
							: this.#event.keys[source].join(" ");
		} else {
			switch (source) {
				case "reorder": return Object.keys(itemNode.format.defaults).reduce((rows, item) => rows += ` change:_reporder:${item}s`, "");
				default: return Object.keys(itemNode.format.defaults).reduce((rows, item) => rows += ` ${type}:repeating_${item}s${(source) ? `:${source}` : ""}`, "");
			}
		}
	}



	/* All code beyond this point is unfinished */

	// Imports one or more items from an export script
	// The items are added to the current itemList by default. "Replace" mode may be used to overwrite the itemList
	import(itemScript, mode="Add") {
		if (this.#accessMode == "write") {
			// - Still need to send a querry to the player confirming they want to overwrite the itemList
			this.itemList = JSON.parse(itemScript);
		} else {
			this.#writeError("import");
		}

		// If the item is linked, do not create it if the linked item doesn't exist
	}

	// Exports an item with a certain id, or the entire current itemList if no id is provided
	// If chatbuttons is enabled, post a chat button to import the items
	export(itemId, chatbuttons=false) {
		if (itemId) {
			return JSON.stringify(this[itemId]);
		} else {
			return JSON.stringify(this.itemList);
		}

		// If exportLinked is true, use recursion to also include any linked items (and items linked to those items etc.)
		// May cause issues if used on a filtered list. Some linked items may not be in the list. Have all itemLists give a origItemList to their children?
	}

	// As export, but generates share messages for each item
	// If chatbuttons is enabled, add chat buttons to import either individual items or every item
	share(itemId, chatbuttons=false) {
		return this; // Allows chaining
	}

	// Takes
	handleEvent(type, info, options={}) {
		// Check if the new value matches the format
	}

	// Returns a subset of the itemList. Allows other handler methods to affect only part of the itemList
	filter(predicate, useOrigList=false) {
		return this.IDs
			.filter(id => predicate(this[id]))
			.reduce((acc, id) => acc.#add({[id]: this[id]}), new itemListHandler(this)); // Need to make this use the same access as the base itemList
	}

	/* Some pre-made filters for commonly accessed values */
	get equipped() {
		return this.filter(item => item.equip?.equipped);
	}
	linked(itemId, recursive=true) {
		let linkedItems = {};
		if (typeof(itemId) == "string") {
			linkedItems = this.filter(item => item.linked?.id == itemId, !recursive);
		}
		else if (typeof(itemId) == "object") {
			if (!Array.isArray(itemId)) {
				itemId = Object.keys(itemId);
			}
			itemId.forEach(id => {
				Object.assign(linkedItems, this.linked(id, false));
			});
		}
		if (recursive) {
			let chainLinkedItems = this.filter(item => linkedItems.IDs.includes(item.linked?.id) && !(item in linkedItems)); // May not work
			if (length(chainLinkedItems) > 0) {
				Object.assign(linkedItems, this.linked(chainLinkedItems.IDs));
			}
		}
		return linkedItems;
	}


	/* Assorted */
	#writeError(method) {
		throw new Error(`Attempted to use method "${method}" in itemList without accessing in write mode`)
	}
}

/* The actual itemListHandler instance that all other code interacts with */
let itemList = new itemListHandler();



/* Initialize itemList when opening a sheet */
on("sheet:opened", function(info) {
	itemList.access("read", {}, () => { console.log(itemList) });
})

/* Item - Open editor */
on(itemList.event("clicked", "edit-item"), function(info) {
	let itemId = info.triggerName.split("_")[2];
	itemList.access("read", {}, () => {
		itemList.editor.open(itemId);
	});
});

/* Item - Close editor */
on("clicked:closeItemEdit", function(info) {
	itemList.access("read", {}, () => {
		itemList.editor.close();
	});
});

/* Item - Sync editor changes */
on(itemList.event("change", "editor"), function(info) {
	console.log(info);
	if (info.newValue && info.newValue != info.previousValue) {
		itemList.access("write", {}, () => {
			itemList.input({[info.sourceAttribute]: info.newValue}, {modify: "sheet"});
		});
	}
});

/* Item - Sync sheet changes */
on(itemList.event("change", "sheet"), function(info) {
	console.log(info);
	if (info.newValue && info.newValue != info.previousValue) {
		itemList.access("write", {}, () => {
			itemList.input({[info.sourceAttribute]: info.newValue}, {modify: "editor"});
		});
	}
});

/* Add new item or rollformat */
on("clicked:addItem", function(info) {
	let itemtype = capitalize(info.htmlAttributes.id.split("_")[1]);
	itemList.access("write", {}, () => { itemList.add(itemtype).endAccess(); });
});

/* Delete item or rollformat */
on("remove:repeating_rollformats " + itemList.event("remove"), function(info) {
	console.log(info);
	let [section, repid] = info.sourceAttribute.split("_").slice(1);
	itemList.access("write", {}, () => {
		if (section == "rollformats") {
			itemList[itemList.editor.target].delete("Rollformat", repid);
		} else {
			itemList.delete(repid);
		}
	});
});
























// Opening the item editor:
// x 1. Event call by _edit-item. Extract the item id and name
//   2. Run openEditor("item", itemId, itemName);  
//   3. Need itemEditorTarget, itemEditorTargetOld and itemEditorTargetName
//     3.1. Set itemEditorTargetOld = itemList.editor.target || ""
//     3.2. Set itemEditorTarget = itemId. Also set itemList.editor.target = itemId
//     3.3. Set itemEditorTargetName = newTargetName
//   4. Access the itemList and do Object.assign(itemList.outputValues, itemList.output.editor)
//   5. setAttrs() the values collected in step 3

// What could be changed here?
// - targetOld is not needed for the item editor
// - you only need to use getAttrs() to get the item's name
// This could probably be an itemList method instead... like itemList.edit(id)




/*
on(itemEvent("clicked", "edit-item"), function(info) {
	
	
	getAttrs([itemName], function(values) {
		openEditor("item", itemData, values[itemName]);
	});
});
*/


























on("clicked:testA", function(info) {
	console.log("Clicked button A");

	itemList.access("write", {editor: true}, () => { // input()

		let itemId = generateRowID().toLowerCase();

		console.log(itemList.event("change", "editor", (attr => attr.includes("option"))))

		console.log(itemList.items)

		itemList.item(0).type = "Augment";
		itemList.item(0).limited.uses.action = false;

		//itemList[itemList.IDs[0]].rollformats["0"].type = "Custom";
		//itemList[itemList.IDs[0]].rollformats["0"].count = "7";
		//itemList[itemList.IDs[0]].rollformats["0"].resource.reaction.type = "Block";

		console.log(itemList.items)
	});
});



on("clicked:testB", function(info) {
	console.log("Clicked button B");

	itemList.access("write", {}, () => {
		console.log(itemList)
		let filteredItemList = itemList.filter(item => item.type == "Tool");
		console.log(filteredItemList);
		console.log(filteredItemList.export());
		console.log(filteredItemList.IDs, filteredItemList[filteredItemList.IDs[0]])
		filteredItemList[filteredItemList.IDs[0]].type = "Weapon";
		console.log(itemList)
		itemList.access("read", {}, () => {
			console.log("Began second access");
			itemList.access("write", {}, () => {
				console.log("Began third access");
			});
		});
	});
});

const test = new Proxy(itemList, {
	get: function (target, prop, receiver) {
		if (prop in target) {
			return target[prop];
		}
	},

	deleteProperty(target, prop) {
		if (prop in target) {
			delete target[prop];
			console.log(`property removed: ${prop}`);
			// Expected output: "property removed: texture"
		}
	},
});

















/* Planned item functionality */

function updateItemList() {
	// As updateAilmentList, but for items. Runs whenever an item is updated or deleted
	
	// Change events include the new attribute value, so you may be able to modify individual attributes instead of updating everything
	// If yes, consider changing the ailmentList over to using this method as well
	// You'd have to find some way to only setAttrs() the new list once and not every time a value changes (Causes a lot of extra server calls when updating many attributes at once)
}

function convertInventory() {
	// Converts all the old items into the new inventory format
	// Runs import(itemScript, "Add") once the data is prepared
}

// Add a on:startup event that adds some empty slots when a sheet is first opened
// If at least one old inventory item exists, use convertInventory() first, then add any unused slots in the old inventory

// Consider adding the getSectionIDsOrdered function from the wiki
// You'd have to rework it to work for multiple repeating sections at the same time










/* LEGACY ITEM EDITOR CODE */

/*--- Repeating inventory events ---*/
function itemEvent(event, element) {
	switch (element) {
		case "editor": return "Currently in development"; // Currently doesn't return. Need to sync the itemList and editor
		case "reorder": return Object.keys(itemNode.format.defaults).reduce((rows, item) => rows += ` change:_reporder:${item}s`, "");
		default: return Object.keys(itemNode.format.defaults).reduce((rows, item) => rows += ` ${event}:repeating_${item}s${(element) ? `:${element}` : ""}`, "");
	}
}



/* Item editor sync changes */
on(itemEvent("change", "editor"), function(info) { // - Doesn't work. Will be updated after adding the new item data parsers
	itemList.access("write", {}, () => {
		let attr = info.sourceAttribute; // ????

		if (attr.includes("repeating_")) {
			let [section, repid, repkey] = info.sourceAttribute.split("_").slice(1);
			let repindex = itemList.editor.IDs[section].indexOf(repid);
			switch (section) {
				case "rollformats": itemList.rollformats[repindex][repkey];
				case "ailments": break;
			}
		}
	});
});


/* Remove repeating item or rollformat */
/*
on("remove:repeating_rollformats" + itemEvent("remove"), function(info) {
	// - Change this over to using the itemList

	let itemType = info.sourceAttribute.split("_")[1];
	let itemId = info.sourceAttribute.split("_")[2];

	if (itemType == "rollformats") {
		saveEditor("item", itemEditorAttrs);
		getSectionIDs("repeating_rollformats", idarray => {
			console.log(idarray);
			if (idarray.length < 5) {
				setAttrs({"rollFormatAddToggle": "0"});
			}
		});
	}

	console.log(`${itemType} section - removed item: ${itemId}`);
});
*/

/* Repeating item share button */
on(itemEvent("clicked", "shareItem"), function(info) {
	console.log(info);
});



/* Reorder repeating items */
on(itemEvent("reorder"), function(info) {
	let itemType = info.sourceAttribute.split("_")[3];

	let newOrder = info.newValue; // Handle if this is undefined. Unsure why it happens

	// Update the item order in the itemList

	console.log(`${itemType} section - changed item order to: ${newOrder}`);
});


/* Clear equipment and skills search bar */
on("clicked:clearSearchBar", function() {
	setAttrs({"itemSearchInput":""});
	// - Also needs to clear the advanced search options
});
/*--- Repeating inventory end ---*/



/*--- AutoScript functions ---*/

console.log("clicked:autoScriptEdit" + itemEvent("clicked", "edit-autoscript")
  + ["roll", "store"].reduce((acc, type) => acc += ` clicked:repeating_rollformats:edit-${type}autoscript`, ""))

/* AutoScript editor open button */
on("clicked:autoScriptEdit" + itemEvent("clicked", "edit-autoscript")
  + ["roll", "store"].reduce((acc, type) => acc += ` clicked:repeating_rollformats:edit-${type}autoscript`, ""), function(info) {	
	getAttrs(["autoScriptEditorTargetOld"], function(values) {
		let target = (info.htmlAttributes.id == "autoScriptReturn") ? values.autoScriptEditorTargetOld
				   : (info.sourceAttribute?.includes("repeating")) ? info.sourceAttribute.replace("_edit-", "_")
				   : info.htmlAttributes.id;

		if (target.includes("repeating")) {
			let targetNameAttr = (target.includes("rollformats")) ? "itemEditorTargetName" : target.replace("_autoscript", "_name");

			getAttrs([targetNameAttr], function(values) {
				let targetName = values[targetNameAttr]
				if (target.endsWith("rollautoscript")) {
					targetName += ` (${getTranslationByKeyCustom("Roll format", "item-rollformat")})`;
				}
				else if (target.endsWith("storeautoscript")) {
					targetName += ` (${getTranslationByKeyCustom("Recycle", "item-roll-recycle")})`;
				}

				openEditor("autoScript", target, targetName);
			});
		} else {
			openEditor("autoScript", target);
		}
	});
});

/* AutoScript editor close button */
on("clicked:closeAutoScriptEdit", function(info) {
	console.log(info);
	saveEditor("autoScript", {}, () => {
		closeEditor("autoScript");
	});
});

/* AutoScript editor sync changes */
on("change:autoScriptEditorInput", function(info) {
	console.log(info);
	saveEditor("autoScript");
});

/* AutoScript editor reset styling or aliases to default */
on("clicked:autoScriptDefault", async function(info) {
	let type = (info.htmlAttributes.id.includes("Styling")) ? "styling" : "alias";
	
	let queryResults = await sendQuery(["userConfirmation",
		getTranslationByKeyCustom(`Are you certain you want to reset back to the default AutoEffect ${type} settings? This action can not be reversed`, `query-reset-${type}`), {
			[getTranslationByKeyCustom("No","query-no")]:"false",
			[getTranslationByKeyCustom("Yes","query-yes")]:"true"
		}
	]);

	if (queryResults.userConfirmation == "true") {
		loadDefaultAutoScriptRules(capitalize(type));
	}
});
function loadDefaultAutoScriptRules(type) {
	getAttrs(["autoScriptEditorTarget"], function(values) {
		let settingDefault = (type == "Styling") ? stylingDefault : aliasDefault;
		let editorTarget = values.autoScriptEditorTarget;
		
		let output = {[`autoScript${type}`]: settingDefault}
		
		// Only modifies the editor input if the aliases/styling is currently open in the editor
		// Avoids issues with styling rules being applied to other AutoScripts
		if (editorTarget == `autoScript${type}`) {
			output.autoScriptEditorInput = settingDefault;
		}
		
		setAttrs(output);
	});
}

/* Executes a conditional button. Hides the button if at least one check fails */
/* Also hides the button if a Consume check would fail after using the button again */
on("clicked:repeating_conditionalButtons:activate", function(info) {
	let buttonid = info.sourceAttribute.split("_")[2];
	let buttonAutoScript = "";
	let buttonName = "";

	getAttrs([`repeating_conditionalButtons_${buttonid}_buttonAutoScript`, `repeating_conditionalButtons_${buttonid}_buttonName`], function(values) {
	buttonAutoScript = values[`repeating_conditionalButtons_${buttonid}_buttonAutoScript`];
	buttonName = values[`repeating_conditionalButtons_${buttonid}_buttonName`];

	AutoScriptMain(buttonAutoScript, "ConditionalButton", "false", "true", {}, function(returnValues) {
		if (returnValues.checkResult != "success") {
			removeRepeatingRow("repeating_conditionalButtons_" + buttonid)
		}
	}, buttonName);
	});
});

/* Main function for using AutoScripts. Called by actions through on click events */
/* inputAutoScript: AutoScript provided by the action. Can be an empty string */
/* trigger: An array of valid AutoEffect triggers or "None". Selects which type of AutoEffects to collect and append to an AutoScript */
/* collect: If the function should collect augment/outfit/etc. AutoEffects or not */
/* sendMessage: If true, the function print a standard chat message */
/* overrideList: One or more override values for the execution process */
/* callback: Function to be run on returnValues. Defaults to an empty function */
/* messageHeaderTitle: Title of the standard chat message printed by the function */
async function AutoScriptMain(inputAutoScript="", triggerType="None", collect="true", sendMessage="true", overrideList={}, callback=()=>{}, messageHeaderTitle=getTranslationByKeyCustom("AutoEffects", "autoeffect-title")) {
	
	/* If using generic token mode, switches to the correct token before applying incoming AutoEffects */
	let tokenId = overrideList.tokenId || "";
	changeActiveToken(tokenId, () => {

	/* Gets all AutoScript sources */
	let autoScriptList = ["augment", "outfit", "ego", "special1", "special2"]
	for (let i = 1; i <= 4; i++) { autoScriptList.push(`weapon${i}`, `tool${i}`) }
	for (let i = 1; i <= 6; i++) { autoScriptList.push(`skill${i}`, `egoSkill${i}`) }
	autoScriptList = autoScriptList.map(prefix => prefix + "AutoScript");

	getSectionIDs("conditionalButtons", function(idarray) {
	let buttonAutoScriptList = idarray.map(id => [`repeating_conditionalButtons_${id}_buttonName`, `repeating_conditionalButtons_${id}_buttonAutoScript`]);


	/* --- Prepare input values --- */

	getAttrs([...autoScriptList, ...buttonAutoScriptList, "isFirstRound", "autoScriptStyling", "autoScriptAlias",
	"settingMuteMessage", "settingWhisperRolls", "settingWhisperTarget", "settingLimbusStyle", "settingHideNextTurn",
	"settingCollapseAutoEffectSections", "settingHideConditionalButtonReminder", "settingTargeting", //"settingTargetMode",
	"HP", "HP_max", "StagRes", "StagRes_max", "SP", "SP_max", "Light", "Light_max", "THP_Sources", "TST_Sources",
	"Instinct", "Charm", "Wisdom", "Insight", "Justice", "Temperance",
	"baseSpeed", "thisRoundSpeed", "nextRoundSpeed", "distortState", "egoActiveState", "egoType",
	"Action", "Action_max", "Reaction", "Reaction_max", "Counter", "Counter_max", "Block", "Block_max", "Evade", "Evade_max", "Action_base", "Reaction_base",
	"Light_Regen", "Light_Regen_max", "Light_Regen_base",
	"character_id", "character_name", "targetId", "targetName", "targetTokenId", "targetSettings"], async function(values) {

	let settingMuteMessage = values.settingMuteMessage;
	let settingWhisperRolls = values.settingWhisperRolls;
	let settingWhisperTarget = values.settingWhisperTarget;
	let settingLimbusStyle = values.settingLimbusStyle;
	let settingHideNextTurn = values.settingHideNextTurn;
	let settingCollapseSections = values.settingCollapseAutoEffectSections;
	let settingConditionalButtonReminder = values.settingHideConditionalButtonReminder;
	let settingTargeting = values.settingTargeting;

	let charId = values.character_id;
	let charName = values.character_name;
	let distortState = values.distortState;
	let egoActiveState = values.egoActiveState;
	let egoType = values.egoType;

	let targetId = values.targetId || "";
	let targetName = values.targetName || "";
	let targetTokenId = values.targetTokenId || "";
	let targetSettings = Data.unpackage(values.targetSettings || {});

	/* Values configurable by AutoEffects */
	/* valueLists are no longer used during execution (now handled by aeVars), but is still used during AutoScript parsing */
	let [HP, ST, SP, Light] = [parseInt(values.HP), parseInt(values.StagRes), parseInt(values.SP), parseInt(values.Light)];
	let [HP_max, ST_max, SP_max, Light_max] = [parseInt(values.HP_max), parseInt(values.StagRes_max), parseInt(values.SP_max), parseInt(values.Light_max)];
	let [baseSpeed, thisRoundSpeed, nextRoundSpeed] = [parseInt(values.baseSpeed), parseInt(values.thisRoundSpeed), parseInt(values.nextRoundSpeed)]
	let [action, reaction, counter, block, evade, light_regen] = [parseInt(values.Action), parseInt(values.Reaction), parseInt(values.Counter), parseInt(values.Block), parseInt(values.Evade), parseInt(values.Light_Regen)]
	let [action_max, reaction_max, counter_max, block_max, evade_max, light_regen_max] = [parseInt(values.Action_max), parseInt(values.Reaction_max), parseInt(values.Counter_max), parseInt(values.Block_max), parseInt(values.Evade_max), parseInt(values.Light_Regen_max)]
	
	if (triggerType.includes("Round start") || triggerType.includes("Combat start")) {
		[action_max, reaction_max, counter_max, block_max, evade_max] = [parseInt(values.Action_base), parseInt(values.Reaction_base), 0, 0, 0]
		action=action_max; reaction=reaction_max; counter=counter_max; block=block_max; evade=evade_max;
		if (triggerType.includes("Combat start")) {
			light_regen_max = parseInt(values.Light_Regen_base);
			light_regen = light_regen_max;
		}
	}
	
	let valueLists = {
		barList: {"HP":HP, "ST":ST, "SP":SP, "Light":Light, "THP":0, "TST":0 },
		barMaxList: {"HP_max":HP_max, "ST_max":ST_max, "SP_max":SP_max, "Light_max":Light_max},
		barDamageList: {"-HP":HP_max-HP, "-ST":ST_max-ST, "-SP":SP_max-SP, "-Light":Light_max-Light},
		speedList: {"baseSpeed":baseSpeed, "thisRoundSpeed":thisRoundSpeed, "nextRoundSpeed":nextRoundSpeed},
		resourceList: {"Action":action, "Reaction":reaction, "Counter":counter, "Block":block, "Evade":evade, "Light_Regen":light_regen},
		resourceMaxList: {"Action_max":action_max, "Reaction_max":reaction_max, "Counter_max":counter_max, "Block_max":block_max, "Evade_max":evade_max, "Light_Regen_max":light_regen_max},
	}

	let THP_Sources = (values.THP_Sources != "" && values.THP_Sources != "{}") ? JSON.parse(values.THP_Sources) : "";
	if (THP_Sources.AutoEffects) { valueLists.barList.THP = THP_Sources.AutoEffects[0]; }
	let TST_Sources = (values.TST_Sources != "" && values.TST_Sources != "{}") ? JSON.parse(values.TST_Sources) : "";
	if (TST_Sources.AutoEffects) { valueLists.barList.TST = TST_Sources.AutoEffects[0]; }
	
	/* Execution parameters and variables */
	let aeVars = { scaling:1, checkResult:"success" }				// Variables about the current AutoScript execution which should be available to players
	let aeType = "standard";										// If the current AutoEffect is "standard", "section" or "conditional"
	let aeConditional = "";											// The conditional of the currently executing AutoEffect. Used by the #Section option
	let messageValues = {}											// Holds data about the last executed AutoEffect. Used by CustomMessage

	/* Output storage */
	let output = {													// Stores all attribute values to be set by autoScriptMain
		...valueLists.resourceList,
		...valueLists.resourceMaxList
	}
	
	let returnValues = { checkResult:"success", message:"" }		// Stores all modifiers and action buttons that are returned to the calling function
	let outputLists = {												// Stores all output values that cannot be applied directly using setAttrs()
		challengeRollList: [],
		procList: []
	}
	let conditionalSectionList = {}
	let conditionalButtonList = {}
	let buttonList = {}
	let outputMessage = "";
	let errorMessageList = {}

	/* Assorted */
	let stylingList = {
		...parseAutoScriptStyling(stylingDefault),					// Default styling rules
		...parseAutoScriptStyling(values.autoScriptStyling) 		// Custom styling rules from the AutoScript editor
	}
	let defaultAliases = autoScriptToArray(aliasDefault, "aliases");
	let customAliases = autoScriptToArray(values.autoScriptAlias, "aliases");
	let aliasList = [...customAliases, ...defaultAliases, ...customAliases, 		// This structure means custom aliases are checked first before default ones, while
	].reduce((acc, alias) => Object.assign({[alias[0]]:alias[1], ...acc}), {});		//   still overwriting default aliases with matching custom aliases


	/* Get all ailments */
	exportAilmentList(overrideList, (ailmentList) => {
	valueLists.ailmentList = ailmentList;

	/* If targeting is in use, get target ailments and bars */
	updateTargetAttrLists(settingTargeting, charId, targetId, targetTokenId, targetSettings, settingLimbusStyle, (targetLists) => {
	valueLists = {...valueLists,
		targetAilmentList: (targetLists.targetAilmentList) ? Data.unpackage(targetLists.targetAilmentList) : {},
		targetBarList: targetLists.targetBarList || {},
		targetBarMaxList: targetLists.targetBarMaxList || {},
		targetBarDamageList: targetLists.targetBarDamageList || {}
	}

	/* Add legacy values to aeVars */
	Object.assign(aeVars, {
		...valueLists.barList, ...valueLists.barMaxList, ...valueLists.barDamageList, ...valueLists.resourceList, ...valueLists.resourceMaxList,
		...Object.entries({...valueLists.targetBarList, ...valueLists.targetBarMaxList, ...valueLists.targetBarDamageList})
			.reduce((acc, attr) => { return {...acc, [attr[0].replace(/([^-])/, "target$1")]:attr[1]} }, {}),
		...Object.entries(valueLists.ailmentList)
			.reduce((acc, attr) => { return {...acc, [attr[0]]:attr[1][1], [`${attr[0]}NextTurn`]:attr[1][2], [`${attr[0]}Immutable`]:attr[1][3], [`${attr[0]}Pause`]:attr[1][4]} }, {}),
		...Object.entries(valueLists.targetAilmentList)
			.reduce((acc, attr) => { return {...acc, [`target${attr[0]}`]:attr[1][1], [`target${attr[0]}NextTurn`]:attr[1][2], [`target${attr[0]}Immutable`]:attr[1][3], [`target${attr[0]}Pause`]:attr[1][4]} }, {})
	});
	/* Add new values to aeVars */
	Object.assign(aeVars, {
		...targetLists.targetStatVars,
		...targetLists.targetResourceVars,
		...statNames.reduce((acc, stat) => { return {...acc, [updateStatName(stat)]:parseInt(values[stat])} }, {}),
	});

	output = {...output, ...deleteMultiple(targetLists, 'targetAilmentList', 'targetBarList', 'targetBarDamageList', 'targetResourceVars', 'targetStatVars')}
	/* --- Prepare input values end --- */
	

	/* --- Parse AutoScripts --- */
	
	/* Appends one or more AutoScripts based on the trigger type */
	let autoScriptTriggers = [];
	let collectedAutoScripts = "";
	let buttonAutoScripts = "";
	if (collect == "true") {
		if (typeof triggerType == "string") { autoScriptTriggers.push(triggerType) }
		else {autoScriptTriggers.push(...triggerType) }
		if (triggerType != "None") {
			autoScriptTriggers.forEach(trigger => {
				switch (trigger) {
					case "Block": case "Evade": autoScriptTriggers.push("Defensive"); break;
					case "Combat start": autoScriptTriggers.push("Round start"); break;
					case "DamagedHP": case "DamagedST": case "DamagedSP": autoScriptTriggers.push("Damaged"); break;
				}
			});
		}
		if (!autoScriptTriggers.includes("Permanent")) {
			autoScriptTriggers.push("Permanent")
		}

		/* Collects all AutoScripts from existing conditional buttons */
		/* Adds back in the conditional for AutoEffects without a conditional */
		if (triggerType == "ConditionalButton") {
			buttonAutoScriptList.forEach(button => {
				inputAutoScript += button[1].replace(/(\([^]+?)(\))/, `$1, ${button[0]})`) + "(Reset)" + inputAutoScript;
			});
		}

		/* Collects all AutoScripts that use triggers */
		autoScriptList.forEach(source => {

			/* Do not collects AutoScripts from Mystery/Distortion items when not manifesting/distorting */
			if (source.includes("ego") && !(values.distortState == "true" || values.egoActiveState == "true")) {
				return;
			}

			/* Replaces any aliases in the AutoScript as they can contain triggers */
			let AutoScript = autoScriptApplyAliases(values[`${source}`], aliasList, "triggers", errorMessageList);

			/* Finds all substrings that begin with "[#" and end with "#]" */
			if ((/\[#(.+?)#\]/g).test(AutoScript)) {
				collectedAutoScripts += AutoScript.match(/\[#(.+?)#\]/g).reduce((acc, trigger) => `${acc}${trigger}`,'');
			}
		});
		collectedAutoScripts = autoScriptToArray(collectedAutoScripts, "triggers");
		
		/* Append any collected AutoScripts with a relevant trigger */
		collectedAutoScripts.forEach((trigger) => {
			
			/* Accept #First round triggers if it is currently the first round. Otherwise discard them */
			let firstRound = getTranslationByKeyCustom("#First round", "autoeffect-option-firstround")
			if (trigger[0].includes(firstRound) && values.isFirstRound == "true") { trigger[0] = trigger[0].replace(firstRound,"").trim(); }
	
			if (autoScriptTriggers.includes(getTriggerFromTranslation(trigger[0]))) {
				if (inputAutoScript != "") { inputAutoScript += "(Reset)"; }
				inputAutoScript += trigger[1];
			}
		});
	}

	/* Cancels execution if no AutoScripts were provided */
	if (inputAutoScript == "") { callback(returnValues); setAttrs(output); return; }

	/* Validates AutoEffect formats and returns an array of effects to be executed. Also returns any errors that were encountered during parsing */
	let ExecutionArray = parseAutoScript(inputAutoScript, valueLists, aliasList, aeVars, autoScriptTriggers, errorMessageList);
	
	/* --- Parse AutoScripts end --- */


	/* --- AutoEffect execution --- */
	ExecutionArray.forEach(AutoEffect => {
		console.log(AutoEffect)

		/* Stops execution if any errors were encountered while parsing or executing the AutoScript */
		if (length(errorMessageList) > 0) { return; }

		/* Handle conditional */
		/* Only the first conditional of each AutoEffect is used, while the rest are stored */
		if (AutoEffect.conditional && AutoEffect.conditional.name) {
			const [conditional, options] = [AutoEffect.conditional.name, AutoEffect.conditional.options];

			/* Reset if new conditional doesn't match previous one */
			if (conditional != aeConditional) { autoEffectReset(); }
			aeConditional = conditional;

			/* The primary conditional has the following options: */
			/*   section: Sorts the message created by the AutoEffect into a section with a name equal to the name of the condition */
			/*   ignorefailure: If the AutoEffect is a check that fails, the conditional button is not revealed. This option suppressed this behaviour */
			/*     Note: ignorefailure is now a standard option. The old conditional option can still be used for legacy support */
			/* If no options are used the effect is not executed and is instead stored in a conditional button */
			if (length(options) == 0) {
				aeType = "conditional";
				if (!conditionalButtonList[conditional]) { conditionalButtonList[conditional] = {} }
				modifyProp(conditionalButtonList[conditional], "AutoScript", autoEffectToString(AutoEffect.origAutoEffect));

				/* If AutoEffect is Require or Consume, do not display the button if the check will fail. Ignore this rule if #IgnoreFailure is used */
				if (["Require", "Consume"].includes(AutoEffect.name) && !options.ignoreFailure) {
					if (["failure", "no target"].includes(autoEffectCheck(AutoEffect).checkResult)) {
						conditionalButtonList[conditional].doNotDisplay = true;
					}
				}
			}
		} else {
			if (aeType != "standard") { autoEffectReset(); }
			aeType = "standard";
		}

		/* Execute effects */
		if (aeType != "conditional") {
			/* If using a math formula, calculate the result */
			if ((/[{}]/).test(AutoEffect.value)) {
				AutoEffect.value = parseMath(AutoEffect.value, aeVars, {strict:true}, errorMessageList);
			}

			/* Checks and Reset are always processed. Other AutoEffects are not processed if the last check failed */
			switch (AutoEffect.name) {
				case "Reset": autoEffectReset(AutoEffect); break;
				case "CustomMessage": autoEffectCustomMessage(AutoEffect, messageValues); break;
			}
			if (aeVars.checkResult.includes("success")) {
				autoEffectGetCount(AutoEffect); // Get the current count of ailments/bars/resources
				switch (AutoEffect.name) {
					case "Require": case "Consume": autoEffectCheck(AutoEffect); break;
					case "Gain": case "Inflict": case "Give": autoEffectAilment(AutoEffect); break;
					case "Set": case "Add": case "Multi": autoEffectBar(AutoEffect); break;
					case "DicePower": case "DiceMax": case "DiceCount": case "DiceAdv": autoEffectDice(AutoEffect); break;
					case "BaseDamage": case "FlatDamage": autoEffectDamage(AutoEffect); break;
					case "Proc": autoEffectProc(AutoEffect); break;
					case "Pause": autoEffectPause(AutoEffect); break;
					case "ChallengeRoll": autoEffectChallengeRoll(AutoEffect); break;
					case "Speed": autoEffectSpeed(AutoEffect); break;
				}
			}
		}
	});
	/* --- AutoEffect execution ends --- */



	/* --- Message handling --- */

	/* When encountering one or more errors, print an error message instead of the standard output buttons and messages */
	if (length(errorMessageList) > 0) {
		resetConditionals();
		
		/* Error message */
		outputMessage = "";
		for (const [errorType, errorMessage] of Object.entries(errorMessageList)) {
			outputMessage += autoEffectSection(errorType, errorMessage, settingCollapseSections, "icons", "exit", getColor("Red"));
		}

	} else {
		
		/* Create conditional buttons */
		let conditionalAlert = "";
		for (const [buttonName, buttonValues] of Object.entries(conditionalButtonList)) {
			/* Checks if any checks failed and the button should not be displayed */
			if (buttonValues.doNotDisplay) { continue; }
			
			let [iconFolder, iconName, iconColor] = stylingList[buttonName] || ["icons", "gear", "green"];
			if (!["green","blue","red","orange","yellow","purple","black"].includes(iconColor)) { iconColor = "green"; }

			createConditionalButton(buttonName, buttonValues.AutoScript, iconFolder, iconName, iconColor);
			conditionalAlert += (conditionalAlert != "") ? ", " + buttonName : buttonName;
		}
		if (conditionalAlert != "" && settingConditionalButtonReminder != "true") {
			outputMessage += `<div class="autoeffectEntry">${getIcon("icons","whisper","false","html","class=autoEffectImage")}<b>Created conditional buttons:</b><br> ${conditionalAlert}</div>`;
		}

		/* Encapsulate the unconditional AutoEffect messages in an generic "AutoEffects" section */
		if (outputMessage != "") {
			outputMessage = autoEffectSection("AutoEffects", outputMessage, settingCollapseSections);
		}

		/* Encapsulate conditional AutoEffect messages using #Section in a section matching the conditional */
		for (const [conditionName, conditionMessage] of Object.entries(conditionalSectionList)) {
			let [iconFolder, iconName, iconColor] = stylingList[conditionName] || ["icons", "gear", "#85a874"];
			outputMessage += autoEffectSection(conditionName, conditionMessage, settingCollapseSections, iconFolder, iconName, getColor(iconColor));
		}

	}

	/* If a message is to be sent, print the output message and attach any action buttons that exist for the AutoScript */
	if (settingMuteMessage != "true" && sendMessage == "true" && outputMessage != "") {
		
		/* Get AutoScript styling */
		let [iconFolder, iconName, iconColor] = stylingList[messageHeaderTitle] || ["icons", "gear", "#85a874"];
		let messageHeaderIcon = getIcon(iconFolder, iconName, "false", "html", `style="background-color: ${getColor(iconColor)}"`);

		/* Prepare unconditional and conditional sections into one message block */
		let messageContents = "<div class='autoeffectContainer'>" + outputMessage + "</div>";
		
		/* Collapse sections if the setting is enabled */
		if (settingCollapseSections == "true") {
			messageContents = messageContents.replaceAll("autoeffectContainer'>", "autoeffectContainer collapseSection'><div class='arrow'></div>")
		}
		
		let whisper = "";
		if(settingWhisperRolls == "true"){
			whisper = "/w " + settingWhisperTarget;
		}
		
		/* Post the message to the chat */
		setAttrs({dummyIcon: messageHeaderIcon, dummy: messageContents});
		startRoll((whisper + "&{template:autoeffect} {{icon=@{dummyIcon}}} {{title=" + messageHeaderTitle + "}} {{name=@{character_name}}} {{message=@{dummy} }}"), (results) => {
			finishRoll(results.rollId, {} );
		
			/* Attach any action buttons that have been created for the AutoScript*/
			createChatButtons(buttonList);
		});
	}
	
	/* Otherwise, return the message and any action buttons */
	else {
		returnValues.message = outputMessage;
		returnValues.buttonList = buttonList;
	}
	/* --- Message handling ends --- */

	

	/* --- Apply results --- */
	console.log(returnValues)
	callback(returnValues);
	setAttrs(output, {}, () => {

		/* Execute challange rolls */
		for (let i = 0; i < outputLists.challengeRollList.length; i++) {
			/* Checks if any checks failed and the button should not be displayed */
			rollChallenge(outputLists.challengeRollList[i][0].toLowerCase(), outputLists.challengeRollList[i][1], "false");
		}

		/* Execute proc effects */
		for (let i = 0; i < outputLists.procList.length; i++) {
			if (outputLists.procList[i][0].slice(0,1) == "-") { /* If custom ailment */
				updateCustomAilment(outputLists.procList[i][0], "standard", "false");
			} else if (outputLists.procList[i][0] == "Bleed") { /* If Bleed */
				updateBleed();
			} else { /* If standard ailment */
				updateAilments(outputLists.procList[i][0]);
			}
		}
	});
	});
	});
	/* --- Apply results end --- */



	/* --- AutoEffect functions --- */
	function autoEffectGetCount(ae) {
		ae.count = false;
		ae.countImmutable = false;

		if (ae.format.useCount && ae.targetList != "no target") {
			ae.count = parseInt(aeVars[ae.targetVar]);
			if (ae.targetType == "ailment") ae.countImmutable = parseInt(aeVars[`${ae.target}Immutable`]);
			else ae.countImmutable = ae.count;
		}
	}

	function autoEffectOutput(ae, buttonName="", buttonAutoScript="", applyMode="add") {
		if (ae.options.target && buttonAutoScript != "") {
			applyOutputButton(buttonName, buttonAutoScript, ae.options.target, ae.conditional.options.chatButton || false);
		} else {
			switch (ae.name) {
				case "FlatDamage": applyOutputButton(buttonName, buttonAutoScript, "target", ae.conditional.options.chatButton || false); // Intentional lack of break
				case "BaseDamage": applyOutput(applyMode, ae.name + (ae.target || ""), ae.value); break;
				case "DicePower": case "DiceMax": case "DiceCount": case "DiceAdv": applyOutput(applyMode, ae.name, ae.value); break;
				case "Proc": applyOutput(applyMode, ae.targetAttr, true, ae.name); break;
				case "Speed": applyOutput(applyMode, ae.target, ae.value); break;
				default:
				if (ae.targetType) {
					switch (ae.targetType) {
						case "tempBar": ae.result = updateTempBar(values, ae.target, "AutoEffects", ae.value * aeVars.scaling, "None", `AutoEffects ${ae.target}`, "icons", "gear", true, output); break;
						case "resource":
							applyOutput(applyMode, ae.targetAttr, ae.value);
							if (ae.targetAttr.includes("_max")) applyOutput(applyMode, ae.targetAttr.replace("_max",""), ae.value);
							break;
						case "stat": applyOutput(applyMode, ae.targetAttr, ae.value); break;
						case "ailment": case "bar": applyOutput(applyMode, ae.targetAttr, ae.value); break;
					}
				}
			}
		}
		

		function applyOutput(applyMode, attr, value=0) {

			/* Make sure the output value is an integer when using "add" or "set" apply modes */
			if (["add", "set"].includes(applyMode)) {
				value = roundTowardsZero(value);
			}

			/* Add the change to the output */
			switch (applyMode) {
				case "add": modifyProp(output, attr, value * aeVars.scaling, "+", {setValue: ae.count}); break;
				case "set": output[attr] = value * aeVars.scaling; break;
				case "multi": modifyProp(output, attr, value * aeVars.scaling, "*", {setValue: ae.count, round: "down"}); break;
				case "dice": modifyProp(returnValues, attr, value * aeVars.scaling, "+"); break;
				case "list": outputLists[`${uncapitalize(ae.name)}List`].push([attr, value * aeVars.scaling]); break;
			}

			/* Return the output value. Used for result inserts in messages */
			ae.result = output[attr] || returnValues[attr] || 0;

			/* Updates any modified variables */
			if (ae.targetVar in aeVars) aeVars[ae.targetVar] = ae.result;
		}

		function applyOutputButton(defaultName, AutoScript, targetMode, customName) {
			let buttonName = customName || defaultName;
			if (buttonName == "") { return; }

			let buttonTarget = "selected";
			let buttonIcon = getIcon("icons", "gear", "false", "url");
			let buttonColor = "green";
			let buttonData = {buttonName:buttonName, buttonAutoScript:AutoScript, targetTokenId:""}

			let stylingMatch = Object.keys(stylingList).find(conditional => buttonName.toLowerCase().includes(conditional.toLowerCase()))
			if (stylingMatch) {
				let [iconFolder, iconName, iconColor] = stylingList[stylingMatch] || ["icons", "gear", "green"]
				if (!["green","blue","red","orange","yellow","purple","black"].includes(iconColor)) { iconColor = "green"; }
				buttonIcon = getIcon(iconFolder, iconName, "false", "url");
				buttonColor = iconColor;
			}
			
			if (targetMode == "target" && targetName) {
				buttonTarget = targetName;
				buttonData.targetTokenId = targetTokenId;
			}

			buttonList = generateChatButton(buttonList, buttonTarget, buttonName, buttonIcon, buttonColor, buttonData, "chatButton", "half");
		}
	}

	function autoEffectMessage(ae, countUpdate) {
		let checkResult = ae.checkResult || aeVars.checkResult;
		let scaling = ae.scaling || Math.max(parseInt(aeVars.scaling), 1);
		let effectVal = roundTowardsZero(ae.value) || 0;
		let scalingVal = roundTowardsZero(scaling * ae.value) || 0;
		let effectTarget = ae.target || "No target";
		let effectCount = parseInt(ae.count) || 0;
		let effectResult = roundTowardsZero(ae.result || effectCount);
		let effectName = ae.customname || ae.name.match(/[A-Z][a-z]+/g).join(" ") || "Unknown AutoEffect"; // Adds a space between parts of the name, ex. DicePower -> Dice Power
		let effectIcon = ae.icon || "No icon";
		let iconColor = ae.color || undefined;
		let messageFormat = ae.format || "";	

		/* Retrieve the messageFormat of the AutoEffect */
		switch (ae.name) {
			case "CustomMessage": messageFormat = ae.format; break;
			case "Require": messageFormat = getTranslationByKeyCustom("Require [SCALING NUM] [TARGET]: [CHECK]", "autoeffect-format-require"); break;
			case "Consume": messageFormat = getTranslationByKeyCustom("Consume [-SCALING NUM] [TARGET]: [CHECK]", "autoeffect-format-consume"); break;
			case "Gain": messageFormat = getTranslationByKeyCustom("Gain [SCALING NUM] [TARGET]", "autoeffect-format-gain"); break;
			case "Inflict": messageFormat = getTranslationByKeyCustom("Inflict [SCALING NUM] [TARGET] to target", "autoeffect-format-inflict"); break;
			case "Give": messageFormat = getTranslationByKeyCustom("Give [SCALING NUM] [TARGET] to ally", "autoeffect-format-give"); break;
			case "Set": messageFormat = getTranslationByKeyCustom("Set [TARGET] to [RESULT]", "autoeffect-format-set"); break
			case "Add":
				if (["Light", "THP", "TST", "Action", "Reaction", "Counter", "Block", "Evade", "Light_Regen"].includes(ae.target)) {
					if (ae.value < 0) { messageFormat = getTranslationByKeyCustom("Lose [-SCALING NUM] [TARGET]", "autoeffect-format-add-light-neg"); }
					else { messageFormat = getTranslationByKeyCustom("Gain [SCALING NUM] [TARGET]", "autoeffect-format-add-light"); }
				} else {
					if (ae.value < 0) { messageFormat = getTranslationByKeyCustom("Receive [-SCALING NUM] [TARGET] damage", "autoeffect-format-add-neg"); }
					else { messageFormat = getTranslationByKeyCustom("Regen [SCALING NUM] [TARGET]", "autoeffect-format-add"); }
				} break;
			case "Multi": messageFormat = getTranslationByKeyCustom("Multiply [TARGET] by [SCALING NUM]", "autoeffect-format-multi"); break;
			case "BaseDamage":
				if (ae.target) { messageFormat = getTranslationByKeyCustom("Increase [TARGET] Base Damage by [SCALING NUM]", "autoeffect-format-basedamage-target"); }
				else { messageFormat = getTranslationByKeyCustom("Increase Base Damage by [SCALING NUM]", "autoeffect-format-basedamage"); } break;
			case "FlatDamage": messageFormat = getTranslationByKeyCustom("Deal [SCALING NUM] [TARGET] Damage", "autoeffect-format-flatdamage"); break;
			case "DicePower": case "DiceMax": case "DiceCount": case "DiceAdv":
				if (ae.value < 0) { messageFormat = getTranslationByKeyCustom("Reduce [EFFECT] by [SCALING NUM]", "autoeffect-format-dice-neg"); }
				else { messageFormat = getTranslationByKeyCustom("Increase [EFFECT] by [SCALING NUM]", "autoeffect-format-dice"); } break;
			case "Proc": messageFormat = getTranslationByKeyCustom("Proc [TARGET]", "autoeffect-format-proc"); break;
			case "Pause": messageFormat = getTranslationByKeyCustom("Paused [TARGET] for [SCALING NUM] activations", "autoeffect-format-pause"); break;
			case "ChallengeRoll":
				if (ae.value < 0) { messageFormat = getTranslationByKeyCustom("Rolling [TARGET] [SCALING NUM]", "autoeffect-format-challengeroll-neg"); }
				else { messageFormat = getTranslationByKeyCustom("Rolling [TARGET] <b>+</b>[SCALING NUM]", "autoeffect-format-challengeroll"); } break;
			case "Speed":
				if (ae.value < 0) { messageFormat = getTranslationByKeyCustom("Reduce [EFFECT] by [-SCALING NUM]", "autoeffect-format-speed-neg"); }
				else { messageFormat = getTranslationByKeyCustom("Increase [EFFECT] by [SCALING NUM]", "autoeffect-format-speed"); } break;
		}

		/* Update old stat names */
		effectTarget = updateStatName(effectTarget);

		/* Handle ailment icons */
		if (ae.targetType == "ailment" && ae.name != "CustomMessage") {
			messageFormat = "[/TARGET] " + messageFormat;
			effectIcon = valueLists.ailmentList[ae.target][6];
		}

		/* Handle formating for the target option */
		if (autoEffectOptions.Target.includes(ae.name) && ae.options.target) {
			messageFormat = (ae.options.target == "target")
				? `${getTranslationByKeyCustom("Target", "message-target")} - ${messageFormat}`
				: `${getTranslationByKeyCustom("Select", "message-select")} - ${messageFormat}`;
		}

		/* Handle formating for the round and duration options */
		if (autoEffectOptions.Round.includes(ae.name) && settingHideNextTurn != "true" && ae.options.round != "this") {
			messageFormat += (` ${getTranslationByKeyCustom("Next", "autoeffect-option-next")} ${getTranslationByKeyCustom("Round", "autoeffect-option-round")}`).toLowerCase();
		}
		if (autoEffectOptions.Duration && ae.options.duration) {
			switch (ae.options.duration) {
				case "combat": messageFormat += (` ${getTranslationByKeyCustom("This", "autoeffect-option-this")} ${getTranslationByKeyCustom("Combat", "autoeffect-option-combat")}`).toLowerCase(); break;
				case "this": messageFormat += (` ${getTranslationByKeyCustom("This", "autoeffect-option-this")} ${getTranslationByKeyCustom("Round", "autoeffect-option-round")}`).toLowerCase(); break;
				case "next": messageFormat += (` ${getTranslationByKeyCustom("Next", "autoeffect-option-next")} ${getTranslationByKeyCustom("Round", "autoeffect-option-round")}`).toLowerCase(); break;
			}
		}

		/* Handle compare modes */
		if (ae.options.compareValue) {
			effectVal = ae.options.compareValue + effectVal;
			scalingVal = ae.options.compareValue + scalingVal;
		}

		/* Handle value updates */
		if (!["failure", "no target"].includes(checkResult) && countUpdate && ae.value && !ae.options.target) {
			messageFormat += " [[INITIAL] -> [RESULT]]";
		}

		messageValues = {
			"customname": effectName,
			"value": ae.value,
			"target": effectTarget,
			"count": effectCount,
			"result": effectResult,
			"icon": effectIcon,
			"scaling": scaling,
			"checkResult": checkResult
		}

		if(messageFormat != "" && ![true, "self"].includes(ae.options.silent)) {
			
			const applyInsert = (match, insert, prefix="<b>", affix="</b>") => {
				message = message.replaceAll(match, prefix + insert + affix);
			}

			let message = messageFormat;
	
			let langCheck = getTranslationByKeyCustom("[CHECK]", "autoeffect-match-check");
			let langSuccess = getTranslationByKeyCustom("Success", "distort-results-good");
			let langFailure = getTranslationByKeyCustom("Failure", "distort-results-bad");
			let langNoTarget = getTranslationByKeyCustom("No target", "autoeffect-alert-notarget");
			let langNum = getTranslationByKeyCustom("[NUM]", "autoeffect-match-num");
			let langScaling = getTranslationByKeyCustom("[SCALING]", "autoeffect-match-scaling");
			let langScalingNum = getTranslationByKeyCustom("[SCALING NUM]", "autoeffect-match-scalingnum");
			let langNegNum = getTranslationByKeyCustom("[-NUM]", "autoeffect-match-neg-num");
			let langNegScaling = getTranslationByKeyCustom("[-SCALING]", "autoeffect-match-neg-scaling");
			let langNegScalingNum = getTranslationByKeyCustom("[-SCALING NUM]", "autoeffect-match-neg-scalingnum");
			let langMulti = getTranslationByKeyCustom("[MULTI]", "autoeffect-match-multi");
			let langInitial = getTranslationByKeyCustom("[INITIAL]", "autoeffect-match-initial");
			let langResult = getTranslationByKeyCustom("[RESULT]", "autoeffect-match-result");
			let langEffectName = getTranslationByKeyCustom("[EFFECT]", "autoeffect-match-effectname");
			let langCharacterName = getTranslationByKeyCustom("[CHAR]", "autoeffect-match-charname");
			let langTarget = getTranslationByKeyCustom("[TARGET]", "autoeffect-match-target");
			let langTargetIcon = getTranslationByKeyCustom("[/TARGET]", "autoeffect-match-targeticon");
	
			switch (checkResult) {
				case "failure": applyInsert(langCheck, langFailure); break;
				case "no target": applyInsert(langCheck, langNoTarget); break;
				default:
					applyInsert(langCheck, langSuccess);
					/*applyInsert(langResult, effectResult);*/ break;
			}
			applyInsert(langNum, effectVal);
			applyInsert(langScaling, scaling);
			applyInsert(langScalingNum, scalingVal);
			applyInsert(langNegNum, -effectVal);
			applyInsert(langNegScaling, -scaling);
			applyInsert(langNegScalingNum, -scalingVal);
			applyInsert(langMulti, Math.floor(scalingVal * effectCount)); // Used for the Multi AutoEffect
			applyInsert(langInitial, effectCount);
			applyInsert(langResult, effectResult); // Used on checkFailure
			applyInsert(langEffectName, effectName);
			applyInsert(langCharacterName, charName);
			applyInsert(langTarget, effectTarget.replace("_"," "));

			/* Handle text styling */
			let styleTextFind = new RegExp(/\[([^\]]+?)\]\(#(?!")(.+?)\)/);
			let styleTextReplace = new RegExp(/(\[[^\]]+?\]\(#(?!").+?\))/);
			while (styleTextFind.test(message)) {
				let [text, style] = message.match(styleTextFind).slice(1);
				message = message.replace(styleTextReplace, styleText(text, style));
			}

			/* Icon handling */
			/* Get target icon. Is in this format: [/TARGET]. If a effectIcon is provided, use that instead */
			if (effectIcon != "No icon") {
				if (settingLimbusStyle == "true") { effectIcon = effectIcon.replace("limbus/",""); }
				applyInsert(langTargetIcon, getIcon("ailments", effectIcon, settingLimbusStyle, "html", `class="autoEffectImage" style="background-color: ${iconColor}"`), "", "");
			} else {
				applyInsert(langTargetIcon, getIcon("ailments", effectTarget.replace("_"," "), settingLimbusStyle, "html", `class="autoEffectImage" style="background-color: ${iconColor}"`), "", "");
			}
			
			/* Question mark icon */
			applyInsert("[/Question]", getIcon("icons", "Question", "false", "html", `class="autoEffectImage" style="background-color: ${iconColor}"`), "", "");
	
			/* Get custom icon. Is in one of these formats: [/iconName], [/limbus/iconName], [/community/iconName]*/
			if ((/\[\/([^0-9]+)\]/g).test(message)) {
				applyInsert("[/community/", "[community, ", "", "");
				applyInsert("[/limbus/", "[ailments, limbus/", "", "");
				applyInsert("[/", "[ailments, ", "", "");
				
				message.match((/\[([^0-9]+)\]/g)).forEach(icon => {
					let iconSelector = icon.slice(1,-1).split(", ");
					let iconFolder = iconSelector[0];
					let iconName = iconSelector[1];
					message = message.replace(icon, getIcon(iconFolder, iconName, "false", "html", `class="autoEffectImage" style="background-color: ${iconColor}"`));
				});
			}
	
			/* Message structure */
			if (message.startsWith("<img") == true) {
				message = message.replace(">","><div>") + "</div>";
			} else {
				message = "<div>" + message + "</div>";
			}
			message = autoEffectEntry(message);

			/* Output message */
			if (aeType != "section") {
				outputMessage += autoEffectTranslateMessage(message);
			} else {
				if (conditionalSectionList[aeConditional]) {
					conditionalSectionList[aeConditional] += autoEffectTranslateMessage(message);
				} else {
					conditionalSectionList[aeConditional] = autoEffectTranslateMessage(message);
				}
			}
		}
	}

	function autoEffectCustomMessage(ae, messageValues = {}) {
		let checkResultOption = ae.options.checkResult || "success";
		ae = {...ae, ...messageValues, format: ae.value}

		/* Handle the target option */
		if (ae.options.target) {
			autoEffectOutput(ae, "", autoEffectToString(ae.origAutoEffect, {removeOptions:["Target", "Select"]}));
		} else {
			if (checkResultOption == ae.checkResult.replace("last ","").replace("no target","failure") || checkResultOption == "ignore") {
				autoEffectMessage(ae);
			}
		}
	}

	// Math operation

	function autoEffectCheck(ae) {
		let checkResult = "success";
		let scaling = 1;

		if (ae.targetList == "no target") {
			checkResult = "no target";
		} else {
			/* Handle the scaling option */
			if (ae.options.scaling) {
				let baseScaling = Math.floor(ae.countImmutable/ae.value);
				if (parseInt(ae.options.scaling)) {
					scaling = Math.max(Math.min(baseScaling, ae.options.scaling), 1); // If number
				} else if ((/[{}]/).test(ae.options.scaling)) {
					scaling = Math.max(Math.min(baseScaling, parseMath(ae.options.scaling, aeVars, {strict:true}, errorMessageList)), 1); // If math formula
				} else {
					scaling = Math.max(baseScaling, 1); // If boolean
				}
				if (ae.options.compareValue && ae.options.compareValue.includes("<")) {
					if (!mathOperation(ae.options.compareValue, ae.countImmutable, ae.value*scaling)) {
						scaling++
					}
				}
			} else {
				scaling = aeVars.scaling;
			}

			/* Execute check */
			if (ae.name == "Require") {
				if (ae.options.compareValue) {
					checkResult = mathOperation(ae.options.compareValue, ae.countImmutable, ae.value*scaling) ? "success" : "failure"
				} else {
					checkResult = (ae.countImmutable >= ae.value*scaling) ? "success" : "failure";
				}
			}
			else if (ae.name == "Consume") {
				if (ae.countImmutable >= ae.value && ae.count >= ae.value) {
					checkResult = (ae.count >= 2*ae.value) ? "success" : "last success";
				} else {
					checkResult = "failure";
				}
			}
		}

		/* If conditional, do not apply any changes or send a message */
		if (aeType == "standard") {
			/* Update execution variables */
			aeVars = {...aeVars, scaling: scaling, checkResult: checkResult }

			/* Update returned checkResult if result is worse than the current value */
			if (returnValues.checkResult == "success") {
				returnValues.checkResult = checkResult.replace("no target","failure");
			} else if (returnValues.checkResult == "last success" && ["failure", "no target"].includes(checkResult)) {
				returnValues.checkResult = "failure;"
			}

			/* Apply output */
			let countUpdate = false;
			if (ae.name == "Consume" && checkResult != "failure") {
				ae.value = -ae.value;
				countUpdate = "update count";
				autoEffectOutput(ae, "Apply ailments", `(Consume 1 ${ae.target} Scaling${-ae.value*scaling} ${([true, "target"].includes(ae.options.silent)) ? "Silent" : ""}) (Reset)`);
			}
			ae.value = Math.abs(ae.value);
			autoEffectMessage(ae, countUpdate);
		} else {
			return returnValues;
		}
	}

	function autoEffectReset(ae) {
		if (ae && ae.options.target) {
			autoEffectOutput(ae, "", "(Reset)");
		} else {
			aeVars = {...aeVars, checkResult:"success", scaling:1 }
			messageValues = {...messageValues, checkResult:"success"}
		}
	}

	function autoEffectAilment(ae) {
		switch (ae.name) {
			case "Inflict": ae.options.target = "target"; break;
			case "Give": ae.options.target = "select"; break;
		}
		autoEffectOutput(ae, "Apply ailments", autoEffectToString(ae.origAutoEffect, {changeName: "Gain", changeValue: ae.value*aeVars.scaling, removeOptions:["Target", "Select"]}));
		autoEffectMessage(ae, "update count");
	}

	function autoEffectBar(ae) {
		let buttonName = (ae.value < 0) ? "Apply damage" : "Apply regen"
		autoEffectOutput(ae, buttonName, autoEffectToString(ae.origAutoEffect, {changeValue: ae.value*aeVars.scaling, removeOptions:["Target", "Select"]}));
		autoEffectMessage(ae, "update count");
	}

	function autoEffectDice(ae) {
		autoEffectOutput(ae, "", "", "dice");
		autoEffectMessage(ae);
	}

	function autoEffectChallengeRoll(ae) {
		autoEffectOutput(ae, "Roll challenge", autoEffectToString(ae.origAutoEffect, {changeValue: ae.value*aeVars.scaling, removeOptions:["Target", "Select"]}), "list");
		autoEffectMessage(ae);
	}

	function autoEffectSpeed(ae) {
		let applyMode = "add";
		let countUpdate = "update count";
		switch (ae.options.duration) {
			case "combat": ae.target = "SpeedCombat"; ae.count = aeVars.baseSpeed; applyMode = "dice"; countUpdate = false; break;
			case "this": ae.target = "thisRoundSpeed"; ae.count = aeVars.thisRoundSpeed; break;
			case "next": ae.target = "nextRoundSpeed"; ae.count = aeVars.nextRoundSpeed; break;
		}
		autoEffectOutput(ae, "Apply Speed", autoEffectToString(ae.origAutoEffect, {changeValue: ae.value*aeVars.scaling, removeOptions:["Target", "Select"]}), applyMode);
		autoEffectMessage(ae, countUpdate);
	}

	function autoEffectDamage(ae) {
		if (ae.name == "BaseDamage" && (["SP", "Light"]).includes(ae.target)) {
			ae.name = "FlatDamage";
		}
		autoEffectOutput(ae, "Apply damage", `(Add ${-ae.value*aeVars.scaling} ${ae.target} ${([true, "target"].includes(ae.options.silent)) ? "Silent" : ""})`, "dice");
		autoEffectMessage(ae);
	}

	function autoEffectProc(ae) {
		if (ae.targetAttr.includes("repeating")) { // Get the ailment id if a custom ailment
			ae.targetAttr = ae.targetAttr.split("_")[2];
		}
		autoEffectOutput(ae, "Apply ailments", `(Proc ${ae.target} ${([true, "target"].includes(ae.options.silent)) ? "Silent" : ""})`, "list");
		autoEffectMessage(ae);
	}

	function autoEffectPause(ae) {
		ae.targetAttr = ae.targetAttr.replace("ailNum","ail") + "DecayPause";
		ae.targetVar += "Pause";
		autoEffectOutput(ae, "Apply ailments", `(Pause ${ae.value*aeVars.scaling} ${ae.target} ${([true, "target"].includes(ae.options.silent)) ? "Silent" : ""})`);
		autoEffectMessage(ae);
	}
	/* --- AutoEffect functions end --- */
	});
	});
	});
}

/* Removes all newline and tab characters as well as JavaScript comments from an AutoScript */
function cleanAutoScript(AutoScript) {

	/* Remove all comments */
	let cleanAutoScript = AutoScript.replace(/\/\*[\s\S]*?\*\/|(?<=[^:])\/\/.*|^\/\/.*/g,'');

	/* Remove all newlines and tab spaces */
	cleanAutoScript = cleanAutoScript.replace(/(\r\n|\n|\r|\t)/gm, "");

	/* Remove all spaces between AutoEffects ex. )    ( -> )( */
	cleanAutoScript = cleanAutoScript.replace(/[\)}]( +)[\({]/g,')(')

	/* Replace all  quotes with "" quotes */
	cleanAutoScript = cleanAutoScript.replaceAll('','"').replaceAll('','"');

	/* Remove any of the old v0.6 options that still remain in the AutoScript */
	//cleanAutoScript = cleanAutoScript.replaceAll("#MessageButton","").replaceAll("#Button","").replaceAll("#Message","#Section").trim();

	/* Replace Stagger_Protection with StaggerProtection. The leading space is added to avoid affecting image links */
	cleanAutoScript = cleanAutoScript.replaceAll(' Stagger_Protection',' StaggerProtection');

	return cleanAutoScript;
}

/* Adds a new error message to an error object */
function autoEffectError(errorList, errorCode, errorSubject, errorInserts={}, errorVariant) {
	let errorType = getTranslationByKeyCustom(errorCode, autoEffectErrorData[errorCode] + "-type")
	let errorMessage = autoEffectEntry(`<div>${styleText(autoEffectToString(errorSubject), "font-weight: bolder; color: red;")}\n*${getTranslationByKeyCustom(errorCode, autoEffectErrorData[errorType] + "-message" + (errorVariant ? `-${errorVariant}` : ""))}*</div>`);

	for (let [match, insert] of Object.entries(errorInserts)) {
		if (insert == "") { match = ` ${match}`; }
		errorMessage = errorMessage.replaceAll(match, insert);
	}
	modifyProp(errorList, errorType, errorMessage);
	log({errorType, errorMessage});
}

/* Parses an AutoScript, validating its format and getting  */
/* Takes in a list of attribute values (vl) and a list of AutoScript aliases (al) */
/* Returns an array of objects containing execution parameters for each AutoEffect in the AutoScript (target, value, options, conditionals etc.) */
/*   If an errors object is provided, details of any the errors that were encountered while validating the AutoScript will be added to the list */
function parseAutoScript(inputAutoScript, vl, al, vars, triggers=[], errors={}) {
	
	let ExecutionArray = [];

	/* Helper functions */
	const getAutoEffectOptions = (effectName, optionsList, expand=false) => {
		let options = {};
		for (const [option, effects] of Object.entries(optionsList)) {
			if (effects.includes(effectName) || (effects.includes("All") && !effects.includes(`-${effectName}`))) {
				if (option in autoEffectOptionsExpand && expand) {
					options = {...options, ...autoEffectOptionsExpand[option].reduce((rows, o) => Object.assign(rows, {[o]:true}), {})}
				} else {
					options[option] = true;
				}
			}
		}
		return options;
	}
	const optionsToString = (options) => {
		let optionsString = "";
		for (let [option, value] of Object.entries(options)) {
			option = getTranslationByKeyCustom(option, `autoeffect-option-${option.toLowerCase()}`)
			optionsString += (optionsString == "") ? `#${option}` : ` #${option}`;
		}
		return optionsString;
	}
	const valueToString = (valueFormat) => {
		switch (valueFormat) {
			case "number": return getTranslationByKeyCustom('N', "autoeffect-error-value-number");
			case "string": return getTranslationByKeyCustom('"Format"', "autoeffect-error-value-format");
			case false: return "";
		}
	}
	const targetsToString = (targetFormat, divider1=", ", divider2=" or ") => {
		let targetString = "";
		if (targetFormat) {
			targetFormat.forEach(target => {
				let wordDivider = (targetFormat.length != targetFormat.indexOf(target)+1) ? divider1 : divider2;
				target = target.replace("#","");
				target = getTranslationByKeyCustom(target, `autoeffect-error-target-${target.toLowerCase()}`)
				targetString += (targetString == "") ? target : `${wordDivider}${target}`;
			});
		}
		return targetString;
	}

	/* Replaces any aliases in the AutoScript */
	let AutoScript = autoScriptApplyAliases(inputAutoScript, al, "normal", errors);

	/* Convert AutoScript to an array */
	let AutoEffectArray = autoScriptToArray(AutoScript);

	/* Parse each AutoEffect in the AutoScript */
	AutoEffectArray.forEach(AutoEffect => {

		/* Get AutoEffect name */
		let [effectName, langEffectName] = [getAutoEffectFromTranslation(AutoEffect[0][0]), AutoEffect[0][0]];
		
		/* Test: Valid name */
		if (!(effectName in autoEffectFormats)) {
			autoEffectError(errors, "Invalid AutoEffect", AutoEffect[0], {"[NAME]":langEffectName}); return;
		}
		
		/* Get the AutoEffect format */
		let effectFormat = autoEffectFormats[effectName];
		if (effectFormat.copy) {
			effectFormat = autoEffectFormats[effectFormat.copy];
		}
		let valueIndex = targetIndex = optionIndex = 0;
		if (effectFormat.value) { valueIndex = 1; }
		if (effectFormat.target) { targetIndex = valueIndex + 1; }
		if (effectFormat.reverse) { valueIndex++; targetIndex--; }
		optionIndex = Math.max(valueIndex, targetIndex) + 1;
		if (effectFormat.targetOptional && !AutoEffect[0][targetIndex]) { targetIndex = 0; optionIndex--;}
		let [validOptions, validOptionsRaw] = [getAutoEffectOptions(effectName, autoEffectOptions, "expand"), getAutoEffectOptions(effectName, autoEffectOptions)];
		let [validConOptions, validConOptionsRaw] = [getAutoEffectOptions(effectName, conditionalOptions, "expand"), getAutoEffectOptions(effectName, conditionalOptions)];
		let [langValidOptions, langValidConOptions] = [optionsToString(validOptionsRaw), optionsToString(validConOptionsRaw)];
		
		/* Translates AutoEffect names, bars and ailments to English. Stores untranslated values for error messages */
		let langAutoEffect = [...AutoEffect];
		AutoEffect = translateAutoEffectToEnglish(AutoEffect, effectFormat.target ? [...effectFormat.target] : false, validOptions, validConOptions, targetIndex, optionIndex);

		/* Get AutoEffect value, target and options */
		let [effectValue, langEffectValue] = (valueIndex) ? [AutoEffect[0][valueIndex], langAutoEffect[0][valueIndex]] : [false, ""];
		let [effectTarget, langEffectTarget] = (targetIndex) ? [AutoEffect[0][targetIndex], langAutoEffect[0][targetIndex]] : [false, ""];
		let [effectOptions, langEffectOptions] = [AutoEffect[0].slice(optionIndex), langAutoEffect[0].slice(optionIndex)];
		let [effectConditionals, langEffectConditionals] = [AutoEffect.slice(1), langAutoEffect.slice(1)];
		let targetList = targetType = false;
		let targetAttr = targetVar = effectTarget;
		let options = {}
		let conditional = {options:{}}

		/* Test: Valid format / length */
		let effectLengthMin = optionIndex;
		let effectLengthMax = optionIndex + length(validOptionsRaw);
		if (effectFormat.maxLengthMod) { effectLengthMax += effectFormat.maxLengthMod; }
		if (AutoEffect[0].length < effectLengthMin || AutoEffect[0].length > effectLengthMax) {
			autoEffectError(errors, "Invalid Format", AutoEffect[0], {
				"[NAME]":langEffectName,
				"[VALUE]":valueToString(effectFormat.value),
				"[TARGET]":targetsToString(effectFormat.target,
					getTranslationByKeyCustom("/", "autoeffect-error-divider-slash"),
					getTranslationByKeyCustom("/", "autoeffect-error-divider-slash")
				),
				"[OPTIONS]":langValidOptions
			}); return;
		}

		/* Parse options + Test: Valid options */
		if (effectOptions.length > 0) {
			for (let i = 0; i < effectOptions.length; i++) {
				let newOption = capitalize(effectOptions[i].replace("#",""));
				
				/* Handle the "Silent" option */
				if (autoEffectOptionsExpand["Silent"].includes(newOption) && "Silent" in validOptionsRaw) {
					options.silent = (newOption != "Silent") ? newOption.toLowerCase().replace("silent","") : true;
				}

				/* Handle the "Target" option */
				else if (autoEffectOptionsExpand["Target"].includes(newOption) && "Target" in validOptionsRaw) {
					options.target = newOption.toLowerCase();
				}

				/* Handle the "CheckResult" option */
				else if (autoEffectOptionsExpand["CheckResult"].includes(newOption) && "CheckResult" in validOptionsRaw) {
					options.checkResult = newOption.toLowerCase().replace("check","");
				}

				/* Handle the "Round" option */
				else if (autoEffectOptionsExpand["Round"].includes(newOption) && "Round" in validOptionsRaw) {
					options.round = (options.round) ? options.round : false;
					if (newOption == "This" || newOption == "Next") {
						options.round = newOption.toLowerCase();
					}
					if (!options.round) { autoEffectError(errors, "Invalid Round", AutoEffect[0]); }
				}

				/* Handle the "Duration" option */
				else if (autoEffectOptionsExpand["Duration"].includes(newOption) && "Duration" in validOptionsRaw) {
					options.duration = (options.duration) ? options.duration : false;
					if (newOption == "Combat") {
						options.duration = "combat";
					}
					else if (options.duration != "combat" && (newOption == "This" || newOption == "Next")) {
						options.duration = newOption.toLowerCase();
					}
					if (!options.duration) { autoEffectError(errors, "Invalid Duration", AutoEffect[0]); }
				}

				/* Handle options using N (ex. ScalingN) */
				else if ((/[#\w]+({.+}|\d+)/i).test(newOption) && newOption.replace(/([#\w]+)({.+}|\d+)/i, "$1N") in validOptions) {
					let optionN = newOption.match(/({.+}|\d+)/ig)[0];
					newOption = newOption.replace(optionN, "");
					options[newOption.toLowerCase()] = optionN;
					if ((/{.+}/).test(options)) validateMathFormula(optionN, vars, errors);
				}
				
				/* Sets option to true if no other value is provided */
				else { options[newOption.toLowerCase()] = true; }
				
				if (!(newOption in validOptions || `#${newOption}` in validOptions)) {
					autoEffectError(errors, "Invalid Option", AutoEffect[0], {
						"[NAME]":langEffectName,
						"[OPTION]":langEffectOptions[i],
						"[OPTIONS]":langValidOptions.replaceAll(" ", ", ")
					}); return;
				}
			}
		}

		/* Parse target + Test: Valid target */
		if (effectFormat.target) {
			if (effectFormat.target.includes("#Ailment") && effectTarget in vl.ailmentList) { targetList="ailmentList"; targetType="ailment"; }
			if (effectFormat.target.includes("#Bar") && effectTarget in vl.barList) { targetList="barList"; targetType="bar"; }
			if (effectFormat.target.includes("#BarDamage") && effectTarget in vl.barDamageList) { targetList="barDamageList"; targetType="bar"; }
			if (effectFormat.target.includes("#BarTemp") && barNamesTemp.includes(effectTarget)) { targetList="barList"; targetType="tempBar"; }
			if (effectFormat.target.includes("#Stat") && statNamesFull.includes(effectTarget)) { targetList="statList"; targetType="stat"; }
			if (effectFormat.target.includes("#Resource") && resourceNames.includes(effectTarget)) { targetList="resourceList"; targetType="resource"; }
			
			if (targetList) {
				if (options.target) { // Update the target list when using the target option
					if (length(vl.targetAilmentList) > 0) {
						targetList = "target" + capitalize(targetList);
					} else {
						targetList = "no target";
					}
				}
				if (targetType == "ailment") {
					if (vl.ailmentList[effectTarget][5] != "0") {  // Handle custom ailments
						targetAttr = `repeating_ailments_${vl.ailmentList[effectTarget][5]}_ailNum`;
					}
					if (vl.ailmentList[effectTarget][0] == "true") { // Handle next turn ailments
						if (autoEffectOptions["Round"].includes(effectName) && options.round != "this") {
							options.round = "next";
							targetAttr += "NextTurn"; targetVar += "NextTurn";
						}
					} else {
						options.round = "this"; // Forces the round option to "This" if no next turn field exists
					}
				}
				if (targetType == "resource" && triggers.includes("Round start")) {
					targetAttr += "_max"; targetVar += "_max";
				}
			} else {
				if (effectFormat.targetOptional) { // Handle effects with an optional target (ex. BaseDamage)
					if (effectTarget != "undefined") {
						effectOptions.push(effectTarget);
					}
				} else {
					autoEffectError(errors, "Invalid Target", AutoEffect[0], {
						"[TARGETS]":targetsToString(effectFormat.target,
							getTranslationByKeyCustom(", ", "autoeffect-error-divider-comma"),
							getTranslationByKeyCustom(" or ", "autoeffect-error-divider-or"),
						),
						"[TARGET]":langEffectTarget
					}); return;
				}
			}
		}

		/* Parse value + Test: Valid value */
		switch (effectFormat.value) {
			case "number":
				let langPercent = "";
				let percentage = 0;

				/* Test math formulas have a valid format */
				if ((/[{}]/).test(effectValue)) {
					let mathString = effectValue.match(/^{.+}$/g)[0];
					if (mathString) {
						validateMathFormula(effectValue, vars, errors); break;
					} else {
						autoEffectError(errors, "Math Error", AutoEffect[0], {"[MATH]":effectValue}, ""); return;
					}
				}

				/* Extract value options (ex. % and < / > / <= / >= */
				if ((/^[<>]=?/).test(effectValue)) {
					if ((/^[<>]=?/).test(effectValue) && effectFormat.compareValue && effectTarget) {
						let compare = effectValue.match(/^[<>]=?/g)[0];
						effectValue = effectValue.replace(compare,"");
						options.compareValue = compare;
					} else {
						autoEffectError(errors, "Invalid Compare", AutoEffect[0]); return;
					}
				}
				if (effectValue.slice(-1) == "%") {
					if (effectFormat.percentageValue && effectTarget) {
						effectValue = effectValue.replace("%","");
						percentage = Math.abs(parseFloat(effectValue) / 100);
						langPercent = getTranslationByKeyCustom("or percentage", "autoeffect-error-value-percent");
						options.percentageValue = true;
					} else {
						autoEffectError(errors, "Invalid Percentage", AutoEffect[0]); return;
					}
				}
				
				/* Get the base value */
				effectValue = parseFloat(effectValue);
				if (!effectFormat.negativeValue) { effectValue = Math.abs(effectValue); }
				if (isNaN(effectValue)) {
					autoEffectError(errors, "Invalid Value", AutoEffect[0], {"[VALUE]":langEffectValue,"[PERCENT]":langPercent});
				}
				
				/* Apply value options */
				if (options.percentageValue && targetList != "no target") {
					if (["barlist", "bardamagelist"].includes(targetList.toLowerCase())) {
						let barMax = parseInt(vl.barMaxList[effectTarget.replace("-","")+"_max"]);
						effectValue = barMax*percentage;
					}
					else if (targetList.toLowerCase().includes("ailmentlist")) {
						let ailmentMax = parseInt(vl.ailmentList[effectTarget.replace("-","")][3]);
						effectValue = Math.max(ailmentMax*percentage, 1);
					}
				} break;
			
			case "string":
				if (effectValue.indexOf('"') == 0 && effectValue.lastIndexOf('"') == 0) {
					autoEffectError(errors, "Invalid Format", AutoEffect[0], {
						"[NAME]":langEffectName,
						"[VALUE]":getTranslationByKeyCustom('"Format"', "autoeffect-error-value-format"),
						"[TARGET]":langEffectTarget,
						"[OPTIONS]":langValidOptions
					}); return;
				} break;
		}

		/* Parse conditionals and conditional options */
		if (effectConditionals.length > 0 && length(validConOptions) > 0) {
			let primaryCon = effectConditionals[0];
			let conOptions = {}

			/* Handle the "Section" option */
			if (primaryCon.includes("#Section") && "Section" in validConOptions) {
				primaryCon = primaryCon.replaceAll(/(#Section)/ig,"").trim();
				conOptions.section = true;
			}

			/* Handle the "IgnoreFailure" option (is also accepted as a normal option) */
			if ((options.ignoreFailure || primaryCon.includes("#IgnoreFailure")) && "IgnoreFailure" in validConOptions) {
				primaryCon = primaryCon.replaceAll(/(#IgnoreFailure)/ig,"").trim();
				conOptions.ignoreFailure = true;
			}

			/* Handle the "ChatButton" option */
			/* The conditional with option is removed. If the conditional is the primary conditional the effect becomes unconditional */
			for (var i = 0; i < effectConditionals.length; i++) {
				let anyCon = effectConditionals[i];
				
				if (!conOptions.chatButton && anyCon.includes("#ChatButton") && "ChatButton" in validConOptions) {
					effectConditionals.splice(i,i);
					AutoEffect.splice(i+1,i+1);
					primaryCon = false;
					conOptions.chatButton = anyCon.replaceAll(/(#ChatButton)/ig,"").trim();
				}
			}

			conditional = {name: primaryCon, options: conOptions};

			/* Remove the current conditional. Hinders it from being added to conditional/action buttons */
			if (primaryCon) { AutoEffect.splice(1,1); }
		}

		// Store the Execution parameters
		let executionParams = {
			name: effectName,
			format: effectFormat,
			value: effectValue,
			target: effectTarget,
			targetAttr: targetAttr,
			targetVar: targetVar,
			targetList: targetList,
			targetType: targetType,
			options: options,
			conditional: conditional,
			origAutoEffect: AutoEffect
		}
		ExecutionArray.push(executionParams);
	});

	return ExecutionArray

	// Checklist:
	// Add a list of variables. Begins with the default variables and adds any variables created by AutoEffects
	//  Parser throws an error if an AutoEffect uses a variable that has not yet been created
	//  Execution may still fail if the variable isn't created due to a failed check. In this case use a default value for the variable
}

// Converts an AutoScript from a string to an array
// mode: "normal" is for strings of type (AutoEffect...) (AutoEffect...) ...
//	 each AutoEffect returns an array in the format [[name, value, target, option1, option2, ...], conditional1, conditional2, ...]
//	 some AutoEffects do not return a value or target
// mode: "nested" is for strings of type [#Offensive, (AutoEffect...) ... #] [#Round start, (AutoEffect...) ... ]
//   each Trigger returns an array in the format [trigger, (AutoEffect...)]
// mode: "aliases" is for strings of the type {#aliasFormat, aliasAutoScript#}
function autoScriptToArray(AutoScript, mode="normal") {
	let AutoEffect = "";
	let AutoEffectArray = [];
	let AutoScriptArray = [];

	let [beginChar, middleChar, endChar, charOffset] = ["(", ")(", ")", 1];

	if (mode == "triggers") { [beginChar, middleChar, endChar, charOffset] = ["[#", "#][#", "#]", 2]; }
	else if (mode == "aliases") { [beginChar, middleChar, endChar, charOffset] = ["{#", "#}{#", "#}", 2]; }

	AutoScript = cleanAutoScript(AutoScript);

	do {
		AutoScript = AutoScript.trim();

		/* Checks if an AutoEffect still remains in the AutoScript */
		if (AutoScript.indexOf(beginChar) == 0 && AutoScript.indexOf(endChar)) {

			/* Removes the next AutoEffect from the AutoScript. Removes the parentheses */
			if (AutoScript.indexOf(middleChar) != "-1") {
				AutoEffect = AutoScript.substring(charOffset, AutoScript.indexOf(middleChar));
				AutoScript = AutoScript.substring(AutoScript.indexOf(middleChar)+charOffset);
			} else {
				AutoEffect = AutoScript.substring(charOffset, AutoScript.length-charOffset);
				AutoScript = "";
			}
			
			/* Structures the AutoEffect into an array and stores it */
			if (mode != "normal") {
				let keySeperator = (mode == "triggers") ? "," : ";";
				AutoEffect = AutoEffect.trim().replace(keySeperator,"");
				AutoEffectArray = AutoEffect.split("");
				AutoEffectArray = AutoEffectArray.map(e => e.trim());
			} else {
				/* For AutoEffects that use a string value, preserve commas and quotes in the string by extracting the string before splitting over "," */
				if (autoEffectFormats[AutoEffect.split(" ")[0]].value == "string") {
					AutoEffectArray = splitIgnoreBetween(AutoEffect.trim(), ",", '"', '"', true, true);
					AutoEffectArray[0] = splitIgnoreBetween(AutoEffectArray[0], /\s+/g, '"', '"', false, true);
				} else {
					AutoEffectArray = splitIgnoreBetween(AutoEffect.trim(), ",", "{", "}", true, true);
					AutoEffectArray[0] = splitIgnoreBetween(AutoEffectArray[0], /\s+/g, "{", "}", true, true);
				}
			}
			AutoEffectArray = AutoEffectArray.map(e => (typeof e == "string") ? e.trim() : e);
			AutoScriptArray.push(AutoEffectArray);
		} else {
			break;
		}
	} while (AutoScript.length > 1)

	/* Return the converted AutoScript */
	return AutoScriptArray;
}

// Replaces all aliases in the AutoScript with their full AutoScripts
// An alias consists of any ordering of Words and #Insert values surrounded by curly brackets, ex. "{#Insert1 Word1 Word2 #Insert2 Word3}"
//   When added to an item all #Inserts must be replaces with any value, which are inserted into the resulting AutoScript
// The alias is compared to an aliasList object consisting of format-AutoScript pairs: {aliasFormat1:aliasAutoScript1, aliasFormat2:aliasAutoScript2, ...}
//   Ex. a valid format-AutoScript pair could be "{#Ailment Vigor #N}":"(Require {3+#N} #Ailment)(DicePower #N)"
//   If {Burn Vigor 2} is added to an item, it should execute as (Require {3+2} Burn)(DicePower 2)
function autoScriptApplyAliases(AutoScript, aliasList, mode="normal", errors={}, aliasDepth=0) {
	
	AutoScript = cleanAutoScript(AutoScript);
	if ((/(?<!\)[^\)]+)(\{.+?\})(?![^\(]+\()/).test(AutoScript) && length(errors) == 0) { // Only run if at least one alias is in the AutoScript
		for (let [aliasFormatRaw, aliasAutoScript] of Object.entries(aliasList)) {

			/* Throws an error if either the aliasFormat or aliasAutoScript is undefined */
			if (!aliasAutoScript) {
				autoEffectError(errors, "Invalid Alias", aliasFormatRaw, {}, "format"); break;
			}

			/* Throws an error if the aliasFormat only contains Inserts, making it match with all aliases of the same length */
			if (!(/(?<!#[^\s,.\-\/]*)([^#\s,.\-/\\\?]+)/g).test(aliasFormatRaw)) {
				AutoScript = AutoScript.replace(/(\{.+?\})(?![^\(]+\))/g, "");
				autoEffectError(errors, "Invalid Alias", aliasFormatRaw, {}, "inserts");
			}

			if (mode == "normal") { aliasAutoScript = aliasAutoScript.replace(/\[#(.+?)#\]/g,""); } // When parsing normal AutoEffects, remove all trigger blocks from the alias AutoScript

			/* Generate a RegExp that matches the format */
			let [sep, nsep] = ['[\\s,.\\-\\\\/}]', '[^"\\s,.\\-\\\\/}]'] 			// Seperator characters
			let aliasFormat = aliasFormatRaw.trim()
				.replace(/([^\s,.\-/\\\?]+)/g, "($1)") 								// Surround all Words and #Inserts in a capturing group. Doing this makes any ? after the Word make the entire word optional
				.replace(/(\(#[^\s,.\-/\\\?]+)/g, `((?:"[^"]+?")|${nsep}+)`) 		// Replace all #Inserts with a capturing group looking for any value or format. Formats may include seperator characters
				.replace(/\s+(?=[^\s,.\-/\\\?]+\)\?)/g, `${sep}*`)			 		// Replace all spaces just before an optional insert with a RegExp that matches with any or no seperator character
				.replace(/\s+/g, `${sep}+`);			 							// Replace all remaining spaces with a RegExp that matches with any seperator character

			let aliasMatches = AutoScript.match(new RegExp(`{${sep}*${aliasFormat}${sep}*}`, "g")) || [];
			
			if (aliasMatches.length > 0) {
				//console.log(new RegExp(`{\\s*${aliasFormat}\\s*}`, "g"), aliasMatches)

				/* Prepare a list of #Insert-value pairs */
				aliasMatches.forEach(match => {
					let insertArray = aliasFormatRaw.replace("?","").split(/[\s,.\-/\\]+/);
					let valueArray = splitIgnoreBetween(match.slice(1, -1), /[\s,.\-/\\]+/g, '"');
					let insertValueList = insertArray.reduce((acc, insert, i) => Object.assign(acc, {[insert]:valueArray[i]}),{})
					//console.log(insertArray, valueArray)
					//console.log(insertValueList)

					/* Insert any insert values from the alias format */
					let insertAutoScript = aliasAutoScript;
					for (const [insert, value] of Object.entries(insertValueList)) {
						insertAutoScript = insertAutoScript.replaceAll(insert, value || "");
					}

					/* If the aliasAutoScript itself includes aliases, apply those as well */
					/* Throws an error and hinders further recursion if aliasDepth reaches 100 */
					/*   This should only ever happen if the alias creates an infinite loop of cyclically referencing aliases */
					aliasDepth++
					if (aliasDepth < 100) {
						autoScriptApplyAliases(aliasAutoScript, aliasList, "normal", errors, aliasDepth);
					} else {
						AutoScript = AutoScript.replace(/(?<!\)[^\)]+)(\{.+?\})(?![^\(]+\()/g, "");
						autoEffectError(errors, "Invalid Alias", match, {}, "loop");
					}

					AutoScript = AutoScript.replace(match, insertAutoScript);
				});
			}
		}

	/* Throw an error for each alias that remains in the AutoScript */
	AutoScript = cleanAutoScript(AutoScript);
	let restAliasArray = AutoScript.match(/\)(\{.+?\})\(/g); // Ignores curly brackets inside parenthesis (used for math and not aliases)
	if (restAliasArray) {
		restAliasArray.forEach(restAlias => {
				if (!Object.values(errors).some(error => error.includes(restAlias))) { // Avoids duplicate messages
			AutoScript = AutoScript.replace(restAlias,"");
					autoEffectError(errors, "Invalid Alias", restAlias, {}, "missing");
				}
		});
		}
	}

	return AutoScript;
}

function translateAutoEffectToEnglish(AutoEffect, validTargets, validOptions, validConOptions, targetIndex, optionIndex) {
	
	/* Translate AutoEffect names */
	AutoEffect[0][0] = getAutoEffectFromTranslation(AutoEffect[0][0]);

	/* Translate Target */
	if (validTargets && AutoEffect[0][targetIndex]) {
		if (validTargets.some(target => (target.includes("#Bar")))) validTargets.push("#Bar");
		if (validTargets.length > 0) {
			AutoEffect[0][targetIndex] = getTargetFromTranslation(AutoEffect[0][targetIndex], validTargets);
		}
		if (AutoEffect[0][targetIndex].includes("Unknown")) {
			console.error("Translation error with AutoEffect name " + AutoEffect[0][0]);
		}
	}
	
	/* Translate Options */
	if (length(validOptions) > 0) {
		for (let j = optionIndex; j < AutoEffect[0].length; j++) {
			if (getOptionFromTranslation(AutoEffect[0][j], "Unknown") != "Unknown" + AutoEffect[0][j]) {
				AutoEffect[0][j] = getOptionFromTranslation(AutoEffect[0][j]);
			}
		}
	}

	/* Translate Conditional Options */
	if (length(validConOptions) > 0) {
		for (let k = 1; k < AutoEffect.length; k++) {
			for (const option of Object.keys(validConOptions)) {
				let translatedOption = "#" + getConOptionFromTranslation(option);
				if (translatedOption) {
					AutoEffect[k].replace(translatedOption, "#" + option);
				}
			}
		}
	}

	return AutoEffect;
}

function parseAutoScriptStyling(AutoScriptStyling) {
	let stylingList = {};
	let stylingRule = "";

	/* Remove all newlines, tab spaces and comments */
	AutoScriptStyling = cleanAutoScript(AutoScriptStyling);

	do {
		AutoScriptStyling = AutoScriptStyling.trim();

		/* Checks if an styling rule still remains in the AutoScript */
		if (AutoScriptStyling.indexOf("(") == 0 && AutoScriptStyling.indexOf(")")) {

			/* Removes the next styling rule from the string. Removes the parentheses */
			stylingRule = AutoScriptStyling.substring(1, AutoScriptStyling.indexOf(")"));
			AutoScriptStyling = AutoScriptStyling.substring(AutoScriptStyling.indexOf(")")+1);

			stylingRule = stylingRule.trim().split(",");
			stylingRule = stylingRule.map(e => e.trim());

			stylingList[stylingRule[0]] = [stylingRule[1], stylingRule[2], stylingRule[3]];
		} else {
			break;
		}
	} while (AutoScriptStyling.length > 1)

	/* Return the styling list */
	return stylingList;
}
/*--- AutoScript functions end ---*/




/*--- Assorted AutoEffect functions ---*/
function autoEffectEntry(message) {
	return "<div class='autoeffectEntry'>" + message + "</div>";
}
function autoEffectSection(header, message, collapseSections, iconFolder="icons", iconName="gear", iconColor="#85a874") {
	let newEntry  = "<div class='autoeffectContainer'>"
		newEntry += `<div style="background-color: #222; height: 25px; border: 2px #000 solid; color: #fff">`
		newEntry += `<div style="float: left; height: 25px; width: 25px; margin-right: 7px; background-color: ${iconColor};">`
		newEntry += `${getIcon(iconFolder, iconName)}`
		newEntry += `</div>`;
		newEntry += `<div class="autoEffectTitle" style="overflow: hidden ; height: 20px ; padding-top: 5px ; float: left"><b>${header}</b></div>`
		newEntry += `</div>` + message + "</div>";
	if (collapseSections == "true") {
		newEntry = newEntry.replaceAll("autoeffectContainer'>", "autoeffectContainer collapseSection'><div class='arrow'></div>")
	}

	return newEntry;
}

function autoEffectTranslateMessage(message) {
	let returnMessage = message
		.replaceAll("Burn", getTranslationByKeyCustom("Burn","ailments-burn"))
		.replaceAll("Bleed", getTranslationByKeyCustom("Bleed","ailments-bleed"))
		.replaceAll("Paralysis", getTranslationByKeyCustom("Paralysis","ailments-paralysis"))
		.replaceAll("Fragile", getTranslationByKeyCustom("Fragile","ailments-fragile"))
		.replaceAll("Protection", getTranslationByKeyCustom("Protection","ailments-protection"))
		.replaceAll("Stagger Protection", getTranslationByKeyCustom("Stagger Protection","ailments-stgprotection"))
		.replaceAll("Strength", getTranslationByKeyCustom("Strength","ailments-strength"))
		.replaceAll("Endurance", getTranslationByKeyCustom("Endurance","ailments-endurance"))
		.replaceAll("Haste", getTranslationByKeyCustom("Haste","ailments-haste"))
		.replaceAll("Feeble", getTranslationByKeyCustom("Feeble","ailments-feeble"))
		.replaceAll("Disarm", getTranslationByKeyCustom("Disarm","ailments-disarm"))
		.replaceAll("Bind", getTranslationByKeyCustom("Bind","ailments-bind"))
		.replaceAll("Smoke", getTranslationByKeyCustom("Smoke","ailments-smoke"))
		.replaceAll("Charge", getTranslationByKeyCustom("Charge","ailments-charge"))
		.replaceAll("Fortune", getTranslationByKeyCustom("Fortune","ailments-fortune"))
		.replaceAll("HP", getTranslationByKeyCustom("HP","bar-health-shortened"))
		.replaceAll("ST", getTranslationByKeyCustom("ST","bar-stagres-shortened"))
		.replaceAll("SP", getTranslationByKeyCustom("SP","bar-sanity-shortened"))
		.replaceAll("THP", getTranslationByKeyCustom("THP","bar-health-temp-shortest"))
		.replaceAll("TST", getTranslationByKeyCustom("TST","bar-stagres-temp-shortest"));
	
	return returnMessage;
}

/* Converts an AutoEffect from an array back into its string form */
function autoEffectToString(AutoEffect, modList={}) {

	if (!Array.isArray(AutoEffect)) { return AutoEffect; }

	let autoEffectString = "";
	let hasConditionals = Array.isArray(AutoEffect[0]);
	let innerAutoEffect = (hasConditionals) ? AutoEffect[0] : AutoEffect;
	let outerAutoEffect = (hasConditionals) ? AutoEffect.slice(1) : [];
	let effectFormat = autoEffectFormats[innerAutoEffect[0]] || {};
	if (effectFormat.copy) effectFormat = autoEffectFormats[effectFormat.copy];

	let valueIndex = targetIndex = false;
	if (effectFormat.value) valueIndex = 1;
	if (effectFormat.target) targetIndex = 2;
	if (effectFormat.reverse) [valueIndex, targetIndex] = [targetIndex, valueIndex]

	/* Apply modifications */
	if (modList.changeName) {
		innerAutoEffect[0] = modList.changeName;
	}
	if (modList.changeValue && valueIndex) {
		innerAutoEffect[valueIndex] = modList.changeValue;
	}
	if (modList.changeTarget && targetIndex) {
		innerAutoEffect[targetIndex] = modList.changeTarget;
	}
	if (modList.addOptions) {
		innerAutoEffect = [...innerAutoEffect, ...modList.addOptions]
	}
	if (modList.removeOptions) {
		modList.removeOptions.forEach(removeOption => {
			innerAutoEffect = innerAutoEffect.filter(option => !(new RegExp(option,"ig").test(removeOption)));
		});
	}

	/* If the AutoEffect uses a string format as its value, add back in the surrounding quotes */
		if (effectFormat.value == "string") {
			innerAutoEffect[valueIndex] = '"' + innerAutoEffect[valueIndex] + '"';
	}

	autoEffectString += innerAutoEffect.join(" ")
	if (outerAutoEffect.length > 0) {
		autoEffectString += ", " + outerAutoEffect.join(", ");
	}
	return "(" + autoEffectString + ")";
}

/* Creates a new conditional button*/
function createConditionalButton(buttonName, buttonAutoScript, iconFolder, iconName, iconColor) {
	let output = {}
	let buttonIcon = getIcon(iconFolder, iconName, "false", "url");

	let newrowid = generateRowID();
	output[`repeating_conditionalButtons_${newrowid}_buttonName`] = buttonName;
	output[`repeating_conditionalButtons_${newrowid}_buttonAutoScript`] = buttonAutoScript;
	output[`repeating_conditionalButtons_${newrowid}_buttonIcon`] = buttonIcon;
	output[`repeating_conditionalButtons_${newrowid}_buttonColor`] = iconColor;
	setAttrs(output);
}

/* Removes all conditional buttons */
function resetConditionals() {
	getSectionIDs("conditionalButtons", function(idarray) {
		for(var i=0; i < idarray.length; i++) {
			removeRepeatingRow("repeating_conditionalButtons_" + idarray[i]);
		}
	});
}
/*--- Assorte AutoEffect functions end ---*/



/*--- Export/Import functions ---*/
const attrkeys = {
	Character: ["character_nameBase", "instinct", "wisdom", "justice", "charm", "insight", "temperance", "EXP", "character_job", "age", "height", "character_origin", "character_residence", "character_assets", "character_ahn", "character_url", "character_summary", "character_combatnote", "character_history", "character_relations", "character_notes", "character_desc", "character_personality", "character_background"],

	Settings: ["settingWhisperRolls",
	"settingSimpleDisplay", "settingExtraEquip", "settingHideSpecial", "settingHelperText", "settingHideShare", "settingHideUses",
	"settingLoopEnabled", "configLoopDelay", "configUpdateDelay", "configTrackerItemName", "settingAutoDetect", "settingTurnUpdate", "settingMultihitFull", "settingMultihitUses",
	"settingMuteMessage", "settingHideNextTurn", "settingBurnImmune", "settingBleedImmune",
	"settingAutoApplyDamage", "settingHideBarUpdate",
	"settingCollapseAutoEffectSections", "settingHideConditionalButtonReminder", "settingHideChatButtons", "settingHideBaseEffect", "AutoScriptStyling", "autoScriptAlias"],

	Equip: ["outfitName", "outfitRank", "outfitDescription", "outfitEffect", "defDice1", "defDice2", "defDice3", "evdDice1", "evdDice2", "evdDice3", "outfitImmune1", "outfitImmune2", "outfitImmune3", "outfitImmune4", "outfitImmune5", "outfitImmune6", "bleedResist", "burnResist", "damageResist", "outfitAutoScript",

	"weapon1Name", "weapon1Rank", "weapon1Description", "weapon1Effect", "weapon1Dice1", "weapon1Dice2", "weapon1Dice3", "weapon1Type", "weapon1Range", "weapon1Uses", "weapon1Uses_max", "weapon1UseType", "weapon1AutoScript",
	"weapon2Name", "weapon2Rank", "weapon2Description", "weapon2Effect", "weapon2Dice1", "weapon2Dice2", "weapon2Dice3", "weapon2Type", "weapon2Range", "weapon2Uses", "weapon2Uses_max", "weapon2UseType", "weapon2AutoScript",
	"weapon3Name", "weapon3Rank", "weapon3Description", "weapon3Effect", "weapon3Dice1", "weapon3Dice2", "weapon3Dice3", "weapon3Type", "weapon3Range", "weapon3Uses", "weapon3Uses_max", "weapon3UseType", "weapon3AutoScript",
	"weapon4Name", "weapon4Rank", "weapon4Description", "weapon4Effect", "weapon4Dice1", "weapon4Dice2", "weapon4Dice3", "weapon4Type", "weapon4Range", "weapon4Uses", "weapon4Uses_max", "weapon4UseType", "weapon4AutoScript",

	"augmentName", "augmentRank", "augmentType", "augmentDescription", "augmentEffect", "augmentAutoScript",

	"tool1Name", "tool1Rank", "tool1Description", "tool1Effect", "tool1Portable", "tool1Reusable", "tool1Uses", "tool1Uses_max", "tool1Icon", "tool1AutoScript",
	"tool2Name", "tool2Rank", "tool2Description", "tool2Effect", "tool2Portable", "tool2Reusable", "tool2Uses", "tool2Uses", "tool2Uses_max", "tool2Icon", "tool2AutoScript",
	"tool3Name", "tool3Rank", "tool3Description", "tool3Effect", "tool3Portable", "tool3Reusable", "tool3Uses", "tool3Uses", "tool3Uses_max", "tool3Icon", "tool3AutoScript",
	"tool4Name", "tool4Rank", "tool4Description", "tool4Effect", "tool4Portable", "tool4Reusable", "tool4Uses", "tool4Uses", "tool4Uses_max", "tool4Icon", "tool4AutoScript",

	"special1Name", "special1Rank", "special1Risk", "special1Range", "special1Duration", "special1Description", "special1AutoScript",
	"special2Name", "special2Rank", "special2Risk", "special2Range", "special2Duration", "special2Description", "special2AutoScript"],

	Distort: ["distort_name", "distortWork", "distortCounter", "distortWorkInstinct", "distortWorkWisdom", "distortWorkJustice", "distortWorkCharm", "distortWorkInsight", "distortWorkTemperance", "distortResultGood", "distortResultNormal", "distortResultBad", "distortWeaponDice1", "distortWeaponDice2", "distortWeaponDice3", "distortDefDice1", "distortDefDice2", "distortDefDice3", "distortEvdDice1", "distortEvdDice2", "distortEvdDice3", "distortDescription", "distortEffect", "distortDescription2", "distortEffect2", "distort_url", "distort_summary", "distort_behavior", "distort_combatnote", "distort_origin", "distort_notes", "distort_taboo", "distort_appearance", "distort_atmosphere", "distort_story"],

	Ego: ["egoName", "egoCondition", "egoType", "egoRank", "egoIdeology", "egoDescription", "egoEffect", "egoWeaponDice1", "egoWeaponDice2", "egoWeaponDice3", "egoWeaponType", "egoWeaponRange", "egoDefDice1", "egoDefDice2", "egoDefDice3", "egoEvdDice1", "egoEvdDice2", "egoEvdDice3", "egoImmune1", "egoImmune2", "egoImmune3", "egoImmune4", "egoImmune5", "egoImmune6", "egoUses", "egoUses_max", "egoUseType", "egoRisk", "egoRange", "egoDuration", "bleedResist_ego", "burnResist_ego", "damageResist_ego", "egoAutoScript"],

	Skills: ["skill1Name", "skill1Rank", "skill1Type", "skill1Light", "skill1Dice1", "skill1Dice2", "skill1Dice3", "skill1Description", "skill1Effect", "skill1AutoScript",
	"skill2Name", "skill2Rank", "skill2Type", "skill2Light", "skill2Dice1", "skill2Dice2", "skill2Dice3", "skill2Description", "skill2Effect", "skill2AutoScript",
	"skill3Name", "skill3Rank", "skill3Type", "skill3Light", "skill3Dice1", "skill3Dice2", "skill3Dice3", "skill3Description", "skill3Effect", "skill3AutoScript",
	"skill4Name", "skill4Rank", "skill4Type", "skill4Light", "skill4Dice1", "skill4Dice2", "skill4Dice3", "skill4Description", "skill4Effect", "skill4AutoScript",
	"skill5Name", "skill5Rank", "skill5Type", "skill5Light", "skill5Dice1", "skill5Dice2", "skill5Dice3", "skill5Description", "skill5Effect", "skill5AutoScript",
	"skill6Name", "skill6Rank", "skill6Type", "skill6Light", "skill6Dice1", "skill6Dice2", "skill6Dice3", "skill6Description", "skill6Effect", "skill6AutoScript",
	"egoSkill1Name", "egoSkill1Rank", "egoSkill1Type", "egoSkill1Light", "egoSkill1Dice1", "egoSkill1Dice2", "egoSkill1Dice3", "egoSkill1Description", "egoSkill1Effect", "egoSkill1AutoScript",
	"egoSkill2Name", "egoSkill2Rank", "egoSkill2Type", "egoSkill2Light", "egoSkill2Dice1", "egoSkill2Dice2", "egoSkill2Dice3", "egoSkill2Description", "egoSkill2Effect", "egoSkill2AutoScript",
	"egoSkill3Name", "egoSkill3Rank", "egoSkill3Type", "egoSkill3Light", "egoSkill3Dice1", "egoSkill3Dice2", "egoSkill3Dice3", "egoSkill3Description", "egoSkill3Effect", "egoSkill3AutoScript",
	"egoSkill4Name", "egoSkill4Rank", "egoSkill4Type", "egoSkill4Light", "egoSkill4Dice1", "egoSkill4Dice2", "egoSkill4Dice3", "egoSkill4Description", "egoSkill4Effect", "egoSkill4AutoScript",
	"egoSkill5Name", "egoSkill5Rank", "egoSkill5Type", "egoSkill5Light", "egoSkill5Dice1", "egoSkill5Dice2", "egoSkill5Dice3", "egoSkill5Description", "egoSkill5Effect", "egoSkill5AutoScript",
	"egoSkill6Name", "egoSkill6Rank", "egoSkill6Type", "egoSkill6Light", "egoSkill6Dice1", "egoSkill6Dice2", "egoSkill6Dice3", "egoSkill6Description", "egoSkill6Effect", "egoSkill6AutoScript"],

	Global: ["global_ruleName", "global_healthBase", "global_healthStat", "global_healthStatMod", "global_healthRankMod", "global_staggerBase", "global_staggerStat", "global_staggerStatMod", "global_staggerRankMod", "global_sanityBase", "global_sanityStat", "global_sanityStatMod", "global_sanityRankMod", "global_lightBase", "global_lightRankMod", "global_distortLightBase", "global_distortLightRankMod",
	"global_actionBase", "global_actionRankMod", "global_reactionBase", "global_reactionRankMod", "global_actionTradeReaction",
	"global_lightRegenBase", "global_lightRegenRankMod", "global_lightRegenStatMod", "global_lightRegenStaggerSelf", "global_lightRegenStaggerEnemy", "global_lightRegenDefeatEnemy", "global_lightRegenRoundEnd",
	"global_combatEndLightBase", "global_combatEndLightRankMod", "global_recoverHPBase", "global_recoverHPStatMod", "global_recoverHPRankMod", "global_recoverSPBase", "global_recoverSPStatMod", "global_recoverSPRankMod", "global_recoverStaggerMode", "global_recoverStaggerVal", "global_recoverLightBase", "global_recoverLightRankMod",
	"global_attStat", "global_defStat", "global_evdStat", "global_evdAilment", "global_multiPenalty", "global_multiStyle",
	"global_staggerRecoverPercent", "global_staggerRecoverBase", `global_staggerDurationMax`, "global_staggerSanity", "global_settingBar1", "global_settingBar2", "global_settingBar3",
	"global_burnDecayMode", "global_burnDecayVal", "global_burnNextTurnSetting", "global_bleedDecayMode", "global_bleedDecayVal", "global_bleedNextTurnSetting", "global_smokeDecayMode", "global_smokeDecayVal", "global_smokeNextTurnSetting", "global_smokeCalculationMode", "global_smokeCalculationVal", "global_chargeDecayMode", "global_chargeDecayVal", "global_chargeNextTurnSetting", "settingLimbusStyle"]
}
const repattrkeys = {
	ailments: ["ailName", "ailIcon", "ailDisplay", "ailTrigger", "ailNextTurn",
	"ailEffect", "ailEffectMode", "ailEffectVal",
	"ailDecayMode", "ailDecayVal", "ailDecayMin", "ailDecayWhenHit", "ailDecayRoundEnd",
	"ailMax", "ailMaxBehavior",
	"ailMessageCheck", "ailMessage",
	"ailDamageTypeTrigger", "ailBeforeResistance", "ailPositiveType", 
	"ailCustomResistance", "ailCustomResistanceNum", "ailCustomResistanceNumEgo"],

	rollformats: ["mode", "type", "damagetype", "count", "max", "power", "autoscript"],

	inventory: [] // Add this later
}

/* Data Exporter */
on("clicked:export", function(info) { 
	dataExport();
});
function dataExport(override, target) {
	
	getAttrs(["exportType"], function(values) {
	
	let exporttype = override || values.exportType;
	let attrkey = [];
	let output = target || "editorOutput";

	/* Format key */
	if (exporttype) {
		if(exporttype == "All") {
			attrkey = Object.keys(attrkeys).flatMap(type => attrkeys[type]);
		} else {
			attrkey = attrkeys[exporttype];
		}
	}
	
	/* Get attributes */
	getAttrs(attrkey, function(values) {

	/* Export attribute data */
	setAttrs({[output]: packageAttrData(values)});
	});
	});
}

/* Data Importer */
on("clicked:import", function(info) {
	dataImport();
});
function dataImport(target, prefix, replacestr) {
	
	let inputsource = target || "editorInput";
	getAttrs([inputsource], function(values) {

	/* Prepare input attribute data */
	let input = values[`${inputsource}`];
	input = input.replace(/	/g, ''); /* Remove whitespace */
	input = input.replace(/\n/g, "@"); /* Temporarily replace line breaks */
	input = input.replace(/"/g, ""); /* Temporarily replace " quotes */
	
	if (replacestr && prefix) {
		input = input.replaceAll(replacestr, prefix);
	}

	let inputarray = "[" + input.replace(/`/g, '"') + "]";
	const output = {};

	/* Parse data into attributes */
	inputarray = JSON.parse(inputarray);

	for(let i = 0; i < inputarray.length; i++) {
		let attrtarget = inputarray[i][0].toString().replace(/@/g, "\n"); /* Reintroduce line breaks */
		let attrvalue = inputarray[i][1].toString().replace(//g, '"'); /* Reintroduce " quotes */
		
		output[`${attrtarget}`] = attrvalue;
	}

	/* Import attributes */
    setAttrs(output);
	});
}

/* Data Exporter - Repeating Section */
on("clicked:exportRepeating", function(info) { 
	dataExportRepeating("ailments");
});
function dataExportRepeating(section, target) {

	getSectionIDs(`repeating_${section}`, function(idarray) {

	let attrkey = [];
	let replaceList = {};
	let output = target || "editorOutput";

	/* Format key */
    for(var i=0; i < idarray.length; i++) {
		repattrkeys[section].forEach(key => {
			attrkey.push(`repeating_${section}_${idarray[i]}_${key}`);
			replaceList[`repeating_${section}_${idarray[i]}_${key}`] = `${i}_${key}`;
		}); 
    }

	/* Get attributes */
	getAttrs(attrkey, function(values) {

	/* Import attributes */
	setAttrs({[output]: packageAttrData(values, replaceList)});
	});
	});
}

/* Data Importer - Repeating Section */
on("clicked:importRepeating", function(info) { 
	dataImportRepeating("ailments");
});
function dataImportRepeating(section, override, target) {

	let inputsource = target || "ailmentEditor";
	getAttrs([inputsource, "customImportMode", "settingCustomCollapse"], function(values) {
	
	let mode = override || values.customImportMode;
	let collapseSetting = values.settingCustomCollapse;

	/* Prepare input attribute data */
	let input = values[inputsource];
	input = input.replace(/	/g, ''); /* Remove whitespace */
	input = input.replace(/\n/g, "@"); /* Temporarily replace line breaks */
	input = input.replace(/"/g, ""); /* Temporarily replace " quotes */

	let inputarray = "[" + input.replace(/`/g, '"') + "]";
	const output = {};

	/* Parse data into attributes */
	inputarray = JSON.parse(inputarray);

	let indexIds = {};

	if (inputarray.length > 0) {

		if (section == "ailments" && mode != "Add") {
			clearCustomAilments();
		}

		inputarray.forEach(attr => {

			let [attrid, attrtarget] = attr[0].split('_');
			let attrvalue = attr[1].toString();

			attrvalue = attrvalue.replace(/@/g, "\n"); /* Reintroduce line breaks */
			attrvalue = attrvalue.replace(//g, '"'); /* Reintroduce " quotes */

			/* Registering a new item */
			if (!indexIds[attrid]) {

				indexIds[attrid] = generateRowID();

				if (section == "ailments") {
					output[`repeating_${section}_${indexIds[attrid]}_ailCollapse`] = collapseSetting;
				}
			}
			output[`repeating_${section}_${indexIds[attrid]}_${attrtarget}`] = attrvalue;
		});
	} else {
		if (section == "ailments" && mode != "Add") {
			output[`repeating_${section}_${generateRowID()}_ailCollapse`] = collapseSetting;
		}
	}

	/* Import attributes */
	setAttrs(output);
	});
}

/* Export/Import tab: Swap button */ 
on("clicked:swap", function(info) {
	dataSwap();
});
function dataSwap() {
	getAttrs(["editorOutput", "editorInput"], function(values) {
	setAttrs({"editorOutput":values.editorInput, "editorInput":values.editorOutput});
	});
}

/* Export/Import tab: Clear buttons */
on("clicked:clearButton", function(info) {
    let buttonid = info.htmlAttributes.id.split('_')[1];
	setAttrs({[buttonid]:""});
});

/* Data Export/Import helper functions */
const dataStyles = {
	standard: ["[`", "`,`", "`]"],
	repeating: ["", ":", ""]
}
function packageAttrData(values={}, replaceList={}, dataFormat, repFormat, type="standard", options={}) {
	let style = dataStyles[type];
	if (!dataFormat) dataFormat = values;
	let attrData = []
	let prevAttrs = {}

	for (let [key, value] of Object.entries(dataFormat)) {
		
		// Handle check values used for repeating attributes. A repitem which fails a check is not included in the output data
		if (Array.isArray(value)) {
			let checkFunc = value[1];
			value = value[0];

			switch (checkFunc.apply(null, [{self: values[key], ...prevAttrs}])) {
				case "exclude:rep": return "";
				case "include:rep": continue; // repeating_rollformats:rollFormats
				case "exclude:attr": continue;
				case "include:attr": break;
			} 
		}

		// Handle repeating attribute data format
		if (typeof(value) == "object") {
			let [repsection, repalias, repoptionstext] = key.split(":");
			let repData = [];

			let repoptions = {...options};
			if (repoptionstext) {
				if (repoptionstext.includes("includeDefault")) { repoptions.ignoreDefault = false; }
				else if (repoptionstext.includes("ignoreDefault")) { repoptions.ignoreDefault = true; }
			}

			for (let i = 0; i < length(repFormat[key] || 0); i++) {
				let newRepData = packageAttrData(values, {}, repFormat[key][i], {}, "repeating", repoptions);
				if (newRepData) { repData.push(newRepData); }
			}

			if (repData.length > 0) {
				attrData.push([repalias, repData.join(", ")]);
			}
		}

		// Handle standard attribute data format
		else {
			// Apply a prefix if one is provided
			let modkey = (options.prefix && type != "repeating") ? options.prefix + key : key;

			if (options.ignoreDefault && dataFormat[key] == values[modkey]) {
				if (type == "repeating") {
					return "";
				} else {
					continue;
				}
			}
			else if (type == "repeating") {
				attrData.push(values[modkey]);
			}
			else {
				attrData.push([key, values[modkey]]);
			}
			prevAttrs[key.split("_")[3] || key] = values[modkey];
		}
	}

	if (typeof(attrData[0]) != "object") { attrData = [attrData] }
	let textbase = attrData.map(data => style[0] + data.join(style[1]) + style[2]).join(", ");

	/* Legacy code for the old packaging method */
	if (textbase.length > 0 && length(replaceList) > 0) {
		textbase = textbase.replace(/	/g, ''); // Remove whitespace
		
		for (const [replacestr, prefix] of Object.entries(replaceList)) {
			textbase = textbase.replaceAll(replacestr, prefix);
		}
	}

	return textbase;
}













/* Item Editor - LEGACY CODE */
/* Item attributes used in the item editor as well as their default values. Includes both normal and repeating attributes */
/* When creating a new item, override the default values with those of the specific item created (see below) */
/* In addition to a default value a check function can be provided. This is used in packageAttrData() */
const itemEditorAttrs = {
	"type": "None",
	
	"optionRollFormat": 0,
		"repeating_rollformats:rollFormats:includeDefault": {
			rollUse: "Roll", rollType: "Any", rollDamage: "None",
			diceCount: 1, diceMax: 6, dicePower: 0, AutoScript: ""
		},
	
	"optionUses": 0,

	"optionLinked": 0,

	"optionMystery": 0,
	
	"optionEquipSlots": 0,

	"optionTags": 0,

	"optionStyle": 0,
		"optionIcon": 0,
		"optionColor": 0,
	
	"optionLimitedUses": 0,
		"optionUses": 0, "usesMax": 0, "useMode": "Limited",
		"optionLightCost": 0, "lightCost": 0,
	
	"optionResistance": 0,
		"optionDamageResistance": 0,
		"optionAilmentResistance": 0,
			"burnResist": 0, "bleedResist": 0, "damageResist": 0,
			"repeating_ailments:customResist:ignoreDefault": {
				ailCustomResistance: 0, ailName: "Unknown", itemAilCustomResistanceNum: 0
			}
}

/* Item editor close button */
on("clicked:closeItemEdit", function(info) {
	saveEditor("item", itemEditorAttrs, () => {
		closeEditor("item");
	});
});

/* Item editor sync changes */
on(Object.keys(itemEditorAttrs).reduce((rows, key) => {
	
	/* Sync repeating attributes */
	if (key.includes("repeating_")) {
		let repsection = key.split(":")[0];
		return rows += Object.keys(itemEditorAttrs[key]).reduce((acc, repkey) => acc += ` change:${repsection}:${repkey}`, "");
	}
	/* Sync normal attributes */
	else {
		return rows += ` change:item${capitalize(key)}`;
	}
}, ""), function(info) {
	saveEditor("item", itemEditorAttrs);
});
/*--- Export/Import functions end ---*/















/* Action: Toggle combat mode */
on('clicked:combatToggle', (info) => {
	getSectionIDs(`repeating_global`, idarray => {
	let id = `repeating_global_${idarray[0]}_`;

	getAttrs(["charRankNum", "StagRes", "StagRes_max", "Light", "Light_max", `${id}combatEndStaggerMode`, `${id}combatEndStaggerVal`, `${id}combatEndLightBase`, `${id}combatEndLightRankMod`], function(values) {
		let output = {}

		if (info.htmlAttributes.title == "Begin combat") {
			output.combatState = "true";
			rollChallenge("speed");
		} else {
			output.combatState = "0";

			let [ST, ST_max] = [parseInt(values.StagRes), parseInt(values.StagRes_max)]
			let [Light, Light_max] = [parseInt(values.Light), parseInt(values.Light_max)]
			let [staggerMode, staggerVal] = [values[`${id}combatEndStaggerMode`], parseFloat(values[`${id}combatEndStaggerVal`])]
			let [lightBase, lightRank] = [parseFloat(values[`${id}combatEndLightBase`]), values.charRankNum * parseFloat(values[`${id}combatEndLightRankMod`])]

			output.StagRes = calcStagger(ST, ST_max, staggerVal, staggerMode);
			output.Light = Math.min(Light + Math.floor(lightBase + lightRank), Light_max);
		}

		AutoScriptMain("", "Combat end", "true", "true", {}, ()=>{}, getTranslationByKeyCustom("Combat end", "autoeffect-trigger-combatend"));

		setAttrs(output);
	});
	});
});
function calcStagger(ST, ST_max, staggerVal, staggerMode) {
	log({arguments})
	switch (staggerMode) {
		case "x": return Math.min(Math.floor(ST + (staggerVal * ST_max)), ST_max);
		case "+": return Math.min(Math.floor(ST + staggerVal), ST_max);
		case "=": return Math.floor(staggerVal);
	}
}

/* Action: Recover */
on('clicked:recover', (info) => {
	getSectionIDs(`repeating_global`, idarray => {
	let id = `repeating_global_${idarray[0]}_`;

	getAttrs([...statNames, "charRankNum", "StagRes", "StagRes_max", "HP", "HP_max", "SP", "SP_max", "Light", "Light_max", `${id}healthStat`, `${id}recoverHPBase`, `${id}recoverHPStatMod`, `${id}recoverHPRankMod`,
		`${id}recoverStaggerMode`, `${id}recoverStaggerVal`, `${id}sanityStat`, `${id}recoverSPBase`, `${id}recoverSPStatMod`, `${id}recoverSPRankMod`, `${id}recoverLightBase`, `${id}recoverLightRankMod`], function(values) {

		let [rank, hpStatNum, spStatNum] = [parseInt(values.charRankNum), parseInt(values[values[`${id}healthStat`]]), parseInt(values[values[`${id}sanityStat`]])]
		let [HP, HP_max, hpBase,  HPstat, HPrank] = [parseInt(values.HP), parseInt(values.HP_max), parseFloat(values[`${id}recoverHPBase`]), hpStatNum * parseFloat(values[`${id}recoverHPStatMod`]), rank * parseFloat(values[`${id}recoverHPRankMod`])]
		let [SP, SP_max, spBase, SPstat, SPrank] = [parseInt(values.SP), parseInt(values.SP_max), parseFloat(values[`${id}recoverSPBase`]), spStatNum * parseFloat(values[`${id}recoverSPStatMod`]), rank * parseFloat(values[`${id}recoverSPRankMod`])]
		let [Light, Light_max, lightBase, lightRank] = [parseInt(values.Light), parseInt(values.Light_max), parseFloat(values[`${id}recoverLightBase`]), rank * parseFloat(values[`${id}recoverLightRankMod`])]
		let [ST, ST_max, staggerMode, staggerVal] = [parseInt(values.StagRes), parseInt(values.StagRes_max), values[`${id}recoverStaggerMode`], parseFloat(values[`${id}recoverStaggerVal`])]

		let output = {
			HP: Math.min(Math.floor(HP + hpBase + HPstat + HPrank), HP_max),
			SP: Math.min(Math.floor(SP + spBase + SPstat + SPrank), SP_max),
			Light: Math.min(Math.floor(Light + lightBase + lightRank), Light_max),
			StagRes: calcStagger(ST, ST_max, staggerVal, staggerMode)
		}

		AutoScriptMain("", "Recover", "true", "true", {}, ()=>{}, getTranslationByKeyCustom("Recover", "autoeffect-trigger-recover"));

		setAttrs(output);
	});
	});
});


/* Action: Lock section from sync */
on('clicked:lockSection', (info) => {

	let target = info.htmlAttributes.id.split('_')[1];
	let attrname = "syncLock" + target;

	getAttrs([`${attrname}`], function(values) {

	let synclock = values[`${attrname}`];

	if(synclock != "true"){
          setAttrs({ [`${attrname}`]:"true" });

	}
	else {
	  setAttrs({ [`${attrname}`]:"0" });
	}

        });

});


/* Action: Custom ailment display toggle */
on('clicked:repeating_ailments:displaycustom', (info) => {
	const rowid = info.sourceAttribute.split('_')[2];

    getAttrs([`repeating_ailments_${rowid}_ailDisplay`], function(values) {
	let currentval = values[`repeating_ailments_${rowid}_ailDisplay`];
	let newval = (currentval == "0") ? "true" : "0";

          setAttrs({ [`repeating_ailments_${rowid}_ailDisplay`]:newval });
        });
});


/* Action: Custom ailment copy */
on('clicked:repeating_ailments:copycustom', (info) => {
	const rowid = info.sourceAttribute.split('_')[2];

    getAttrs([...ailmentAttrs.map(attr => `repeating_ailments_${rowid}_${attr}`)], function(values) {
	let newrowid = generateRowID();
	let newrowattrs = Object.fromEntries(Object.entries(values).map(attr => [attr[0].replace(rowid, newrowid), attr[1]]));
	newrowattrs[`repeating_ailments_${newrowid}_ailName`] += ` (${getTranslationByKeyCustom("Copy", "message-copy")})`;

	setAttrs(newrowattrs);
        });
});



/* Action: Clear all ailment data */
on('clicked:clearAilment', (info) => {
	clearCustomAilments();
});
function clearCustomAilments() {
   getSectionIDs("repeating_ailments", function(idarray) {
      for(var i=0; i < idarray.length; i++) {
        removeRepeatingRow("repeating_ailments_" + idarray[i]);
      }
	});
}

/* Check: Collapse all ailment data */
on('change:settingCustomCollapse', (info) => {
        getSectionIDs(`repeating_ailments`, idarray => {
            const fieldnames = idarray.reduce((rows,id) => [...rows, `repeating_ailments_${id}_ailCollapse`], '');
		
			getAttrs([...fieldnames, "settingCustomCollapse"], v => {
			const setting = v.settingCustomCollapse;
			const output = idarray.reduce((rows, id) => Object.assign(rows, {[`repeating_ailments_${id}_ailCollapse`]: setting}), {});
            setAttrs(output);
        });
    });
});


/* Action: Sync all ailment data */
on('clicked:syncAilment', (info) => {

getSectionIDs(`repeating_global`, idarray => {
           let id = `repeating_global_${idarray[0]}`;

 getAttrs(["ailmentEditor", `${id}_ailmentSettingSource`, "syncLockAilment", "syncStateAilment"], function(values) {

	let current = values.ailmentEditor;
	let source = values[`${id}_ailmentSettingSource`];

	const output = {};

	/* Translation prep */
	let langSync = "Sync";
	let langCustomAilments = "Custom Ailments";
	let langSyncSuccess = " sync successful.";
	let langSyncFail =  " is locked.\n Unlock before syncing.";
	let langSynced = "No change. Current data is synced.\n(Press Import if display does not match.)";
	let langSyncEmpty = "No change. Source data is empty.";

	if(getTranslationByKey("sync-button") != false){
	langSync = getTranslationByKey("sync-button");
	langCustomAilments = getTranslationByKey("editor-customailments");
	langSyncSuccess = getTranslationByKey("pop-sync-success");
	langSyncFail = getTranslationByKey("pop-sync-fail");
	langSynced = getTranslationByKey("pop-sync-synced");
	langSyncEmpty = getTranslationByKey("pop-sync-empty");

	}

	let syncHeader = langSync;
	let syncBody = "";
	let syncToggle = "0"; 
	let syncCheck = values.syncLockAilment;
	let syncState = values.syncStateAilment;

	if(source != null && source != ""){
	if(source != current && syncCheck != "true"){


	setAttrs({"ailmentEditor":source});

	dataImportRepeating("ailments", "Replace");
	syncBody = langCustomAilments + langSyncSuccess;
	syncToggle = "true"; 
	syncState = "0";

		}
	else if(source != current && syncCheck == "true"){
	syncBody = langCustomAilments + langSyncFail;
	syncToggle = "true"; 

		}
	else if(source == current) {
	syncBody = langSynced;
	syncToggle = "true"; 

		}
	}
	else {
	syncBody = langSyncEmpty;
	syncToggle = "true"; 
	}

	output[`popup_messageHeader`] = syncHeader;
	output[`popup_messageBody`] = syncBody;
	output[`popup_display`] = syncToggle;
	output[`syncStateAilment`] = syncState;

	setAttrs(output);

	});
	});
});

/* Gives a list with the following format: hasNextTurnField, count, nextTurnCount, countImmutable, countDecayPause, repeatingAilmentId, ailmentIconName */
/* countImmutable: Matches the count at the beginning of the AutoEffect execution. Should never be modified */
/* repeatingAilmentId: Is set to 0 for standard ailments */
async function exportAilmentList(overrideList={}, callback=() => {}) {
	getSectionIDs(`repeating_ailments`, idarray => {
	
	let ailmentList = {}
	const fieldnames = ailmentNames.concat(
		ailmentNames.reduce((rows,ailment) => [...rows, `${ailment}NextTurn`, `${ailment}DecayPause`], ''),
		idarray.reduce((rows,id) => [...rows, `repeating_ailments_${id}_ailName`, `repeating_ailments_${id}_ailNextTurn`,`repeating_ailments_${id}_ailNum`, `repeating_ailments_${id}_ailNumNextTurn`, `repeating_ailments_${id}_ailIcon`, `repeating_ailments_${id}_ailIconDisplay`, `repeating_ailments_${id}_ailDecayPause`], '')
	);

	getAttrs([...fieldnames, "settingHideNextTurn", "burnNextTurnSetting", "bleedNextTurnSetting", "smokeNextTurnSetting", "chargeNextTurnSetting"], function(values) {
		
		let settingHideNextTurn = values.settingHideNextTurn;
		const HasNextTurn = settingHideNextTurn == "true" ? 'false' : 'true';

		/* Export default ailments */
		ailmentNames.forEach(ailment => {
			if (["Burn", "Bleed", "Smoke", "Charge"].includes(ailment)) {
				let ailmentNextTurnSetting = (settingHideNextTurn == "true") ? "false" : values[ailment.toLowerCase()+"NextTurnSetting"];
				ailmentList[ailment] = [ailmentNextTurnSetting, parseInt(values[ailment]), parseInt(values[`${ailment}NextTurn`]), parseInt(values[ailment]), parseInt(values[`${ailment}DecayPause`]), 0, ailment];
			} else {
				ailmentList[ailment] = [HasNextTurn, parseInt(values[ailment]), parseInt(values[`${ailment}NextTurn`]), parseInt(values[ailment]), parseInt(values[`${ailment}DecayPause`]), 0, ailment];
			}
			if (overrideList.hasOwnProperty(ailment)) {
				ailmentList[ailment][1] = Math.max(parseInt(overrideList[ailment][0]), 0);
				ailmentList[ailment][3] = Math.max(parseInt(overrideList[ailment][1]), 0);
			}
		});

		/* Export custom ailments */
		idarray.forEach(id => {
			let ailName = values[`repeating_ailments_${id}_ailName`].replaceAll(" ","_");

			ailmentList[ailName] = [
				values[`repeating_ailments_${id}_ailNextTurn`],
				values[`repeating_ailments_${id}_ailNum`],
				values[`repeating_ailments_${id}_ailNumNextTurn`],
				values[`repeating_ailments_${id}_ailNum`],
				values[`repeating_ailments_${id}_ailDecayPause`],
				id,
				values[`repeating_ailments_${id}_ailIcon`]
			];

			if (overrideList.hasOwnProperty(ailName)) {
				ailmentList[ailName][1] = Math.max(overrideList[ailName.replaceAll(" ","_")][0], 0);
				ailmentList[ailName][3] = Math.max(overrideList[ailName.replaceAll(" ","_")][1], 0);
			}
		});

		callback(ailmentList);
	});
	});
}

function importAilmentList(ailmentList, returnMode="false") {
	let output = {}
	for (const [ailmentName, ailmentValues] of Object.entries(ailmentList)) {
		/* Default ailments */
		if (ailmentValues[5] != 0) {
			output[`repeating_ailments_${ailmentValues[5]}_ailNum`] = ailmentValues[1];
			output[`repeating_ailments_${ailmentValues[5]}_ailNumNextTurn`]  = ailmentValues[2];
			output[`repeating_ailments_${ailmentValues[5]}_ailDecayPause`]  = ailmentValues[4];
		}
		/* Custom ailments */
		else {
			output[`${ailmentName}`] = ailmentValues[1];
			output[`${ailmentName}NextTurn`] = ailmentValues[2];
			output[`${ailmentName}DecayPause`] = ailmentValues[4];
		}
	}

	if (returnMode == "true") {
		return output;
	} else {
		setAttrs(output);
	}
}


/* Function: Update multiple custom ailments */
/* triggerList: array which contains at least one of None, RoundEnd, OnAction and WhenHit */
/* See updateCustomAilment() function below for details on modes */
function updateCustomAilments(triggerList=["OnAction"], mode="standard", roundEnd="true", callback=()=>{}) {
	getSectionIDs(`repeating_ailments`, idarray => {
		let autoScriptOverrideList = {}
		let output = {}
		let updatesRemaining = 0;

		/* Immediately callback if no custom ailments exist */
		if (idarray.length == 0) {
			callback({});
		}
		
		const fieldnames = idarray.reduce((rows,id) => [...rows, `repeating_ailments_${id}_ailTrigger`, `repeating_ailments_${id}_ailName`], '');
		getAttrs([...fieldnames], v => {

			idarray.forEach(id => {
	
				let current = v[`repeating_ailments_${id}_ailTrigger`];
				
				/* Update each custom ailment with the requested trigger(s). After the last valid ailment updates, callback */
				if(triggerList.includes(current)) {
					updatesRemaining += 1;
					//console.log(updatesRemaining)
					updateCustomAilment(id, mode, roundEnd, function(returnValues) {
						Object.assign(autoScriptOverrideList, returnValues.overrideList);
						output = {...output, ...returnValues.output};
						updatesRemaining -= 1;
						//console.log(updatesRemaining)
						//console.log(v[`repeating_ailments_${id}_ailName`] + ": finished updating")
						if (updatesRemaining == 0) {
							if (callback != "()=>{}") {
								callback({"output": output, "overrideList": autoScriptOverrideList});
							} else {
								setAttrs(output);
							}
						}
					});
				}
				//console.log(v[`repeating_ailments_${id}_ailName`] + ": " + updatesRemaining);

				/* If no custom ailments have the requested trigger(s), callback */
				if (idarray.indexOf(id) == idarray.length-1 && updatesRemaining == 0) {
					callback({});
				}
			});
		});
	});
}


/* Function: Update custom ailment */
/* Has the following modes : */
/* standard - Triggers both decay and effect */
/* decay - Triggers only decay */
/* effect - Triggers only effect */
function updateCustomAilment(rowid, mode="standard", roundEnd="true", callback=()=>{}) {

	let ailPrefix = `repeating_ailments_${rowid}_`;
	let ailmentAttrs = ailmentAttrs.map(attr => `${ailPrefix}${attr}`);

    getAttrs([...ailmentAttrs, "distortState", "egoActiveState", "egoType", "settingWhisperRolls", "settingWhisperTarget", "settingMuteMessage",
		"HP", "StagRes", "SP", "Light", "distortCounter", "difficulty", "baseSpeed", "baseLuckNum", "character_name", "THP_Sources", "TST_Sources"], function(values) {

	let charname = values.character_name;
	let nomessage = values.settingMuteMessage;
	let mutemessage = values.settingMuteMessage;
	let hiddenroll = values.settingWhisperRolls;

	let ailname = values[`${ailPrefix}ailName`];
	let icon = values[`${ailPrefix}ailIcon`];
	let count = parseInt(values[`${ailPrefix}ailNum`]);
	let countnextturn = parseInt(values[`${ailPrefix}ailNumNextTurn`]);

	let output = { [`${ailPrefix}ailNum`]: count };
	let returnValues = { [ailname]: [count, count] };

	let trigger = values[`${ailPrefix}ailTrigger`];

	let customRes = parseInt(values[`${ailPrefix}ailCustomResistanceNum`]);
	let customResEgo = parseInt(values[`${ailPrefix}ailCustomResistanceNumEgo`]);
	
	let distortState = values.distortState;
	let egoActiveState = values.egoActiveState;
	let egoType = values.egoType;

	let effecttarget = values[`${ailPrefix}ailEffect`];
	let effectmode = values[`${ailPrefix}ailEffectMode`];
	let effectval = values[`${ailPrefix}ailEffectVal`];

	let decayRoundEnd = values[`${ailPrefix}ailDecayRoundEnd`]; 
	let decaypause = parseInt(values[`${ailPrefix}ailDecayPause`]);
	let decaymode = values[`${ailPrefix}ailDecayMode`];
	let decayval = values[`${ailPrefix}ailDecayVal`];
	let decaymin = parseInt(values[`${ailPrefix}ailDecayMin`]);

	if (decaypause > 0) {
		if (trigger != "OnAction" || (trigger == "OnAction" && mode == "standard")) {
			mode = "effect";
			output[`${ailPrefix}ailDecayPause`] = decaypause - 1;
		}
	}

	let THP_Sources = {};
	if (values.THP_Sources != "" && values.THP_Sources != "{}") {
		THP_Sources = JSON.parse(values.THP_Sources);
	}
	let TST_Sources = {};
	if (values.TST_Sources != "" && values.TST_Sources != "{}") {
		TST_Sources = JSON.parse(values.TST_Sources);
	}

	let maxcount = parseInt(values[`${ailPrefix}ailMax`]);
	let maxtype = values[`${ailPrefix}ailMaxBehavior`];

	let messagecheck = values[`${ailPrefix}ailMessageCheck`];
	let message = values[`${ailPrefix}ailMessage`]; 

	//console.log("Name: " + name + " | Icon: " + icon + " | Count: " + count + " | Trigger: " + trigger + " | Effect: " + effecttarget + effectmode + effectval + " | Decay: Count " + decaymode + decayval + " | Message: (" + messagecheck + ")" + message);

	let newcount = parseInt(count);
	let newmessage = message;
	let tempBarMessage = "";

	let targetval = "";
	let result = "";
	let change = "";

	let activateEffect = "true";
	let activateDecay = "true";
	let activateMessage = "";

	if (egoActiveState == "true" && egoType == "Outfit" && distortState != "true") {
		customRes = parseInt(customResEgo);
	}
	else if (distortState == "true") {
		customRes += parseInt(customResEgo);
	}

	/* Mode behaviour */
	if (mode == "decay") { activateEffect = "false"; }
	if (mode == "effect") { activateDecay = "false"; }
	if (trigger == "None" && mode != "standard") {
		activateEffect = "false";
		activateDecay = "false";
	}

	/* Max Behavior Check */
	if(maxcount > 0 && count < maxcount){
		if(maxtype == "Effect" || maxtype == "EffectClear"){
		activateEffect = "false";
		}
		else if(maxtype == "Decay"){
		activateDecay = "false";
		}
		else if(maxtype == "EffectDecay"){
		activateEffect = "false";
		activateDecay = "false";
		}
	}
	else if(maxcount > 0 && count >= maxcount){
		if(maxtype == "Clear" || maxtype == "EffectClear"){
		decaymode = "=";
		decayval = 0;
		}
	}

	/*-- Process Effect --*/
	let effecttargetlist = [];
	if (effecttarget == "HPStagRes") {
		effecttargetlist.push("HP", "StagRes");
	} else {
		effecttargetlist.push(effecttarget);
	}
	
	effecttargetlist.forEach((effecttargetinlist) => {

		targetval = values[`${effecttargetinlist}`];

		if(effecttargetinlist != "None" && effecttargetinlist != null && activateEffect == "true" && count != 0) {
			
			/* Ailment is n or -n multiplied by a number */
			if ((/([0-9]+n)/).test(effectval)) {
				effectval = effectval.replaceAll("n","");
				effectval = parseInt(count) * parseInt(effectval)
			}
			else if ((/(-[0-9]+n)/).test(effectval)) {
				effectval = (0 - parseInt(count)) * parseInt(effectval)
			}
			/* Ailment is n or -n */
			else if (effectval == "n") {
				effectval = parseInt(count);
			}
			else if (effectval == "-n") {
				effectval = (0 - parseInt(count));
			}

			if(effectmode == "+"){
			result = parseInt(targetval) + parseInt(effectval);

			}
			else if(effectmode == "x"){
			result = parseInt(parseInt(targetval) * parseFloat(effectval));

			}
			else if(effectmode == "="){
			result = parseInt(effectval);

			}

			change = parseInt(targetval) - parseInt(result);
			if (change > 0) {
				result += Math.min(change, customRes);
				change -= Math.min(change, customRes);
			}

			/* Temporary bar values */
			let tempBarTarget = "";
			let tempBar_Sources = {};
			if (effecttargetinlist == "HP") { tempBarTarget = "THP"; tempBar_Sources = THP_Sources }
			if (effecttargetinlist == "StagRes") { tempBarTarget = "TST"; tempBar_Sources = TST_Sources }
			
			let tempBarUsed = {}
			if (change > 0 && length(tempBar_Sources) > 0) {
				let returnTempBar = applyTempBarDamageAilment(tempBar_Sources, tempBarTarget, change, result, roundEnd);
				result = returnTempBar.newBar;
				change = returnTempBar.damage;
				tempBarUsed = returnTempBar[`${tempBarTarget}Used`];
			}
			for (const sourceName in tempBarUsed) {
				let countUpdate = `(${parseInt(tempBarUsed[sourceName][0] + tempBarUsed[sourceName][1])} -> ${tempBarUsed[sourceName][0]})`;
				tempBarMessage += styleText(`\n**(${sourceName}: ${tempBarUsed[sourceName][1]} ${countUpdate})**`, "opacity: 50%;");
			}

			output[`${effecttargetinlist}`] = result;

			activateMessage = "true";
		}
	});
	/*-- Process Effect end --*/

	
	/*-- Decay --*/
	if(activateDecay == "true" && count >= decaymin) {
		if ( !(trigger == "OnAction" && roundEnd == "true")) {
			if(decayval == "n") {
			decayval = parseInt(count);
			}
			else if(decayval == "-n"){
			decayval = (0 - parseInt(count));
			}
	
			if(decaymode == "+"){
			newcount = parseInt(count) + parseInt(decayval);	
			}
			else if(decaymode == "x"){
			newcount = parseInt(parseInt(count) * parseFloat(decayval));
			}
			else if(decaymode == "="){
			newcount = parseInt(decayval);
			}
	
			/* Overflow adjustment */
			if(maxcount != 0 && newcount > maxcount){
			newcount = maxcount;
			}
			if(newcount <= 0){
			newcount = 0;
			}
		}
		output[`${ailPrefix}ailNum`] = parseInt(newcount);
		returnValues[ailname][0] = parseInt(newcount);
	}
	if (roundEnd == "true") {
		if (trigger == "WhenHit" && decayRoundEnd != "true") {
			output[`${ailPrefix}ailNum`] = parseInt(count);
		}
		output[`${ailPrefix}ailNum`] += parseInt(countnextturn);
		output[`${ailPrefix}ailNumNextTurn`] = 0;
		returnValues[ailname][0] += parseInt(countnextturn);
	}
	/*-- Decay end --*/

	/* Message */
	if(messagecheck != "0" && activateMessage == "true" && mutemessage != "true"){

		let langResist= getTranslationByKeyCustom("Resistance: ", "message-resist");
		let langEffectValue = "[EVAL]";
		let langDecayValue = "[DVAL]";
		let langName = "[CHAR]";
		let langCount = "[COUNT]";
		let langAilName = "[AIL]";
		let langResult = "[RESULT]";
		let langChange = "[DIFF]";

		/*if(getTranslationByKey("message-match-value") != false){
			langEffectValue = getTranslationByKey("message-match-evalue");
			langDecayValue = getTranslationByKey("message-match-dvalue");
			langName = getTranslationByKey("message-match-name");
			langCount = getTranslationByKey("message-match-count");
			langAilName = getTranslationByKey("message-match-ailment");
			langResult = getTranslationByKey("message-match-result");
			langChange = getTranslationByKey("message-match-change");
			}*/
		
		message = message.replaceAll(langEffectValue, `**${effectval}**`);
		message = message.replaceAll(langDecayValue, `**${decayval}**`);
		message = message.replaceAll(langName,  `**${charname}**`);
		message = message.replaceAll(langCount, `**${count}**`);
		message = message.replaceAll(langAilName, `**${ailname}**`);
		message = message.replaceAll(langResult, `**${result}**`);
		message = message.replaceAll(langChange, `**${change}**`);

		if (customRes != 0) {
			message += ` ${styleText(` **(${langResist}${customRes})**`, "opacity: 50%;")}`;
		}
		newmessage = message + tempBarMessage;

		let iconnew = "";
		if (icon == "Question") {
			iconnew = getIcon("icons", "question", "false", "markdown");
		}
		else if (icon != "None") {
			if (icon.includes("community")) {
				iconnew = getIcon("community", icon.replace("community/",""), "false", "markdown");
			} else {
				iconnew = getIcon("ailments", icon, "false", "markdown");
			}
		}

		/* Whisper roll */
		let whisperrolls = values.settingWhisperRolls;
		let whispertarget = values.settingWhisperTarget;
		let whisper = "";
		if(whisperrolls == "true"){
		whisper = "/w " + whispertarget;
			}

		/*--- Send roll --*/
		startRoll((whisper + `&{template:message} {{icon=${iconnew}}} {{message=${newmessage}}}`), (results) => {
			finishRoll(results.rollId, { });
		});
	}
	/*--Message end --*/

	/* Apply to target */
	if (callback != "()=>{}") {
		callback({"output": output, "overrideList": returnValues});
	} else {
		setAttrs(output);
	}
	});
}

/* Update: Edit Mode state */
on("change:global_editMode", function() {
getAttrs(["global_editMode"], function(values) {
		if(values.global_editMode != "true"){
			setAttrs({"sheetTab":"equipment"});
		}
	});
});

/* Access PW Check */
on("change:global_access", function() {
getSectionIDs("repeating_global", function(idarray) {
	let id = idarray[0];

    getAttrs([`repeating_global_${id}_editKey`, "global_access"], function(values) {

	/* Translation prep */
	let langEditMode = getTranslationByKeyCustom("Edit Mode", "pop-editmode");
	let langPasswordError = getTranslationByKeyCustom("Wrong password.", "pop-pwerror");

	let state = "0";
	let popupdisplay = "0";
	let internalpw = values[`repeating_global_${id}_editKey`];
	let accesspw = values.global_access;       
	const output = {};

	if(internalpw == accesspw || internalpw == null || internalpw == ""){
		state = "true";
	} else {
		output[`popup_messageHeader`] = langEditMode;
		output[`popup_messageBody`] = langPasswordError;
		popupdisplay = "true";
		state = "0";
	}
	output[`popup_display`] = popupdisplay;
	output["global_accessCheck"] = state;

	setAttrs(output);
	});
	});
});

/* Sheet Initialization */
on("sheet:opened", function() { 
getSectionIDs("repeating_global", function(idarray) {

	/* Message Setup */
	let syncHeader = "";
	let syncBody = "";
	let syncToggle = "0"; 
	const output = {};

	setAttrs({"popup_messageHeader":"", "popup_messageBody":"", "popup_display":"0"});

	/* Global Settings Check */
	let rowid = "";
	if (idarray.length >= 1) {
	rowid = idarray[0];
	}
	else if (idarray.length == 0) {
	rowid = generateRowID();
	//syncBody += "Initialize game settings. ID: " + rowid + "\n";
	//syncToggle = "true"; 
	output[`repeating_global_${rowid}_ruleName`] = "";
	}

    getAttrs(["syncStateGame", "syncStateAilment", "syncLockGame", "syncLockAilment",
	"global_access", "global_editMode", "global_editKey", "global_gameSettingSource", "global_ailmentSettingSource", "global_generalSettingSource", "gameEditor", "ailmentEditor",
	`repeating_global_${rowid}_editKey`, `repeating_global_${rowid}_gameSettingSource`, `repeating_global_${rowid}_ailmentSettingSource`, `repeating_global_${rowid}_generalSettingSource`,
	"settingEvdInfluence", "settingTestOption", "autoScriptStyling", "autoScriptEditorTarget", "autoScriptEditorInput",
	"weapon1AutoScript", "weapon2AutoScript", "weapon3AutoScript", "weapon4AutoScript", "augmentAutoScript", "outfitAutoScript",
	"tool1AutoScript", "tool2AutoScript", "tool3AutoScript", "tool4AutoScript", "special1AutoScript", "special2AutoScript",
	"skill1AutoScript", "skill2AutoScript", "skill3AutoScript", "skill4AutoScript", "skill5AutoScript", "skill6AutoScript",
	"egoSkill1AutoScript", "egoSkill2AutoScript", "egoSkill3AutoScript", "egoSkill4AutoScript", "egoSkill5AutoScript", "egoSkill6AutoScript"], function(values) {

	/* Translation prep */
	let langUpdate = "Update";
	let langGameSettings = "Game Settings";
	let langCustomAilments = "Custom Ailments";
	let langGeneralSettings = "General Settings";
	let langSyncSuccess = "Update synced.";
	let langSyncFail = "Update detected, but section is locked.";

	if(getTranslationByKey("pop-update") != false){

	langUpdate = getTranslationByKey("pop-update");
	langGameSettings = getTranslationByKey("editor-gamesettings");
	langCustomAilments = getTranslationByKey("editor-customailments");
	langGeneralSettings = getTranslationByKey("editor-generalsettings");
	langSyncSuccess = getTranslationByKey("pop-update-success");
	langSyncFail = getTranslationByKey("pop-update-fail");
	}

	let lockGame = values.syncLockGame;
	let syncGame = values.syncStateGame;
	let lockAilment = values.syncLockAilment;
	let syncAilment = values.syncStateAilment;

	let gameSettings = values[`repeating_global_${rowid}_gameSettingSource`];
	let ailmentSettings = values[`repeating_global_${rowid}_ailmentSettingSource`];
	let generalSettings = values[`repeating_global_${rowid}_generalSettingSource`];

	let updateFlagGame = "0";
	let updateFlagAilments = "0";
	let updateFlagGeneral = "0";

	let passCompare = values[`repeating_global_${rowid}_editKey`];
	let passInput = values.global_access;

	let comparekey = rowid.toLowerCase();

	/* Check: External (Default Sheet Settings) updates */
		if(values.global_editKey.toLowerCase() != comparekey){
			output[`repeating_global_${rowid}_editKey`] = values.global_editKey;
			output["global_editKey"] = rowid;

			passCompare = values.global_editKey;
		}

		if(values.global_gameSettingSource != null && values.global_gameSettingSource.toLowerCase() != comparekey){
			output[`repeating_global_${rowid}_gameSettingSource`] = values.global_gameSettingSource;
			output["global_gameSettingSource"] = rowid;
			gameSettings = values.global_gameSettingSource;

			updateFlagGame = "true";
		}

		if(values.global_ailmentSettingSource != null && values.global_ailmentSettingSource.toLowerCase() != comparekey){
			output[`repeating_global_${rowid}_ailmentSettingSource`] = values.global_ailmentSettingSource;
			output["global_ailmentSettingSource"] = rowid;
			ailmentSettings = values.global_ailmentSettingSource;

			updateFlagAilments = "true";
		}

		if(values.global_generalSettingSource != null && values.global_generalSettingSource.toLowerCase() != comparekey){
			output[`repeating_global_${rowid}_generalSettingSource`] = values.global_generalSettingSource;
			output["global_generalSettingSource"] = rowid;
			generalSettings = values.global_generalSettingSource;

			updateFlagGeneral = "true";
		}


	/* Check: PW updates */ 
	if(passCompare != passInput && passCompare != ""){
	output["global_accessCheck"] = "0";

	}
	else if(passCompare == passInput && passCompare != "") {
	output["global_accessCheck"] = "true";
	}

	if(passCompare == "" || passCompare == null){
	output["global_accessCheck"] = "true";
	}

	/* Check: Internal setting updates */
	if(gameSettings != "" && gameSettings != null && updateFlagGame != "0"){
		if(gameSettings != values.gameEditor && lockGame != "true"){

			setAttrs({"gameEditor":gameSettings});
			dataImport("gameEditor", `repeating_global_${rowid}_`, "global_");
			output["syncStateGame"] = "0";

			syncToggle = "true";
			syncHeader = langUpdate; 
			syncBody += langGameSettings + ": " + langSyncSuccess + "\n";
		}
		else if(gameSettings != values.gameEditor && lockGame == "true"){

			output["syncStateGame"] = "true";

			if(syncGame != "true"){
				syncToggle = "true";
				syncHeader = langUpdate; 
				syncBody += langGameSettings + ": " + langSyncFail + "\n";
			}
		}
	}

	if(ailmentSettings != "" && ailmentSettings != null && updateFlagAilments != "0"){
		if(ailmentSettings != values.ailmentEditor && lockAilment != "true"){

			setAttrs({"ailmentEditor":ailmentSettings});
			dataImportRepeating("ailments", "Replace");
			output["syncStateAilment"] = "0";

			syncToggle = "true";
			syncHeader = langUpdate; 
			syncBody += langCustomAilments + ": " + langSyncSuccess + "\n";
		}
		else if(ailmentSettings != values.ailmentEditor && lockAilment == "true"){

			output["syncStateAilment"] = "true";

			if(syncAilment != "true"){
				syncToggle = "true";
				syncHeader = langUpdate; 
				syncBody += langCustomAilments + ": " + langSyncFail + "\n";
			}
		}
	}

	if(generalSettings != "" && generalSettings != null && updateFlagGeneral != "0"){

		setAttrs({"editorInput":generalSettings});
		dataImport();

		syncToggle = "true";
		syncHeader = langUpdate; 
		syncBody += langGeneralSettings + ": " + langSyncSuccess + "\n";
	}

	/* Delete any AutoScript styling rules present in normal AutoScripts */
	/* There used to be a bug that replaced one AutoScript with the default AutoScript styling rules. This cleans up any sheets affected by the bug */
	/* Should be able to remove this after a few updates have passed and all currently used character sheets have been cleaned (added in update 0.6.3) */
	let colorList = ["green","blue","red","orange","yellow","purple","black"];
	let autoScriptList = ["weapon1", "weapon2", "weapon3", "weapon4", "augment", "outfit", "ego", "tool1", "tool2", "tool3", "tool4", "special1", "special2",
	"skill1", "skill2", "skill3", "skill4", "skill5", "skill6", "egoSkill1", "egoSkill2", "egoSkill3", "egoSkill4", "egoSkill5", "egoSkill6",
	"autoScriptEditorInput"];

	let editorTarget = values.autoScriptEditorTarget;
	autoScriptList.forEach(autoScriptPrefix => {
		let target = `${autoScriptPrefix}AutoScript`;
		if (autoScriptPrefix == "autoScriptEditorInput") {
			if (editorTarget == "autoScriptStyling") {
				return;
			} else {
				target = "autoScriptEditorInput";
			}
		}
		let autoScript = values[target];
		
		colorList.forEach(color => {
			let stylingRegex = new RegExp(`[(].+?,.+?,.+?,.*?${color}.*?[)]`, "ig");
			if (stylingRegex.test(autoScript)) {
				autoScript = autoScript.replaceAll(stylingRegex, "");
				output[target] = autoScript;
			}
		});
	});

	/* Check: Obsolete attributes  */
	let evdInfluence = values.settingEvdInfluence;
	let testRankPower = values.settingTestOption;

	if(evdInfluence == "true"){
	output[`repeating_global_${rowid}_evdAilment`] = "HasteBind";
	output["settingEvdInfluence"] = "0";
	}

	if(testRankPower == "true"){
	output[`repeating_global_${rowid}_attStat`] = "Rank";
	output["settingTestOption"] = "0";
	}


	output[`popup_messageHeader`] = syncHeader;
	output[`popup_messageBody`] = syncBody;
	output[`popup_display`] = syncToggle;

	setAttrs(output);
	});
	});
});



/* --- Generic helper functions --- */

/* Takes in arguments of the format: [returnValue, queryText, {label1:value1, label2:value2, ...}] */
/* Sends one query for each argument included and returns an array of results */
async function sendQuery(...args) {
	let queryList = [];
	args.forEach(arg => { if(arg != [] && arg != "") { queryList.push(arg); } });
	
	let rollBase = "! ";
	queryList.forEach(query => {
		rollBase += `{{${query[0]}=[[0[?{${query[1]}`;
		
		//?{Name of Query|Label 1, value1|Label 2, value2}
		for (const [label, value] of Object.entries(query[2])) {
			rollBase += `|${label},${value}`;
		}

		rollBase += "}]]]}}";
	});
	
	let queryRoll = await startRoll(rollBase);
	let queryResults = {}
	queryList.forEach(query => {
		queryResults[query[0]] = queryRoll.results[query[0]].expression.match(/^0\[(.*)\]\s*$/)[1];
	});
    finishRoll(queryRoll.rollId);
	
	return queryResults;
}

/* Returns an icon image either as an HTML element, a markdown icon or as an url */
function getIcon(iconFolder, iconName, settingLimbusStyle="false", returnMode="html", htmlAttributes="") {
	let imageUrl = "https://raw.githubusercontent.com/beautidemise/roll20-character-sheets/master/ProjectMoonTRPG/imagesResized/";
	
	if (iconFolder.includes("http") || iconName.includes("http")) {
		imageUrl = (iconFolder.includes("http")) ? iconFolder : iconName;
	} else {
		if (settingLimbusStyle == "true") {
			imageUrl += `ailments/limbus/${iconName.replace("limbus/","")}.png`;
		} else {
			imageUrl += `${iconFolder}/${iconName}.png`;
		}
	}
	switch (returnMode) {
		case "html": imageUrl = `<img src="${imageUrl}" ${htmlAttributes}>`; break;
		case "markdown": imageUrl = `[icon](${imageUrl})`; break;
	}
	return imageUrl;
}
function getColor(color) {
	if (color == undefined) {
		return "#85a874";
	}
	if (!(/^#(?:[0-9a-fA-F]{6}){1,2}$/).test(color)) {
		switch (color.toLowerCase()) {
			case "blue": color = "#7397d1"; break;
			case "red": color = "#c25944"; break;
			case "orange": color = "#cf8c44"; break;
			case "yellow": color = "#dbb748"; break;
			case "purple": color = "#8e7cc3"; break;
			case "black": color = "#000000"; break;
			default: color = "#85a874";
		}
	}
	return color;
}
/* Uses HTML attribute injection to style text that can otherwise only be styled using markdown */
function styleText(text, style) {
	return `[${text}](#" class="sheet-styledText" style="${style})`;
}

/* Returns a translation, or a base string if no translation is available */
function getTranslationByKeyCustom(base, key) {
	return (getTranslationByKey(key)) ? getTranslationByKey(key) : base;
}

function updateStatName(stat) {
	return stat.replace("Instinct","Fortitude").replace("Wisdom","Prudence")
}

/* Translation: Get text in English */
function getAutoEffectFromTranslation(inputAutoEffect, errorString="") {
	let translatedName = Object.keys(autoEffectFormats).find(name => {
		return getTranslationByKey(`autoeffect-${name.toLowerCase()}`) == inputAutoEffect;
	});
	return (translatedName) ? translatedName : errorString + inputAutoEffect;
}

function getTriggerFromTranslation(inputTrigger, errorString="") {
	let translatedTrigger = autoEffectTriggers.find(trigger => {
		return getTranslationByKey(`autoeffect-trigger-${trigger.toLowerCase().replace(" ","")}`) == inputTrigger;
	});
	return (translatedTrigger) ? translatedTrigger : errorString + inputTrigger;
}

function getAilmentFromTranslation(inputAilment, errorString="") {
	let translatedAilment = ailmentNames.find(ailment => {
		return getTranslationByKey(`ailments-${ailment.toLowerCase().replace("stagger","stg")}`).replace(" ","") == inputAilment;
	});
	return (translatedAilment) ? translatedAilment : errorString + inputAilment; // Is presumably a custom ailment if no translation can be found
}

function getBarFromTranslation(inputBar, errorString="") {
	for (let i = 0; i < 4; i++) {
		let translationString = (barNames[i] != "Light") ? `bar-${barNamesFull[i].toLowerCase()}-shortened` : "bar-light";
		if (getTranslationByKey(translationString) == inputBar) { return barNames[i] }
		if ("-" + getTranslationByKey(translationString) == inputBar) { return "-" + barNames[i] }
	}
	if (getTranslationByKey("bar-health-temp-shortest") == inputBar) { return "THP" }
	if (getTranslationByKey("bar-stagres-temp-shortest") == inputBar) { return "TST" }
	return errorString + inputBar;
}

function getResourceFromTranslation(inputResource, errorString="") {
	let translatedResource = resourceNames.find(resource => {
		return getTranslationByKey(`resource-${resource.toLowerCase()}`) == inputResource;
	});
	return (translatedResource) ? translatedResource : errorString + inputResource;
}

function getStatFromTranslation(inputStat, errorString="") {
	let translatedStat = statNamesFull.find(stat => {
		if (["Fortitude","Prudence"].includes(stat)) { return false; } // Needed while using the sheet in English due to the legacy names
		return getTranslationByKey(`stats-${stat.toLowerCase()}`) == inputStat;
	})
	return (translatedStat) ? translatedStat : errorString + inputStat;
}

function getTargetFromTranslation(input, targetList=[], errorString="") {
	if (targetList.includes("#Bar")) { if (getBarFromTranslation(input, "Unknown") != "Unknown" + input) { return getBarFromTranslation(input, errorString); } }
	if (targetList.includes("#Stat")) { if (getStatFromTranslation(input, "Unknown") != "Unknown" + input) { return getStatFromTranslation(input, errorString); } }
	if (targetList.includes("#Resource")) { if (getResourceFromTranslation(input, "Unknown") != "Unknown" + input) { return getResourceFromTranslation(input, errorString); } }
	if (targetList.includes("#Ailment")) return getAilmentFromTranslation(input);
	return errorString + input;
}

function getOptionFromTranslation(inputOption, errorString="") {
	let validOptions = Object.keys(autoEffectOptions);
	let optionN = ""
	if ((/({.+}|\d+)/).test(inputOption)) {
		optionN = inputOption.match(/({.+}|\d+)/)[0];
		inputOption = inputOption.replace(optionN,"");
	}
	validOptions.forEach(option => {
		if (option in autoEffectOptionsExpand) {
			validOptions = [...validOptions.filter(o => o != option), ...autoEffectOptionsExpand[option]];
		}
	});
	let translatedOption = validOptions.find(option => {
		return getTranslationByKey(`autoeffect-option-${option.toLowerCase().replaceAll(" ","").replaceAll("#","")}`).toLowerCase() == inputOption.toLowerCase();
	});
	return (translatedOption) ? translatedOption + optionN : errorString + inputOption + optionN;
}

function getConOptionFromTranslation(inputOption, errorString="") {
	let validOptions = Object.keys(conditionalOptions);
	let translatedOption = validOptions.find(option => {
		return getTranslationByKey(`autoeffect-option-${option.toLowerCase().replaceAll(" ","").replaceAll("#","")}`).toLowerCase() == inputOption.toLowerCase();
	});
	return (translatedOption) ? translatedOption : errorString + inputOption;
}


/* Other helper functions */

/* --- Math functionality --- */
const operators = {
	"+": {min: 2, max: 2, calc: (a,b) => a+b},
	"-": {min: 2, max: 2, calc: (a,b) => a-b},
	"*": {min: 2, max: 2, calc: (a,b) => a*b},
	"/": {min: 2, max: 2, calc: (a,b) => a/b},
	"%": {min: 2, max: 2, calc: (a,b) => a%b},
	"**": {min: 2, max: 2, calc: (a,b) => a**b},
	"<=": {min: 2, max: 2, calc: (a,b) => +(a<=b)},
	">=": {min: 2, max: 2, calc: (a,b) => +(a>=b)},
	"<": {min: 2, max: 2, calc: (a,b) => +(a<b)},
	">": {min: 2, max: 2, calc: (a,b) => +(a>b)},
	"==": {min: 2, max: 2, calc: (a,b) => +(a==b)},
	"!=": {min: 2, max: 2, calc: (a,b) => +(a!=b)},
	"||": {min: 2, max: 2, calc: (a,b) => +!!(a||b)},
	"&&": {min: 2, max: 2, calc: (a,b) => +!!(a&&b)},
	"||=": {min: 2, max: 2, calc: (a,b) => +(a||b)},
	"&&=": {min: 2, max: 2, calc: (a,b) => +(a&&b)},
	"!": {min: 1, max: 1, calc: (a) => !a, func:true},
	"Min": {min: 2, max:"any", calc: (...args) => Math.min.apply(null, args), func:true},
	"Max": {min: 2, max:"any", calc: (...args) => Math.max.apply(null, args), func:true},
	"Floor": {min: 1, max: 1, calc: (a) => Math.floor(a), func:true},
	"Ceil": {min: 1, max: 1, calc: (a) => Math.ceil(a), func:true},
};

// Executes a math operation between two or more numbers and returns the result
function mathOperation(op, ...args) {
	if (op in operators) {
		return operators[op].calc.apply(null, args);
	}
}

// Takes in a math formula in string form and a list of variable values and returns the result of the formula
// Uses the same format as writing calculations in JavaScript, except {curly brackets} are used to specify the order of operations. Functions like Min() still use normal parentheses 
// Returns 0 if the calculation fails due to incorrect formating. If an errors object is provided, details of the error will be added to the list
// Options:
//   mode: One of "math" (returns 1 value) or "function" (returns 1 or more values)
//   strict: true/false. If false, adds unknown variables as a new variable with a value of false and treats their value as 0
function parseMath(mathString, vars={}, options={strict:true}, errors) {
	
	if (!options.mode) options.mode = "math";
	let type = {new: false, current: false, old: false}
	let currentChars = "";
	let parsedChars = "";
	let inNested = "";
	let nestedReturnCount = 0;
	let numbers = []
	let ops = []
	let char = "";

	let [openBracket, closeBracket] = (options.mode == "math") ? ["{","}"] : ["(",")"]

	//console.log((options.mode == "math") ? "Parse math from string: " + mathString : "Parsing function values from string: " + mathString)


	const throwMathError = (errorType, errorInserts={}) => { // Change over to using an error object that has keys like "errorOperator"
		log({errorType, errorInserts, currentChars, parsedChars, mathString});
		if (errors) {
			errorInserts = {
				"[CURRENT CHARS]":styleText(currentChars, "color: red;"),
				"[PREV CHARS]":openBracket + parsedChars.slice(0,-1),
				"[NEXT CHARS]":styleText(mathString.replace(parsedChars,"").trim() + closeBracket, "color: gray;"),
				"[CHAR]":styleText(parsedChars.slice(-1), "color: red;"),
				...errorInserts
			}
			let langLocation = getTranslationByKeyCustom("Location: ", "autoeffect-error-math-location");
			errorInserts["[LOCATION]"] = `*\n${langLocation}**${errorInserts["[PREV CHARS]"]}${errorInserts["[CHAR]"]}${errorInserts["[NEXT CHARS]"]}*`;
			autoEffectError(errors, "Math Error", openBracket + mathString.trim() + closeBracket, errorInserts, errorType.toLowerCase().replaceAll(" ","-"));
		}
	}
	

	const newNumber = (number, options={}) => {
		let newNumber = parseFloat(number);
		if (!isNaN(newNumber)) {
			numbers.push(newNumber);
			//console.log("New Numbers: " + newNumber);
			if (ops.length > 0 && !options.suppressCheck) {
				if (ops[ops.length-1].min <= numbers.length) {
					checkOperator();
				}
			}
		}
	}
	const newOperator = (op) => {
		if (op in operators) {
			if ((/(^|[^\d\w\s])\s*\-\d+$/).test(parsedChars)) { // Don't add - as an operator in cases like "-3 2", "2 + -3", "(2, -3)" and "2 (-3)"
				char = "-" + char; return;
			}
			ops.push({...operators[op], name:currentChars});
			//console.log("New Operator: " + Object.entries(ops).reduce((acc, op) => acc += (acc != '' ? ', ' : '') + op[1].name,''));
			if (!op?.func) checkOperator(); // Function valies only activate on 
		} else {
			throwMathError("Unknown operator", {"[OP]":styleText(op, "color: red;")});
		}
	}
	const checkOperator = () => {
		let op = ops[ops.length-1];
		if (op.min <= numbers.length) {
			if (op.max == "any" || op.max <= numbers.length) {
				if (nestedReturnCount) {
					if (op.max == "any") op.max = nestedReturnCount;
					nestedReturnCount = 0;
				}
				//console.log("Executing math: " + numbers.slice(-op.max) + " | " + op.name)
				newNumber(ops.pop().calc.apply(op, numbers.splice(-op.max)));
			}
		}
	}
	const parseNestedMath = () => {
		let nestedMathString = currentChars;
		[inNested, currentChars] = ["", ""]

		let funcNumbers = parseMath(nestedMathString, vars, {...options, mode:"function"}, errors);

		if (funcNumbers) {
			nestedReturnCount = funcNumbers.length;
			for (let i = 0; i < nestedReturnCount; i++) {
				newNumber(funcNumbers[i], {suppressCheck: (i < nestedReturnCount-1) ? true : false});
			}
		}
	}


	/* Remove surrounding brackets */
	if (["(","{"].includes(mathString[0])) mathString = mathString.slice(1);
	if ([")","}"].includes(mathString.slice(-1))) mathString = mathString.slice(0,-1);
	mathString += " ";

	/* Parse the mathString */
	for (let i = 0; i < mathString.length; i++) {
		char = mathString[i];
		parsedChars += char;
		type.new = false;

		if (length(errors) > 0) return;
		
		/* Checks if next char is the beginning of a new word, number or operator */
		/* Tests specifiec characters with special interactions first */
		switch (char) {
			case ".": if (type.current == "number") { type.new = "number"; break; }
			case ",": if (!inNested.includes("(") && options.mode == "math") { throwMathError("Unexpected comma"); return; } else { break; }
			case "(": inNested += (inNested == "") ? char+"initial" : char; break;
			case ")":
				if (inNested.includes("(")) {
					inNested = inNested.replace("(","");
					if (inNested.length == 0) inNested = "exiting";
					break;
				} else {
					throwMathError(`Unexpected bracket`, {"[UNEX]":char}); return;
				}
			case "{": case "}":
				throwMathError(`Unexpected bracket`, {"[UNEX]":char}); return;
		}
		if (!type.new && inNested == "") {
			if 		((/\s/).test(char)) 				type.new = false;
			else if ((/[\+\-*\/<>=!\|&]/).test(char)) 	type.new = "operator";
			else if ((/\d/).test(char)) 				type.new = "number";
			else if ((/\w/).test(char)) 				type.new = "string";
		}
			
		//console.log(char + " | " + inNested)
		//console.log(currentChars + char + " | type.current: " + type.current + " | type.new: " + type.new)

		/* If the new character is part of the current string/number/operator, continue */
		/* Otherwise, add the new value and check if any operations should be executed */
		/* If reading values from a nested section, store all nested chars and execute them by recursively calling parseMath */
		if ((!type.current && type.new) || (type.current && type.current == type.new) || (inNested != "" && !inNested.includes("initial"))) {
			currentChars += char;
			type.current = type.new;
			if (inNested == "exiting") { parseNestedMath(); }
			continue;
		} else {
			type.old = type.current; type.current = type.new;
			switch (type.old) {
				case "operator": newOperator(currentChars); break;
				case "number": newNumber(currentChars); break;
				case "string":
					let varExists = Object.keys(vars).find(v => v.toLowerCase() == currentChars.toLowerCase());
					if (!varExists && !options.strict && !(currentChars in operators)) {
						varExists = currentChars;
						vars[varExists] = false;
					}
					if (capitalize(currentChars) in operators) {
						newOperator(capitalize(currentChars));
					} else if (varExists || (/^\s*\|\|/).test(mathString.slice(i+1))) { // Allow undefined variables if followed by || or ||=
						newNumber(vars[varExists] || 0);
					} else {
						throwMathError("Unknown variable", {"[VAR]":styleText(currentChars, "color: red;")}); return;
					} break;
			}
			if (inNested.includes("initial")) {
				inNested = inNested.replace("initial","");
				currentChars = char;
			} else {
				currentChars = (type.new) ? char : "";
			}
		}
	}

	/* Finish parsing and return the result */
	//console.log("Final numbers: " + numbers);
	//console.log("Final operators: " + Object.entries(ops).reduce((acc, op) => acc += (acc != '' ? ", " : '') + op[1].name, ''));
	for (let [key, value] of Object.entries(ops)) {
		//console.log(key, value);
	}
	if (!inNested) {
		if (ops.length == 0) {
			if (options.mode == "function" || numbers.length == 1) {
				//console.log("Math string parsed successfully")
				return (options.mode == "math") ? numbers[0] : numbers
			} else {
				throwMathError("Unused values", {"[COUNT]":styleText(numbers.length-1, "color: red;")}); return;
			}
		} else {
			let langDividerComma = getTranslationByKeyCustom(", ", "autoeffect-error-divider-comma");
			let langDividerAnd = getTranslationByKeyCustom(" and ", "autoeffect-error-divider-and");
			throwMathError("Unused operators", {
				"[OPS]": replaceLast(Object.entries(ops).reduce((acc, op) => acc += (acc != '' ? langDividerComma : '') + styleText(op[1].name, "color: red;"), ''), langDividerComma, langDividerAnd)
			}); return;
		}
	} else {
		throwMathError(`Missing bracket`, {"[CHAR]":styleText(")", "color: red;"), "[MISSING]":")"}); return;
	}
}

/* Tests if a math formula is valid and throws no errors */
/* Returns false or true. Also returns any errors encountered if an errors object is provided */
function validateMathFormula(mathString, vars, errors, options={strict:false}) {
	let mathErrors = {}
	parseMath(mathString, vars, options, mathErrors);
	if (length(mathErrors) > 0) {
		if (errors) {
			for (const [errorType, errorMessage] of Object.entries(mathErrors)) {
				modifyProp(errors, errorType, errorMessage);
			}
		}
		return false;
	}
	return true;
}

/* Collection of random value generators */
const Random = {
	Int(min, max) {
		const [minCeiled, maxFloored] = [Math.ceil(min), Math.floor(max)]
		return Math.floor(Math.random() * (maxFloored - minCeiled + 1) + minCeiled);
	}
}
/* --- Math functionality end --- */


// Round down positive numbers and rounds up negative numbers
function roundTowardsZero(value) {
	return (value >= 0) ? Math.floor(value) : Math.ceil(value);
}
// Capitalizes or uncapitalizes a string
function capitalize(string) {
	if (typeof string == "string" && string.length > 0) {
		return string.charAt(0).toUpperCase() + string.slice(1);
	} else {
		return string;
	}
}
function uncapitalize(string) {
	if (typeof string == "string" && string.length > 0) {
		return string.charAt(0).toLowerCase() + string.slice(1);
	} else {
		return string;
	}
}
function replaceLast(string, match, replace) {
	let i = string.lastIndexOf(match);
	if (i >= 0) string = string.slice(0, i) + replace + string.slice(i+match.length);
	return string;
}
// Creates a new object property with a value, or adds the value to the property if it already exists
// Also works for arrays, treating property as an index. If the index does not exist the value is pushed onto the array
function modifyProp(object, property, value, mode="+", mod={addValue:undefined, setValue:undefined, max:undefined, min:undefined, round:undefined}) {

	if (typeof object == "object") {
		/* Get new value */
		if (object[property]) {
			//console.log(`${object[property] + (mod.addValue || 0)} ${mode} ${value} = ${mathOperation(mode, object[property] + (mod.addValue || 0), value)}`)
			value = (typeof value == "number") ? mathOperation(mode, object[property] + (mod.addValue || 0), value) : object[property] + value;
		} else {
			value = (typeof value == "number") ? mathOperation(mode, mod.setValue || 0, value) : value;
		}

		/* Apply max and min values */
		if (mod.max) { value = Math.min(value, mod.max) }
		if (mod.min) { value = Math.max(value, mod.min) }
		switch (mod.round) {
			case "up": value = Math.ceil(value); break;
			case "down": value = Math.floor(value); break;
		}

		/* Set the new property value, or add a new property/array element */
		if (Array.isArray(object)) { object.push(value); } // If array
		else { object[property] = value; } // If object
	}
}
// Works as split(), but ignores any seperator matches that are surrounded by characters a and b
// Characters a and b are not included in the result unless the include argument is set to true
function splitIgnoreBetween(string, seperator, a, b, includeChars=false, allowNesting=false) {
	if (!b) b = a;
	let formatInner = (allowNesting) ? ".*?" : `[^${a}${b}]*`;
	let formatOuter = (includeChars) ? `(\\${a}${formatInner}\\${b})` : `${a}(${formatInner})${b}`;
	let between = new RegExp(formatOuter, "g");

	let ignoreArray = [];
	return string.replace(between, (i, b) => { ignoreArray.push(b); return ""; })
		.split(seperator)
		.map(v => { while (v.includes("")) { v = v.replace("", ignoreArray.shift()) }; return v; });
}
// Deletes multiple object properties
function deleteMultiple(object, ...args) {
	args.forEach(arg => {
		if (typeof arg == "string") {
			delete object[arg];
		}
	});
}
// Return the length of an object
function length(object) {
	return keys = Object.keys(object).length;
}

const is = new Proxy( // In English: "When accessing "is", treat it as "Reflect.construct". .bind(null, {}) causes "{}" to always be the first argument of .construct()"
  	Reflect.construct.bind(null, {}), { // "Other arguments of is() are included after {}. is("foo") gives "Reflect.construct({}, "foo"), which is the same as "new Object("foo")"
		get(target, prop, val) { return Reflect.get(checkVal, prop, val); }, // "On is, when using a property accessor "is.prop", instead do "checkVal.prop" "
		set(target, prop, val) { return Reflect.set(checkVal, prop, val); }, // "Do the same for "is.prop = value. Both of these also work for methods like "is.method()"
		apply(target, thisArg, argumentsList) { // "On is, when making a function call is(), treat it as if "new Object(arguments)" was called, but then..."
			is.x = argumentsList[0]; // "... set the static property x of is (which instead sets checkVal) to the first argument in new Object(arguments)..."
			return checkVal; // "... and return the checkVal class instead of a creating an new Object instance"
    	} // "In summary, this makes "is(v).method(u)" the same as writing "checkVal.x = v; checkVal.method(u)" "
  	} // To whichever future dev sees this: thank you for coming to my TED talk
);

// A collection of custom data type checks
class checkVal {
	static x;

	static Int(i, opts={}) { return !isNaN(parseInt(i)) && this.Opts(i, opts); }
	static String(s, opts={newlines:true}) { return typeof(s) == "string" && (opts.newline) ? !s.includes("\n") : true; }
	static ID(s, opts={}) { return is.String(s) && (opts.strict ? /^-[A-Za-z0-9-]{19}$/ : /^-.{19}$/).test(s) } // Checks if a Roll20-style id is valid
	
	static False(b) { return ["false", "0"].includes("" + b); }
	static True(b) { return ["true", "1"].includes("" + b); }
	static Bool(b) { return ["false", "true", "0", "1"].includes("" + b); }

	static Array(a, opts={}) { console.log("Array heeeeere:", a, a.length, opts, this.Opts(a.length, opts)); return Array.isArray(a) && this.Opts(a.length, opts); }
	static Object(o, opts={}) { return typeof(o) == "object" && !Array.isArray(o) && this.Opts(length(o), opts); }
	static In(o) { return (Array.isArray(o)) ? o.includes(this.x) : this.x in o }

	static Min(min, opts={}) { return opts.inclusive ? this.x >= min : this.x > min; }
	static Max(max, opts={}) { return opts.inclusive ? this.x <= max : this.x < max; }
	static Between(min, max, opts={}) { return this.Opts(i, {...opts, min: min, max: max}); }
	
	static Opts(i, opts={min:false, max:false}) {
		this.x = i;
		if (opts.inclusive == undefined) opts.inclusive = true;
		if (typeof opts.min == "number" && !is.Min(opts.min, opts)) { return false; }
		if (typeof opts.max == "number" && !is.Max(opts.max, opts)) { return false; }
		return true;
	}
}

// Works as the range() Python function
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from
const range = (start, stop, step=1) =>
  Array.from(
    { length: Math.ceil((stop - start) / step) },
    (_, i) => start + i * step,
  );

// Helper used to quickly log data during testing
// Can use property value shorthand log({var1, var2, ...}) to get a more detailed console message
function log(...args) {
	var callFunction = "unknown";
	(new Error().stack.split('\n').slice(2)).every(call => {
		var functionName = call.slice(6).match(/\w+/)[0]; 
		if (functionName != "eval") {
			callFunction = functionName;
			return false;
		}
		return true;
	})
	const styleName = "color: purple; font-weight: bold";
	const styleNumber = "color: darkblue; margin-bottom: 4px";
	const styleString = "color: black; margin-bottom: 4px";
	var logText = `%cLog: ${callFunction}%c\n`;
	var logStyle = ["font-weight: bold; padding: 2px; margin-bottom: 2px; margin-right: 45%; background-color: lightgrey; border: 1px solid darkgrey; border-radius: 4px", styleName]
	var logObjects = []

	args.forEach(variable => {
		if (typeof variable == "object") {
			for (const [key, value] of Object.entries(variable)) {
				switch (typeof value) {
					case "object": case "array":
						logObjects.push(`${key}:`, value, "\n");
						break;
					case "number":
						logText += `%c${key}: %c${value}\n`;
						logStyle.push(styleName, styleNumber);
						break;
					default:
						logText += `%c${key}: %c${value}\n`;
						logStyle.push(styleName, styleString);
						break;
				}
			}
		} else if (typeof variable == "array") {
			logObjects.push(variable, "\n")
		} else {
			logText += `%c(${typeof variable}): %c${variable}\n`;
			logStyle.push(styleName, styleString);
		}
	});
	console.log.apply(console, [logText.slice(0,-1), ...logStyle, ...logObjects]);
}

// Helper used to package and unpackage data transferred through action buttons
// Read more about this system at https://app.roll20.net/forum/post/10346883/adventures-with-startroll/?pageforid=10346884#post-10346884
const Data = {
    chars: {
        '"': '%quot;',
        ',': '%comma;',
        ':': '%colon;',
        '}': '%rcub;',
        '{': '%lcub;',
		')': '&rpar;',
		'(': '&lpar;',
    },
    package(data) {
		data = (typeof(data) === 'object') ? JSON.stringify(data) : (typeof(data) === 'string') ? data : null;
        data = (data) ? `${data}`.replace(new RegExp(`[${Object.keys(this.chars)}]`, 'g'), (r) => this.chars[r]) : null;
		return data.replaceAll(']','%rbrack;').replaceAll('[','%lbrack;');
    },
    unpackage(data) {
		data = data.replaceAll('%rbrack;',']').replaceAll('%lbrack;','[');
		data = `${data}`.replace(new RegExp(`(${Object.values(this.chars).join('|')})`, 'g'), (r) => Object.entries(this.chars).find(e=>e[1]===r)[0]);
        return JSON.parse(data);
    }
}
/* --- Generic helper functions end --- */

</script>





